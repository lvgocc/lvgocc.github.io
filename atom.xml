<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Star Dust 星尘</title>
  
  <subtitle>亦或繁星、亦或尘埃。不要抱怨，坚持下去</subtitle>
  <link href="http://lvgo.org/atom.xml" rel="self"/>
  
  <link href="http://lvgo.org/"/>
  <updated>2020-12-07T13:20:32.000Z</updated>
  <id>http://lvgo.org/</id>
  
  <author>
    <name>lvgo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>和 lvgo 一起学设计模式（二十三）行为型之解释器模式</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-interpreter.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-interpreter.html</id>
    <published>2020-12-07T13:20:32.000Z</published>
    <updated>2020-12-07T13:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>这篇是<strong>《和 lvgo 一起学设计模式》</strong>系列的最后一个设计模式了，这篇就轻松一些吧。</p><h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h1><blockquote><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p></blockquote><p>因为时代的发展、技术的更替等等原因（你想做的解释器都有人做好了，且开源）吧，可能这个是我们很长一段时间都用不到的一种设计模式了。</p><h2 id="你能看懂TA的“眼色”吗？"><a href="#你能看懂TA的“眼色”吗？" class="headerlink" title="你能看懂TA的“眼色”吗？"></a>你能看懂TA的“眼色”吗？</h2><p>还记得那些年看过的影视剧吗？或是表情包吗？</p><p><img src="https://i.loli.net/2020/12/03/dFSRYxU9AEDji4v.jpg" alt="interpreter-1.jpg"></p><p><img src="https://i.loli.net/2020/12/03/pazvAJuBRKZhkco.jpg" alt="interpreter-2.jpg"></p><p>你能看懂柯镇恶和“老婆”的眼色吗？</p><p>反正我是看不懂，单是看这情况，完全看不懂是什么意思。</p><p>但如果我提前给你说下规则呢？</p><p><strong>柯镇恶图</strong></p><ol><li>柯镇恶往左摆头，冲！</li><li>柯镇恶往右摆头，撤！</li></ol><p><strong>“老婆”图</strong></p><ol><li>“老婆”坐在坐垫上，生气！</li><li>“老婆”坐在摩的后面架子上，开心！</li></ol><p>那这个时候再看他们的“眼色”，你能看懂了吗？如果有了上面的定义，我便知道了：</p><ul><li>柯镇恶的意思是冲！（假设是往左摆头了）</li><li>“老婆”很开心！</li></ul><h2 id="再谈解释器模式"><a href="#再谈解释器模式" class="headerlink" title="再谈解释器模式"></a>再谈解释器模式</h2><p><u>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</u></p><p>定义一个语言：“眼色”</p><p>定义他的文法表示：“摆头”、“坐的位置”</p><p>定义解释器：“规则”</p><p>这样我们就可以通过这个解释器来了解TA了。</p><p><strong>给定一个”眼色“，定义”摆头“或”坐的位置“，并定义一个规则，这样就可以解释图中的柯镇恶和”老婆“了。</strong></p><h2 id="解释器模式类图-📌"><a href="#解释器模式类图-📌" class="headerlink" title="解释器模式类图 📌"></a>解释器模式类图 📌</h2><p><img src="https://i.loli.net/2020/12/03/IrtOF8hdjB3PDnG.png" alt="interpreter-UML.png"></p><p>这个结构比较简单，定义一个解释接口，然后就是两个具体的解释器</p><ol><li>最终解释器</li><li>非最终解释器</li><li>环境</li></ol><p>这两个有点像组合模式中的子节点和叶节点的意思。这里的 <code>NonTerminalExpression </code> 是可以有多个的；</p><p>这里最麻烦的其实是 <code>Context</code> 环境。</p><h2 id="代码-📃"><a href="#代码-📃" class="headerlink" title="代码 📃"></a>代码 📃</h2><p>我们来看看代码来实现上面的”眼色“</p><blockquote><p>完整代码关注回复“源码”获取。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;<br>    EyeColor eyeColor = <span class="hljs-keyword">null</span>;<br>    Context context = <span class="hljs-keyword">new</span> Context(<span class="hljs-string">&quot;柯镇恶往左摆头 | 老婆坐在了架子上&quot;</span>);<br>    String content = context.getContent();<br>    String[] strings = content.split(<span class="hljs-string">&quot;\\|&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strings.length; i++) &#123;<br>        String string = strings[i];<br>        context.setContent(string);<br>        <span class="hljs-keyword">if</span> (string.contains(<span class="hljs-string">&quot;柯镇恶&quot;</span>)) &#123;<br>            eyeColor = <span class="hljs-keyword">new</span> KeZhenE();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (string.contains(<span class="hljs-string">&quot;老婆&quot;</span>)) &#123;<br>            eyeColor = <span class="hljs-keyword">new</span> Wife();<br>        &#125;<br>        <span class="hljs-keyword">assert</span> eyeColor != <span class="hljs-keyword">null</span>;<br>        eyeColor.interpreter(context);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KeZhenE</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EyeColor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (context.getContent().contains(<span class="hljs-string">&quot;左摆头&quot;</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;冲！&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (context.getContent().contains(<span class="hljs-string">&quot;右摆头&quot;</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;撤！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wife</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EyeColor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (context.getContent().contains(<span class="hljs-string">&quot;座椅&quot;</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;生气！&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (context.getContent().contains(<span class="hljs-string">&quot;架子&quot;</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;开心！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">冲！<br>开心！<br></code></pre></td></tr></table></figure><h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>通过上面的内容我们了解到，<strong>解释器可以自己定义一些规则和对应的解释规则</strong>，<strong>来完成一些复杂的事情</strong>，这样就使得可以用一个简单的“动作”来达成一件复杂的事情。你看柯镇恶一个眼色，我就知道他想冲，他省去了复杂的“张嘴”过程。</p><p>其实解释器模式就像是我们现在用高级语言来开发软件程序一样，是怎么才能让计算机知道我们在说什么呢？其实这就是解释器的作用，我们按照一定规则（语法）来编写代码，然后解释器按照定义好的规则来将我们的代码翻译成机器认识的 01 代码。</p><p>对于解释器，它将复杂的事自己“包揽”了，但是一旦<strong>发生新的规则</strong>，你就<strong>不得不去修改“包揽”的复杂解析过程</strong>。</p><p>在今天，解释器模式应该很少会在我们的应用自己去设计了，毕竟这如同设计一门语言一样，过程很复杂，还记得我们正在用的正则表达式吗？他就是一个轻量级的语言，如果有能力有机会的时候，也可以挑战一下，开发一个自己的语言。</p>]]></content>
    
    
    <summary type="html">　　“你能看懂TA的“眼色”吗？”</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>和 lvgo 一起学设计模式（二十二）行为型之访问者模式</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-visitor.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-visitor.html</id>
    <published>2020-12-06T13:20:32.000Z</published>
    <updated>2020-12-06T13:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><blockquote><p>将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。</p></blockquote><p>刚看到这个模式的时候，我人都傻了，完全不知道说的是啥，直到看了近5份资料！才搞清楚这个设计模式，不愧是最复杂的一种，我也这样觉得。不过千万别被复杂吓到，捋清了之后，还是比较简单的。</p><h2 id="开门见山"><a href="#开门见山" class="headerlink" title="开门见山"></a>开门见山</h2><p>访问者模式“人如其名”，就是说不同的访问者对同一个对象的访问结果不同。为什么会不同呢？因为这个访问者是我们自己定义的，我们就想让他不同😂。</p><p>而实际情况更是如此。我通过几份资料总结下来，这个访问者模式所谓的访问者其实就是我们想要控制的访问权限一样。因为任何一个“访问者”都可以看到具体数据的全部内容，他只是选择性的”不看“，这样便区分开了”访问者“<strong>关注的内容</strong>，或者<strong>”限制“了”访问者“的权限</strong>。</p><p>可能我说的有点绕，有点抱歉，我再简化一下这个内容。</p><h2 id="网络用语"><a href="#网络用语" class="headerlink" title="网络用语"></a>网络用语</h2><p><strong>抛开表象看本质</strong></p><p>如果我们抛开访问者模式这些专业的定义，单纯的去理解这个访问者模式要表达的意思，我觉得用一个东西最合适不过。那就是“网络用语”；</p><p>不知道大家听没听过前阵子火了的百度广告《你说啥》单曲。歌曲中的朝阳大妈就是一个不知道关注点或者是被限制了访问权限的访问者，当然他歌曲中说的网络语有好多我也不知道是啥🙃。没听过的快去听吧。</p><p>还有最近的 <code>凡尔赛文学</code> 我不百度的时候以为是个地名，所以我的 <code>权限</code> 也被限制了。</p><p>正好提到这个了，那我们就拿 <code>凡尔赛文学</code> 这个网络语来学习一下访问者模式吧~🤩</p><h2 id="凡尔赛文学"><a href="#凡尔赛文学" class="headerlink" title="凡尔赛文学"></a>凡尔赛文学</h2><p><strong>首先我们就要再一次抛开表象看本质😂</strong></p><p>下面是我搜集到有关凡尔赛的释义：</p><ol><li>凡尔赛是法国巴黎的卫星城以及伊夫林省省会，曾是法兰西王朝的行政中心。</li><li>《凡尔赛》是皮埃尔·苏勒执导的剧情片。</li><li>以法国路易十四为时代背景的电视剧。</li><li>凡尔赛文学，网络热词，指通过先抑后扬、自问自答或第三人称视角，不经意间露出”贵族生活的线索”。</li><li>啥？？？</li></ol><p>对于凡尔赛一共有 5 种释义，他的结构应该是这样的</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Versailles</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation1 = <span class="hljs-string">&quot;凡尔赛是法国巴黎的卫星城以及伊夫林省省会，曾是法兰西王朝的行政中心。&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation2 = <span class="hljs-string">&quot;《凡尔赛》是皮埃尔·苏勒执导的剧情片。&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation3 = <span class="hljs-string">&quot;以法国路易十四为时代背景的电视剧。&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation4 = <span class="hljs-string">&quot;凡尔赛文学，网络热词，指通过先抑后扬、自问自答或第三人称视角，不经意间露出\&quot;贵族生活的线索\&quot;。&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation5 = <span class="hljs-string">&quot;啥？？？&quot;</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>因为我们还要对这个数据进行访问，所以还要给他加个访问的方法 #visit</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Versailles</span> </span>&#123;<br><br>   .....<br>       ....<br>       ...<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 访问</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然要访问，肯定要有访问者啊，因为访问者挺多的，比如我、我的小伙伴、还有你，所以我们就使用依赖倒置原则来定义一个访问者接口 <code>Visitor</code> 然后有个访问方法，再把凡尔赛给访问者去让其自己访问，那代码实现起来应该是这样的。</p><p> <code>Visitor</code>接口</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Visitor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Versailles versailles)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>凡尔赛的访问方法调整一下，最终完整类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Versailles</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation1 = <span class="hljs-string">&quot;凡尔赛是法国巴黎的卫星城以及伊夫林省省会，曾是法兰西王朝的行政中心。&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation2 = <span class="hljs-string">&quot;《凡尔赛》是皮埃尔·苏勒执导的剧情片。&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation3 = <span class="hljs-string">&quot;以法国路易十四为时代背景的电视剧。&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation4 = <span class="hljs-string">&quot;凡尔赛文学，网络热词，指通过先抑后扬、自问自答或第三人称视角，不经意间露出\&quot;贵族生活的线索\&quot;。&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation5 = <span class="hljs-string">&quot;啥？？？&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将该对象提供给访问者访问</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> visitor 访问者</span><br><span class="hljs-comment">     * 方法名改成 accept 更好，表示这个类接受一个访问者来访问自己🙅</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span></span>&#123;<br>        visitor.visit(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就是具体的访问者了，那我根据实际情况来定义一些访问者</p><ol><li>I</li><li>MyFriend</li><li>You</li></ol><p>一共三个访问者</p><p><strong>I</strong>（我自己）</p><p>我比较博学多识，我知道凡尔赛是地名、电影、电视剧三个</p><p><strong>MyFriend</strong>（狗哥）</p><p>看他的样子应该是不知道</p><p><img src="https://i.loli.net/2020/12/03/fBnOdChGT9mZ2Yj.png" alt="visitor-unkown.png"></p><p><strong>You</strong>（你呢？）</p><p>我就当你知道凡尔赛文学，已经领悟到了无形装逼的境界好了🌚</p><p>看下这三个类的情况</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 我比较博学多识</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 欢迎跟我一起学习，微信（lvgocc）公众号搜索：星尘的一个朋友</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@blog</span> <span class="hljs-doctag">@see</span> http://lvgo.org</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CSDN</span> <span class="hljs-doctag">@see</span> https://blog.csdn.net/sinat_34344123</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">I</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Visitor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Versailles versailles)</span> </span>&#123;<br>        System.out.println(versailles.getInterpretation1());<br>        System.out.println(versailles.getInterpretation2());<br>        System.out.println(versailles.getInterpretation3());<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 弱智狗哥</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFriend</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Visitor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Versailles versailles)</span> </span>&#123;<br>        System.out.println(versailles.getInterpretation5());<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 网络达人</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">You</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Visitor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Versailles versailles)</span> </span>&#123;<br>        System.out.println(versailles.getInterpretation4());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们在模拟一下运行起来的情况</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VisitorTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span> </span>&#123;<br>        Versailles versailles = <span class="hljs-keyword">new</span> Versailles();<br><br>        System.out.println(<span class="hljs-string">&quot;lvgo 你知道凡尔赛吗？&quot;</span>);<br>        versailles.accept(<span class="hljs-keyword">new</span> I());<br><br>        System.out.println(<span class="hljs-string">&quot;\n狗哥 你知道凡尔赛吗？&quot;</span>);<br>        versailles.accept(<span class="hljs-keyword">new</span> MyFriend());<br>        <br>        System.out.println(<span class="hljs-string">&quot;\n你知道凡尔赛吗？&quot;</span>);<br>        versailles.accept(<span class="hljs-keyword">new</span> You());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果，狗哥拉胯</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">lvgo 你知道凡尔赛吗？<br>凡尔赛是法国巴黎的卫星城以及伊夫林省省会，曾是法兰西王朝的行政中心。<br>《凡尔赛》是皮埃尔·苏勒执导的剧情片。<br>以法国路易十四为时代背景的电视剧。<br><br>狗哥 你知道凡尔赛吗？<br>啥？？？<br><br>你知道凡尔赛吗？<br>凡尔赛文学，网络热词，指通过先抑后扬、自问自答或第三人称视角，不经意间露出<span class="hljs-string">&quot;贵族生活的线索&quot;</span>。<br></code></pre></td></tr></table></figure><p>不同的访问者，看到数据结构中的结果不同。再来看下访问者的定义</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。<br></code></pre></td></tr></table></figure><p>虽然我们这里用的是一个对象，试着将它变成集合（多个网络语而已）吧。使用循环把每个元素都“送”给访问者，这个就留着给你动手试试吧，也留给自己以后回来看的时候能被逼动动脑😂。实在不想动，关注回复 “源码” 吧！😀</p><h2 id="访问者模式类图-📌"><a href="#访问者模式类图-📌" class="headerlink" title="访问者模式类图 📌"></a>访问者模式类图 📌</h2><p>最后，我们来看下标准的访问者模式结构图</p><p><img src="https://i.loli.net/2020/12/03/mKRj7h6eZVp2gt8.png" alt="visitor-UML.png"></p><p>这个结构比较复杂</p><ol><li>客户端高层模块 <code>Client</code>；</li><li>访问者接口，依赖倒置接口 <code>Visitor</code>；</li><li>被访问的元素，<code>Element</code>；</li><li>最后一个，<code>ObjectStructure</code> 对象结构；</li></ol><p>这里唯一可能需要解释的就是这个 <code>ObjectStructure</code> 了，他即用于来定义管理 <code>Element</code> 的对象载体。它可以是我们业务场景中任何需要被访问元素的载体对象，比如上述例子中，我们想把这个结构放进去那我就可以定义一个词语类 <code>Word</code> ，里面可以有 <code>NetWordLanguage</code>，<code>Professional vocabulary</code> 等等对象。如下所示</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Word</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 网络语</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;NetWordLanguage&gt; netWordLanguages = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addWord</span><span class="hljs-params">(NetWordLanguage netWordLanguage)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!netWordLanguages.contains(netWordLanguage))&#123;<br>            netWordLanguages.add(netWordLanguage);   <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>访问者全部源代码关注回复 “源码” 获取</p></blockquote><h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>访问者模式适合在<strong>数据结构稳定</strong>的系统中，即很少或不变的数据结构场景；</p><p>当你想要对一个数据集合增加一些不同的使用规则，或者是“权限”控制时，可以考虑使用访问者模式，并要一同考虑数据结构是否稳定（是否会在增加类），因为这会导致访问者需要“重构”。</p><p><strong>解决的问题：</strong></p><ol><li>访问者模式使数据结构与数据访问分离</li><li>可以很灵活的增加不同的访问规则</li></ol><p><strong>自身的问题：</strong></p><ol><li>一旦出现数据结构变更（新增类型），将会使访问者发生较大的修改，因为需要调整访问者接口！严重违反了开闭原则</li></ol>]]></content>
    
    
    <summary type="html">　　“是“凡尔赛”让我“认清”了访问者模式！”</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>和 lvgo 一起学设计模式（二十一）行为型之中介者模式</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-mediator.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-mediator.html</id>
    <published>2020-12-05T13:20:32.000Z</published>
    <updated>2020-12-05T13:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><blockquote><p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p></blockquote><p>与其说中介者模式还不如说是软件设计原则的具体体现。这个原则就是——迪米特法则。</p><p><em>这里可以参考之前的系列文章<strong>《和 lvgo 一起学习设计模式 - 序》</strong>中的软件设计基本原则 6 迪米特法则</em></p><ul><li>6️⃣ 迪米特法则又叫作最少知识原则 LOD/LKP ，1987 年美国东北大学👨‍🎓（Northeastern University）的一个名为迪米特（Demeter）的研究项目，由伊恩·荷兰（Ian Holland）提出，被 UML 创始人之一布奇（Booch）🧙‍♂️普及，后来又在经典著作《程序员修炼之道》📕中提及，从而传播开来。原则定义：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：<u>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用</u>。其目的是降低类之间的耦合度，提高模块的相对独立性。</li></ul><p>通过这个原则的核心内容我们知道，迪米特法则（中介者模式）要解决的问题就是提高软件程序的聚合度、降低对象之间的耦合。</p><h2 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h2><h3 id="王二入职"><a href="#王二入职" class="headerlink" title="王二入职"></a>王二入职</h3><p>前阵子王二刚刚毕业，入职了一家公司，报道的第一天，人事将王二带到部门后介绍了接头人就走了，王二坐在座位上等待人“接待”他，等了20分钟，没人管他，于是他起身去找了当时的部门接头人旺仔。</p><p>“仔哥，我~“，”啊，我知道，你新来的“。”我还没电脑“</p><p>“没电脑？你去找那个角落里，那是网管，问他们要一台”，”好的“</p><p>王二初来乍到，总觉得哪里不对，又不好意思说，就去角落里问：”您好，我是xxx部新来的，需要领台电脑“，”啊，去找你组长申请“。</p><p>“仔哥，那面叫我来和组长申请。我组长是谁啊？”，“我啊，我就是你组长，跟我申请”。王二没说话。“把这个表格打出来，填一下，给我和部门经理签字”，“仔哥，去哪里打印？”，“茶水间边上的房间，找打印机管理员”。</p><p>王二蹑手捏脚的过去了，到了那里“您好，我想打份申请单。” “什么申请？”，“离职申请。“王二淡定的说。</p><p><img src="https://i.loli.net/2020/12/03/6v5UQJkTwA8YqBZ.png" alt="mediator-wanger-ruzhi.png"></p><h3 id="王二找房"><a href="#王二找房" class="headerlink" title="王二找房"></a>王二找房</h3><p>王二最终找到了一个让他满意的地方，然后开始找地方住，所以他开始了繁忙的 “找房之旅” ，一开始，王二一口气就找到了三个房东</p><p><img src="https://i.loli.net/2020/12/03/SBtYkczJxvgPwIm.png" alt="mediator-wanger-zufang.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">房东一 = <span class="hljs-number">10</span>平米，无窗<br>房东二 = <span class="hljs-number">20</span>平米，半个窗<br>房东三 = <span class="hljs-number">1000</span>平米，<span class="hljs-number">108</span>个窗<br></code></pre></td></tr></table></figure><p>找了很多，王二也没找到自己心仪的，而此时的王二已经累了。</p><p><img src="https://i.loli.net/2020/12/03/RdHNVnpkZlYjXtf.png" alt="mediator-wanger-zufang2.png"></p><p>最后经历了第 10 个房东的时候，王二终于找到自己满意的房子了。</p><p><del><strong>通过这件事我们知道了买房的重要性</strong></del></p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><h3 id="王二入职-1"><a href="#王二入职-1" class="headerlink" title="王二入职"></a>王二入职</h3><p>如果你是这家公司的人事，你会怎么来安排一个新同事的到来的各种事情呢，或者说怎么管理公司间同事的交叉问题呢？</p><p>如果是我的话，我会制定一个专员负责管理同事间的诉求，比如人事专员、行政专员等等，当然还可以设立其他专员来解决这种类似的问题。</p><p>有了专员之后，专员就负责在各种业务流程上起引导督促等作用。比如刚刚王二入职，人事专员需负责跟踪引导其完成入职知道可以开展工作之前的相关事项。于此同时，王二只需要和人事专员进行通信，其中间的流程步骤变得清晰了很多。</p><p>王二：“你好，我这里没有电脑”</p><p>人事专员：“已经再给你申请了，稍等”</p><p>王二：“好的”</p><p>过了，20分钟</p><p>设备管理员：“电脑登记好了，给你吧”</p><p>人事专员：“好的，我给王二送过去，<strong>你也不认识他</strong>”；</p><p>人事专员：“王二，这是你的电脑，编号在背面，有什么问题再联系我”</p><p>通过专员的加入，解耦了各个同事之间的耦合，同时降低了各个同事间复杂的交互，<del>也避免了不必要的“人才流失”</del></p><p><img src="https://i.loli.net/2020/12/03/XYe7vWomLqV3FKs.png" alt="mediator-wanger-ruzhi2.png"></p><h3 id="王二找房-1"><a href="#王二找房-1" class="headerlink" title="王二找房"></a>王二找房</h3><p>因为有了输入就会有输出，王二给市场上输入了一种“找房”的需求，市场自然而然的反馈回来一个输出，那就是“房屋中介”</p><p>当有了“房屋中介”的加入，王二就没那么辛苦了，并且各个房东的资源因为在“房屋中介”这也会让“租房”变得高效起来。</p><p><img src="https://i.loli.net/2020/12/03/NUi32SgBvtb6X4E.png" alt="mediator-wanger-zufang3.png"></p><h2 id="中介者模式类图-📌"><a href="#中介者模式类图-📌" class="headerlink" title="中介者模式类图 📌"></a>中介者模式类图 📌</h2><p><img src="https://i.loli.net/2020/12/03/hHZYAVLNRWvd2za.png" alt="mediator-UML.png"></p><p>模式结构：</p><ol><li>中介者接口 Mediator</li><li>具体中介者 ConcreteMediator</li><li>同事抽象类 Colleague</li><li>具体同事 ConcreteColleague</li></ol><p><em>多学一点：在设计模式中发现几乎所有的模式结构图中，都会有接口或者抽象类，这其实是依赖倒置的默认思路，任何的程序设计这一点原则都要优先考虑。</em></p><h2 id="代码-📃"><a href="#代码-📃" class="headerlink" title="代码 📃"></a>代码 📃</h2><blockquote><p>篇幅和过长代码展示原因：完整代码关注回复 “ <strong>源码</strong> “ 获取。</p></blockquote><p>这里通过王二入职案例的解决方案为背景，用程序来表示一下如何解决多个对象间复杂交错导致程序难以维护最终崩溃（离职）的问题。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HRTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;<br>        HR hr = <span class="hljs-keyword">new</span> HR();<br>        DeviceManager deviceManager = <span class="hljs-keyword">new</span> DeviceManager(hr);<br>        hr.addColleague(deviceManager);<br>        WangEr wangEr = <span class="hljs-keyword">new</span> WangEr(hr);<br>        hr.addColleague(wangEr);<br>        WangZai wangZai = <span class="hljs-keyword">new</span> WangZai(hr);<br>        hr.addColleague(wangZai);<br><br>        wangEr.send(<span class="hljs-string">&quot;我没有电脑&quot;</span>);<br>        deviceManager.send(<span class="hljs-string">&quot;设备管理员下发一台电脑&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">设备管理员收到消息：我没有电脑<br>王二收到消息：设备管理员下发一台电脑<br></code></pre></td></tr></table></figure><h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p><strong>解决的问题</strong></p><ol><li>在 1 对多对象关系中，可以通过 <code>中介者模式</code> 来解耦，达成 1 对 1 的松耦合关系。</li></ol><p><strong>存在的问题</strong></p><ol><li><code>中介者模式</code> 自身有个隐患问题，就是中介者自己本身知道了太多的内容。稍有不慎，就会导致 <code>同事</code> 的信息出现问题。</li><li>由于 <code>中介者模式</code>  本身的原因，这个 <code>中介者</code> 会变得特别复杂。（对象间的复杂转换成成了类复杂，两权相害取其轻的道理。）</li><li>在 多对多 的问题上，最好仔细的考虑一下，甚至考虑要不要用这种模式。</li></ol>]]></content>
    
    
    <summary type="html">　　“还记得你到单位入职的第一天吗？你有没有遇到文中‘王二’的事呢？”</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>和 lvgo 一起学设计模式（二十）行为型之状态模式</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-state.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-state.html</id>
    <published>2020-12-04T13:20:32.000Z</published>
    <updated>2020-12-04T13:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><blockquote><p>允许一个对象在其内部状态发生改变时改变其行为能力。</p></blockquote><p>我刚开始看到这个模式的时候，没啥感觉，不知道这东西要说的是个啥，后来看了个案例，渐渐清楚了，这个模式本身还是比较简单的。</p><h2 id="小菜的工作状态"><a href="#小菜的工作状态" class="headerlink" title="小菜的工作状态"></a>小菜的工作状态</h2><blockquote><p>这个案例出自程杰的《大话设计模式》，抽取案例模型，完整案例还请大家自行阅读</p></blockquote><p>案例说的是主人公“小菜”上班写代码时的各种状态，上午的时候精神饱满，中午时有点萎靡，下午状态一般，晚上状态疲惫。然后这一天各个时段的写代码状态用程序表达出来是这个样子的；</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Work</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> clock;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 上午 9 点</span><br>        clock = <span class="hljs-number">9</span>;<br>        writeCode();<br>        <span class="hljs-comment">// 中午 12 点</span><br>        clock = <span class="hljs-number">12</span>;<br>        writeCode();<br>        <span class="hljs-comment">// 下午 15 点</span><br>        clock = <span class="hljs-number">15</span>;<br>        writeCode();<br>        <span class="hljs-comment">// 晚上 21 点</span><br>        clock = <span class="hljs-number">21</span>;<br>        writeCode();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (clock &lt; <span class="hljs-number">12</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;精神抖擞写代码&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clock &lt; <span class="hljs-number">13</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;饿了困了写代码&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clock &lt; <span class="hljs-number">17</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;状态一般写代码&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clock &lt; <span class="hljs-number">23</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;加班疲惫写代码&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一段典型的面向过程编程代码，之后根据面向对象的思想来改了一版变成了这样。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OOPWork</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Working working = <span class="hljs-keyword">new</span> Working();<br>        <span class="hljs-comment">// 上午 9 点</span><br>        working.clock = <span class="hljs-number">9</span>;<br>        working.writeCode();<br>        <span class="hljs-comment">// 中午 12 点</span><br>        working.clock = <span class="hljs-number">12</span>;<br>        working.writeCode();<br>        <span class="hljs-comment">// 下午 15 点</span><br>        working.clock = <span class="hljs-number">15</span>;<br>        working.writeCode();<br>        <span class="hljs-comment">// 晚上 21 点</span><br>        working.clock = <span class="hljs-number">21</span>;<br>        working.writeCode();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Working</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> clock;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (clock &lt; <span class="hljs-number">12</span>) &#123;<br>            <span class="hljs-keyword">new</span> MorningState();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clock &lt; <span class="hljs-number">13</span>) &#123;<br>            <span class="hljs-keyword">new</span> NoonState();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clock &lt; <span class="hljs-number">17</span>) &#123;<br>            <span class="hljs-keyword">new</span> AfterNoonState();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clock &lt; <span class="hljs-number">23</span>) &#123;<br>            <span class="hljs-keyword">new</span> EveningState();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MorningState</span> </span>&#123;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;精神抖擞写代码&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoonState</span> </span>&#123;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;饿了困了写代码&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AfterNoonState</span> </span>&#123;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;状态一般写代码&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EveningState</span> </span>&#123;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;加班疲惫写代码&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实写到这里我相信大家就算没看过这本书也能多少发现一点端倪，就是这个 Working 类是不是有点奇怪。每新增一个状态就要去改这个类，而且这里负责了全部的工作状态，还有最关键的就是这个 <code>if else</code> 是不是有点太长了？？？没错，其实这些都可以用 <code>状态模式</code> 来规避掉，并且这些在软件设计中也都违反了一些原则或建议。</p><ol><li>每新增一个状态就要去改这个类（违反了 <code>开闭原则</code>）</li><li>而且这里负责了全部的工作状态（违反了 <code>单一职责原则</code>）</li><li>还有最关键的就是这个 <code>if else</code> 是不是有点太长了？？？（这是 <code>重构</code> 书中提到的 <code>long method</code> 的坏味道）</li></ol><h2 id="利用状态模式解决这-3-个问题"><a href="#利用状态模式解决这-3-个问题" class="headerlink" title="利用状态模式解决这 3 个问题"></a>利用状态模式解决这 3 个问题</h2><p>首先来看下状态模式的结构类图</p><h3 id="状态模式类图-📌"><a href="#状态模式类图-📌" class="headerlink" title="状态模式类图 📌"></a>状态模式类图 📌</h3><p><img src="https://i.loli.net/2020/11/29/YWsdEVzrgFheG3A.png" alt="state-UML"></p><p>这里有几个关键的角色</p><ol><li>运行的上下文环境 <code>Context</code> 对应到程序中就是 <code>Working</code> 类</li><li>状态接口 <code>State</code> 这是为了解决单一职责和开闭原则；</li><li>具体的状态，也就是 <code>State</code> 接口的实现</li></ol><h3 id="状态模式代码-📃"><a href="#状态模式代码-📃" class="headerlink" title="状态模式代码 📃"></a>状态模式代码 📃</h3><p>将上面的写法改成用状态模式的话就长这个样子</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writeCode</span><span class="hljs-params">()</span> </span>&#123;<br>    Working working = <span class="hljs-keyword">new</span> Working(<span class="hljs-keyword">new</span> MorningState());<br>    <span class="hljs-comment">// 手动模拟不同时刻</span><br>    working.setClock(<span class="hljs-number">9</span>);<br>    working.writeCode();<br><br>    working.setClock(<span class="hljs-number">12</span>);<br>    working.writeCode();<br><br>    working.setClock(<span class="hljs-number">15</span>);<br>    working.writeCode();<br><br>    working.setClock(<span class="hljs-number">21</span>);<br>    working.writeCode();<br><br><br>    working.setClock(<span class="hljs-number">24</span>);<br>    working.writeCode();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Working</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前工作状态</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WorkState concurrentState;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前时刻</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> clock;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Working</span><span class="hljs-params">(WorkState concurrentState)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.concurrentState = concurrentState;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeCode</span><span class="hljs-params">()</span> </span>&#123;<br>        concurrentState.handle(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    ....<br>    ....<br>    <span class="hljs-comment">// 篇幅原因，完整代码关注回复“源码”获取。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">精神抖擞写代码<br>饿了困了写代码<br>状态一般写代码<br>加班疲惫写代码<br>别再写了，程序员回家了，明早再试吧😢，现在都已经<span class="hljs-number">24</span>点了。放过他吧<br></code></pre></td></tr></table></figure><blockquote><p>篇幅原因，完整代码关注回复“源码”获取。</p></blockquote><p>这样不仅消除了 <code>if else</code> 的臃肿 <code>long method</code> 坏味道代码，同时 Working 类更专注 “写代码”，同时有 <code>State</code> 接口的出现，实现了开闭原则，让程序的扩展的到了保障，并且一个关键的内容就是“在不同时刻，调用 writeCode 方法的结果是不同的。这也是状态模式的定义中提到的 <code>一个对象在其内部状态发生改变时改变其行为能力。</code> 改变对象的一个状态，使他的行为也发生了变化，这看起来就像我们对这个类的代码进行了修改一样。</p><h2 id="状态模式延伸"><a href="#状态模式延伸" class="headerlink" title="状态模式延伸"></a>状态模式延伸</h2><p>如果大家有做过交易系统的订单的话，有一个东西应该不会陌生，叫做 <code>有限状态机</code> 也叫做 <code>状态机</code>。</p><p><img src="https://i.loli.net/2020/11/29/ODt68sjlZchYk3M.png" alt="state-order"></p><p>这是正常情况，也就是如果一个订单按照正常步骤来流转是会按照上图所示来进行。但是，真实的订单场景远比这个要复杂的多。</p><p>这里我们只看一些简单的几个场景：</p><ol><li>提交订单之后突然心思转变，不买了，那这个时候给客户就是<code>取消订单</code>和<code>付款</code>两种选择，这一步发生的时候，订单状态为 <code>待付款</code>；</li><li>付款之后又看了看发现有更好的店铺选择，此时钱已经付了，所以此时的操作提供给客户的就是 <code>申请退款</code>，此时订单状态为 <code>待发货</code>；</li><li>等等订单场景较为复杂，不过万变不离其宗，即 <code>不同的状态，用户的操作行为和这笔订单之后的行为是有限的</code>；</li></ol><p>用一个图来看下上述几个问题场景</p><p><img src="https://i.loli.net/2020/11/29/gbnuih81x7ZYMBr.png" alt="state-exception-order"></p><p>我们可以通过图可以看到，即使只有这简单的两种情况，整个订单的处理逻辑就已经开始变得复杂了起来，如果利用传统的面向过程编程或简单的面向对象编程思路来设计这个订单流程逻辑，我想，第一版，也就是正常的订单流程开发实现起来问题应该“不大”，无非代码啰嗦一点、判断逻辑多一点。</p><p>不过一旦产品经理提出在付款时可以进行撤单操作、在发货时可以进行退款、发货前可以修改接收地址又或者收货时可以拒收等等这些需求时，我觉得这个业务应该不会有人愿意去开发了。</p><p>不是开发人员不愿意做这个业务，而是不愿意在糟糕的代码上进行再次迭代（当然在现实情况，一个糟糕的团队确有可能继续在糟糕的代码上继续迭代，原因很简单，因为他们从一开始便能设计出来，领导能通过就说明这是一个没有技术沉淀的团队，他们很愿意将一坨坨代码“至死不渝”的一直维护下去）。</p><p>如果订单状态利用 <code>状态模式</code> 来设计，无论状态如何变化，高层模块也永远不需要关心，这也是开闭与单一职责这两个原则的很好体现。在哪个状态能做哪些事情，完全有对应的状态说了算，即使在复杂的业务，也会因为状态的区分而是业务颗粒变得很小（如果传统的 <code>if else</code> 到底，整个业务流程必须全部重新测试一遍，这不是谁说的，这是由高耦合紧密设计决定的，逃不开），这一点在开发和测试上，都会大幅提高开发和测试效率和节省成本。</p><p>好了，关于这一块内容确实大家可以看看 <code>有限状态机</code> ，订单业务在实际情况是交由 <code>状态机</code> 来管理的。</p><h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>当你的应用程序可能会存在多种状态，而且每种状态的行为会随着状态的改变而改变，这时你可以考虑使用状态模式。通过状态模式不光可以使应用程序可以和应用状态可以很好的解耦，同时在状态的管理和扩展上都是非常的有帮助。</p><p>状态模式关键的几个点：</p><ol><li>应用环境的上下文，这个是用来作为状态模式的入口，他负责来调用当前状态的执行方法。</li><li>状态接口，这个接口负责管理全部的状态，这里在使用的时候需要好好设计，可以将整个业务所有的状态方法全部维护好，在具体接口类中间放一个抽象状态类，如果当前状态不能操作这个方法可以放在一个抽象类中来实现一个空方法，而不是子类去实现全部的接口方法。</li></ol><p>设计模式是一把双刃剑，在合理的时机使用可以达到很好的应用效果，反之亦然。大家要谨慎对待。不要变成手里只有一把锤子的人。</p>]]></content>
    
    
    <summary type="html">　　“从工作状态，再到订单状态一点点深入学习状态模式”</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>和 lvgo 一起学设计模式（十九）行为型命令之模式</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-command.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-command.html</id>
    <published>2020-12-03T13:20:32.000Z</published>
    <updated>2020-12-03T13:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/img_convert/4b0c6fc7d3e8ee4f4a942c404366a274.png#pic_center" alt="土方令"></p><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><blockquote><p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天一大早就来了图书馆🏫，刚坐下来就迫不及待的开始看命令模式的相关资料📚。不过这个模式跟我之前的理解出入特别大。</p><p>最开始的时候，我以为的命令模式就是<code>函数回调</code>。但后来发现并不是，但他们两个确实是有关系，这一切的答案都藏在 GOF 的设计模式一书中。</p><h2 id="开始学习"><a href="#开始学习" class="headerlink" title="开始学习"></a>开始学习</h2><p>在软件设计模式之始 GOF 的原著中，命令模式的讲解还是在他们开发的那个编辑工具中，其用来讲解的案例就是我们日常编辑使用的编辑工具中，在工具栏有很多个功能按钮，或者菜单按钮。 就比如编辑工具中的一个 <code>新增文件</code> 的按钮🆕吧。GOF 要表达的意思就是，这个 <code>新增文件</code> 对系统本身来讲就是给使用者提供的一个命令，我们在用的过程中可以给编辑器发送不同的命令，但是这个 <code>新增文件</code> 的操作并不是在这个按钮上实现的，同时对于我们发送命令的人来说，也不知道具体这个 <code>新增文件</code> 这个动作是由谁来执行、怎么执行，这对我们来讲完全是透明的。</p><p>我们先不讨论这样做的好处，先看下这里面要说的几个角色</p><ol><li>客户端应用</li><li><code>新增文件</code>按钮（调用新增文件操作命令）</li><li>操作命令</li><li>操作接收（负责具体的操作执行）</li></ol><p>我试着按照这个结构写了一下这个代码</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        FileReceiver fileReceiver = <span class="hljs-keyword">new</span> FileReceiver();<br>        AddFileCommand addFileCommand = <span class="hljs-keyword">new</span> AddFileCommand(fileReceiver);<br>        Invoker invoker = <span class="hljs-keyword">new</span> Invoker();<br>        invoker.setCommand(addFileCommand);<br>        invoker.executeCommand();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>客户端应用 <code>Client</code></li><li><code>新增文件</code>按钮（调用新增文件操作）<code>Invoker</code></li><li>操作命令 <code>AddFileCommand</code></li><li>操作接收者 <code>FileReceiver</code></li></ol><figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">新增文件<br></code></pre></td></tr></table></figure><h2 id="关于-‘命令’-的疑惑-🤔"><a href="#关于-‘命令’-的疑惑-🤔" class="headerlink" title="关于 ‘命令’ 的疑惑 🤔"></a>关于 ‘命令’ 的疑惑 🤔</h2><p>按照上面的方式实现下来，我有一种感觉，有种脱裤子放屁的感觉，我直接调用 FileReceiver 不香吗</p><p>非要这样</p><p><img src="https://i.loli.net/2020/11/28/oqEZfATCtK2UuQk.png" alt="command.png"></p><p>我以为，使用者利用按钮直接调用对应的操作不就行了吗？就像我下面这样中间非要放一个命令对象（将具体的请求包装成了这个对象）？</p><p><img src="https://i.loli.net/2020/11/28/SiylpQUYxGRAb91.png" alt="command-no-command"></p><h2 id="解惑-‘命令’-🤪"><a href="#解惑-‘命令’-🤪" class="headerlink" title="解惑 ‘命令’ 🤪"></a>解惑 ‘命令’ 🤪</h2><p>不过不久我就找到了答案💡</p><p>首先看下命令模式要解决的问题❔：<u>对请求排队、下载或记录请求日志，以及支持可撤消的操作。</u></p><p>然后我们开始思考🤔如果没有中间这个 “命令” 角色，那这些功能做在哪里？只能做在接收者，也就是逻辑具体的实现里面，那这是不是违背了一个设计原则，叫做 <code>单一职责原则</code> ？而且对这种 ”辅助型“ 的功能变多会导致逻辑实现类<strong>变得越来越”肿胀“</strong>，没错，就是”肿胀“！</p><p>并且这也使得调用者和实现者之间通过这个“命令”进行解耦，然后我们使用依赖倒置原则，将“命令”提取出来一个抽象类，这使得扩展请求也变得容易了。而且对于高层模块来说，自己完全不需要关心调用的时候具体的请求内容和实现内容，通过“命令”来完成自己的操作，比如点一个按钮、遥控器下的按键（从这里还可以看出，多个命令可以对应一个接受者，比如数字键的换台）、去餐厅点菜。这样一看，命令模式还真是符合这种设计思路的命名啊。</p><h2 id="命令模式类图-📌"><a href="#命令模式类图-📌" class="headerlink" title="命令模式类图 📌"></a>命令模式类图 📌</h2><p><img src="https://i.loli.net/2020/11/28/8HJOtxMFsq6PjoE.png" alt="command-UML"></p><p>主要结构</p><ol><li>调用者，也是暴露给客户端的对象 <code>Invoker</code></li><li>命令接口，<code>Command</code>（满足依赖倒置原则，便于扩展）</li><li>具体的命令，这里要包含谁来接受这个命令的接受者对象 <code>ConcreteCommand</code></li><li>命令的接收者，这里没有列实现类是因为任何类都可以是接收者 <code>Receiver</code></li></ol><h2 id="代码-📃"><a href="#代码-📃" class="headerlink" title="代码 📃"></a>代码 📃</h2><p>命令模式这篇使用的是通用框架写了一个实现，在这基础上事实上我们可以做很多扩展，比如再 <code>Invoker</code> 类中将 command 换成 <code>List&lt;Command&gt;</code> 来实现请求的排队、撤销等操作。</p><p><img src="https://i.loli.net/2020/12/03/ZE2fTd4FHQYhxeo.png" alt="image-20201128142121299"></p><h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p><strong>适用场景：</strong></p><ol><li>需要记录请求记录；</li><li>请求可以进行排队处理；</li><li>请求可以进行撤销、重做；</li><li>具体接收者来决定请求是否执行（关于这一点，如果请求不是封装成一个对象的话，判断起来是比较困难的）</li></ol><p>不过这种模式并不是一个常用的思想，一定是当你想要对请求做一些事情的时候才考虑，具体的事情就上面提到的 4 点，不然的话使用这种模式真的就是我上面说的，“脱裤子放屁了”。</p><p>最后再来一句话来总结一下命令模式，“张三，把门关一下”。这里我就是 Invoker，“把门关一下“ 就是 command （命令），“张三” 是 receiver （接收者）。更多时候，我们实际开发中，”把门关一下“ 都是定义好的，”我“直接选就行了，就像遥控器上的按键一样。但切记这个模式的使用时机，别做”恶心“人的事！</p><p>如果哪里有问题或者有疑问，欢迎加我微信（lvgocc）讨论，或者直接进群交流！天凉了🥶🥶，进群一起取暖也好啊😁，等你~</p>]]></content>
    
    
    <summary type="html">　　“如果把请求变成一个对象，在一些场景更好用！”</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>和 lvgo 一起学设计模式（十八）行为型之迭代器模式</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-iterator.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-iterator.html</id>
    <published>2020-12-02T13:20:32.000Z</published>
    <updated>2020-12-02T13:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/img_convert/ef7aed4c24f3d2f219e4ea4451a2e3c9.png#pic_center" alt="海尔"></p><h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><blockquote><p>提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p></blockquote><p>在看迭代器模式之前，我觉得应该来研究一段代码开开胃先。</p><h2 id="Java-中的-List-集合遍历"><a href="#Java-中的-List-集合遍历" class="headerlink" title="Java 中的 List 集合遍历"></a>Java 中的 List 集合遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Appetizer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;String&gt; strings = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>            strings.add(<span class="hljs-string">&quot;第&quot;</span> + i + <span class="hljs-string">&quot;个元素&quot;</span>);<br>        &#125;<br>        Iterator&lt;String&gt; iterator = strings.iterator();<br>        <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>         iterator.next();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码很简单，我们在日常开发中可能也是经常使用到。有的人可能会说了，啊不对，我用的都是</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strings.size(); i++)<br></code></pre></td></tr></table></figure><p>还有的朋友说了，我直接用增强<code>for</code>循环啊</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(String s : Strings)<br></code></pre></td></tr></table></figure><p>是的，没错。在日常开发中，或多或少的人会用以上两种方式来进行一个列表的遍历。那这两者有什么区别呢？让我们通过编译出来的 <code>class</code>  文件来一探究竟吧。</p><p>这里使用三种不同的写法来遍历一个 list</p><p><strong>java 源码文件</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 使用迭代器遍历</span><br>Iterator&lt;String&gt; iterator = strings.iterator();<br><span class="hljs-keyword">while</span>(iterator.hasNext())<br>iterator.next()<br><br><span class="hljs-comment">// 2. jdk 8 提供的 lambda 写法</span><br>strings.forEach(System.out::println);<br><br><span class="hljs-comment">// 3. 增强 for 循环写法</span><br><span class="hljs-keyword">for</span> (String string : strings) &#123;<br>    System.out.println(string);<br>&#125;<br><br><span class="hljs-comment">// 4. 下标遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strings.size(); i++) &#123;<br>    System.out.println(strings.get(i));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>class 反编译的 java 文件内容</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 使用迭代器遍历</span><br>Iterator&lt;String&gt; iterator = strings.iterator();<br><span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>    iterator.next();<br>&#125;<br><br><span class="hljs-comment">// 2. jdk 8 提供的 lambda 写法</span><br>var10001 = System.out;<br>strings.forEach(var10001::println);<br>Iterator var3 = strings.iterator();<br><br><span class="hljs-comment">// 3. 增强 for 循环写法</span><br><span class="hljs-keyword">while</span>(var3.hasNext()) &#123;<br>    String string = (String)var3.next();<br>    System.out.println(string);<br>&#125;<br><br><span class="hljs-comment">// 4. 下标遍历</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strings.size(); ++i) &#123;<br>    System.out.println((String)strings.get(i));<br>&#125;<br></code></pre></td></tr></table></figure><p>第一种和第三种可以算为同一种，所以就只剩下三种迭代方式</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 增强 for 循环（迭代器）</span><br><span class="hljs-keyword">for</span>(String s : Strings)<br><span class="hljs-comment">// 2. JDK8 的 forEach 方法</span><br>Strings.forEach()<br><span class="hljs-comment">// 3. 下标遍历</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strings.size(); i++)<br></code></pre></td></tr></table></figure><p>接下来我们用数据来看一下这几种方式的表现情况</p><p><strong>第一次</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">测试方法：iterator<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">21</span><br>-----------------------------<br>测试方法：forEach<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">132</span><br>-----------------------------<br>测试方法：增强 <span class="hljs-keyword">for</span> 循环<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">18</span><br>-----------------------------<br>测试方法：下标遍历<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">1</span><br>-----------------------------<br></code></pre></td></tr></table></figure><p><strong>第二次</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">测试方法：iterator<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">17</span><br>-----------------------------<br>测试方法：forEach<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">123</span><br>-----------------------------<br>测试方法：增强 <span class="hljs-keyword">for</span> 循环<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">12</span><br>-----------------------------<br>测试方法：下标遍历<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">3</span><br>-----------------------------<br></code></pre></td></tr></table></figure><p><strong>第三次</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">测试方法：iterator<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">18</span><br>-----------------------------<br>测试方法：forEach<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">119</span><br>-----------------------------<br>测试方法：增强 <span class="hljs-keyword">for</span> 循环<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">14</span><br>-----------------------------<br>测试方法：下标遍历<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">2</span><br>-----------------------------<br></code></pre></td></tr></table></figure><p>为了更直观的展示，我整理了一张统计图</p><p><img src="https://i.loli.net/2020/11/28/VR5IWpXJtTPgKAB.png" alt="10万-1250万数据量4种方式遍历list统计图"></p><p>通过数据也证实了 迭代器 和 增强 for 循环的写法效果相同。</p><h2 id="List-集合到底该如何遍历"><a href="#List-集合到底该如何遍历" class="headerlink" title="List 集合到底该如何遍历"></a>List 集合到底该如何遍历</h2><p>其实乍一看数据，应该用下标遍历这种方式啊，当然，正常是这样的，这是因数组的下标索引决定的它的访问时间复杂度O(1)，同时 JDK 也为 <code>ArrayList</code> 增加了</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RandomAccess</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>标记。标记其为随机访问集合。</p><p><img src="https://i.loli.net/2020/11/28/XqV1x3iUp5YCQjk.png" alt="run-faster-than"></p><p>Java 官方给出的遍历说明：根据经验，下标要比迭代器更快。</p><p>当然，根据我们对数据的测试表现情况来看，当你的数据量低于30w时，这个时间差基本是没有任何影响的，我想，这一切应该得益于当下处理器的计算能力以及内存更高的数据交互速度吧。所以你用以上的 4 种方式都是没有问题的。但是如果你遍历的数据量大于100w时，一定要使用下标遍历了。</p><p>关于 List 集合的遍历，我们就讨论这么多，更主要的是我们要讨论一下上面提到的一个东西，“迭代器”</p><blockquote><p>文末关注回复“源码”获取本文测试使用代码及图表数据</p></blockquote><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>我通过上面的开胃菜知道，迭代器是用来遍历集合的，或者说它是用来遍历的。</p><p>这个时候我们就想了，那刚刚的列表不用这个迭代器速度反而更快，用它还慢还麻烦，为什么要用它呢？</p><p>我们可以想象一下，如果此时的数据结构不是数组，而是链表、是树、是图呢？</p><p>集合本身的目的是存取，目的明确，但如果我们在集合本身增加了遍历操作的话，我们可以看看下图。</p><p><img src="iterator-collection.png" alt="iterator-collection.png"></p><blockquote><p>图片来源：<a href="https://refactoringguru.cn/design-patterns/iterator">https://refactoringguru.cn/design-patterns/iterator</a></p></blockquote><p>假如对于一个链表，我们开始想要以 DFS 方式遍历，写好了一个算法在集合类中，后面发现有需要 BFS 方式遍历这个集合，以目前这种方式，就只能去修改集合类，再加一个方法。如果哪天发现这两个都不合适，又要加一个呢，慢慢的，集合本身的存取目的开始变得不明确，这其实是因为违反了<code>单一职责</code>原则。</p><p>致使遍历访问的问题需要被单独解决。于是迭代器就出现了，它要解决的问题就是用来遍历集合，同时它并不需要去关注具体要遍历的集合是什么样的数据结构。这里我们可以回想一下刚刚测试遍历列表的操作，迭代器在迭代的时候，它知道遍历的具体的数据结构是什么吗？不知道，对于一个迭代器来讲，它只需要关注如何将集合的数据完整无缺的取出来就好了。</p><p>这样，迭代器的概念就捋清了，再看看迭代器模式的定义</p><blockquote><p>提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p></blockquote><p>接下来我们就看看 JDK 中是怎么样用这个迭代器模式来设计集合遍历程序的。go！</p><h2 id="迭代器模式类图-📌"><a href="#迭代器模式类图-📌" class="headerlink" title="迭代器模式类图 📌"></a>迭代器模式类图 📌</h2><p><img src="https://i.loli.net/2020/11/28/4doaxqQrbWgUhvM.png" alt="iterator-JDK-UML"></p><p>下面是根据 JDK 的类直接生成的 UML 类图</p><blockquote><p>注意：并非全部类生成的 UML 类图，这里去掉了一些无关类。</p></blockquote><p><img src="https://i.loli.net/2020/11/28/LSbEmXAoFpGnN8U.png" alt="iterator-idea-UML.png"></p><h2 id="代码-📃"><a href="#代码-📃" class="headerlink" title="代码 📃"></a>代码 📃</h2><p>因为迭代器模式是围绕 JDK 的 iterator 来学习的，所以这里具体的迭代器模式的实现代码就没有自己实现，不过这里学习了 JDK 的代码。我就简单记录一下 JDK 的实现思路。</p><ol><li>定义一个可被迭代的约束类，表示其子类可以被迭代器迭代，这里用的是 <code>Iterable</code>接口。</li><li>定义迭代器接口，其子类为具体的迭代器实现。这里说的是<code>Iterator</code> 接口。</li><li>可被遍历的集合实现<code>Iterable</code> 接口，比如 <code>ArrayList</code>。</li><li>具体迭代器的实现<code>Iterator</code>接口，JDK 使用的 ArrayList 的内部类 Itr 来实现的这个接口。</li><li>迭代器中的提供一个顺序访问的规则，然后通过顺位标识调用集合的“get”方法。</li></ol><p>为了直观表示这个”get”方法，我贴几个迭代器的 next() 实现关键部分代码。</p><p><strong>ArrayList</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-comment">// 这里的 elementData[i] 就是我上面说的 “get” 方法</span><br>    <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>LinkedList</strong>(使用的是 AbstractList 的迭代器)</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 这里的 get 就是我上面说的 “get” 方法</span><br>    E next = get(i);<br>    <span class="hljs-keyword">return</span> next;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>HashSet/HashMap</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 这里的 nextNode() 就是我上面说的 “get” 方法</span><br>    <span class="hljs-keyword">return</span> nextNode().key;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">nextNode</span><span class="hljs-params">()</span> </span>&#123;<br>    Node&lt;K,V&gt;[] t;<br>    Node&lt;K,V&gt; e = next;<br>    <span class="hljs-keyword">if</span> ((next = (current = e).next) == <span class="hljs-keyword">null</span> &amp;&amp; (t = table) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-keyword">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> e;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上内容可以配合 JDK 源码了解，下面列一些涉及类或方法位置</p><ol><li><code>Iterable.java</code></li><li><code>Iterator.java</code></li><li><code>ArrayList.java</code></li><li><code>java/util/ArrayList.java:846</code> （jdk8）</li></ol><h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><ol><li>迭代器模式主要解决的问题就是集合的遍历与集合访问要进行合理的划分职责，这满足了<strong>单一职责</strong>原则。集合类本身专注集合的存取，迭代器专注集合的遍历。</li><li>同时迭代器在实现的过程中不需要关注待遍历集合的数据结构，因为它会使用目标集合的“get”方法来按序读取集合元素。所以这使得了同一个迭代器可以遍历不同的集合，同样的同一个集合也可以用不同的迭代器来进行遍历。</li><li>因为有了迭代器接口和可被迭代的集合接口两个接口的设计方式可以在集合或迭代器的扩展上提供很好的支持，这也满足了<strong>开闭原则。</strong></li><li><strong>这个模式基本不会使用。除非你有自己的数据结构和对他们的遍历规则时。</strong></li></ol>]]></content>
    
    
    <summary type="html">　　你真的“会”遍历list吗？</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>和 lvgo 一起学设计模式（十七）行为型之备忘录模式</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-memento.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-memento.html</id>
    <published>2020-12-01T13:20:32.000Z</published>
    <updated>2020-12-01T13:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="备忘录（Memento）模式"><a href="#备忘录（Memento）模式" class="headerlink" title="备忘录（Memento）模式"></a>备忘录（Memento）模式</h1><blockquote><p>在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</p></blockquote><p>还记得那些年你的游戏存档吗？</p><p><strong>Don’t Starve</strong></p><p><img src="https://i.loli.net/2020/11/28/uWjlqrXoOhPLIxY.jpg" alt="Don&#39;t Starve.jpg"></p><p><strong>unascribed-game1</strong></p><p><img src="https://i.loli.net/2020/11/28/18vxNgFbsJpASw6.jpg" alt="unascribed-game.jpg"></p><p><strong>unascribed-game2</strong></p><p><img src="https://i.loli.net/2020/11/28/Dl5H9G82FkpO4P1.jpg" alt="unascribed-game2.jpg"></p><h2 id="自己实现一个简易版的游戏存档功能"><a href="#自己实现一个简易版的游戏存档功能" class="headerlink" title="自己实现一个简易版的游戏存档功能"></a>自己实现一个简易版的游戏存档功能</h2><p>今天写一个游戏存档功能练习一下编码基本功。</p><p><strong>需求分析</strong></p><ol><li>需要有个管理存档的角色，那么多个存档总要有人来管啊，想存档或者读档需要它说了算。</li><li>还需要有个具体的存档对象，方便我们管理呀。</li></ol><p><strong>需求设计</strong></p><ol><li>存档对象的管理角色 Caretaker 管理存档对象</li><li>存档对象 Memento 具体的存档对象</li><li>存档的创建者 Originator 管理“存档”这件事，创建恢复存档。</li></ol><h2 id="代码-📃"><a href="#代码-📃" class="headerlink" title="代码 📃"></a>代码 📃</h2><blockquote><p>完整源码关注回复“源码获取”</p></blockquote><p><img src="https://i.loli.net/2020/11/28/ODChyStnGzM47Lo.png" alt="memento-source"></p><p>测试结果</p><p><img src="https://i.loli.net/2020/11/28/57jB1tPbwWDsdJR.png" alt="memento-test"></p><p><strong>展示存档列表</strong></p><p><img src="https://i.loli.net/2020/11/28/9SrAQZD465qW1zl.png" alt="memento-list-test"></p><h2 id="备忘录模式类图-📌"><a href="#备忘录模式类图-📌" class="headerlink" title="备忘录模式类图 📌"></a>备忘录模式类图 📌</h2><p><img src="https://i.loli.net/2020/11/28/hHtJlIPN9OTw4KL.png" alt="memento-UML1"></p><p>上面的代码是以这种类图方式实现的，不过这在 Java 中显然有可以优化的地方。即将 Caretaker 角色优化掉。优化后的类图</p><p><img src="https://i.loli.net/2020/11/28/GNXw8MnRPskxbSh.png" alt="memento-UML2"></p><blockquote><p>两个写法的完整源码关注回复“源码获取”，优化版代码在 optimization 目录中</p></blockquote><h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>由于备忘录模式使用这种代码构建的方式在 Java 中并不多，这要得益于 Java 的 <code>Serializable</code> 接口，可以使用序列化来完成备份的操作。所以只是简单的使用一个游戏存档案例记录一下这个知识点，配合学习理解的最好的再就应该是文档编辑功能中的 <code>ctrl+z</code>了。</p><p>备忘录模式可以使我们对一个对象的状态进行保存，在需要的时候快速恢复。不得不说的就是备忘录模式如果保存的大量的对象时，内存的占用还是需要关注一下的。在备忘录模式中保存对象的时候，可以配合原型模式来一起使用。</p><p>最后，这个模式在 Java 中应该不太香，原因上面也说了。所以<strong>我对这个设计模式仅作为了解</strong>，真正要使用它的话我还是会尽可能的考虑使用 <code>Serializable</code>。</p><p><strong>优点：</strong>无侵入备份/恢复对象状态（<strong>在 Java 里不是很香</strong>）。</p><p><strong>缺点：</strong>GOF 中的写法在 Java 中<strong>不香</strong>，同时使用这种模式需考虑内存占用问题。</p>]]></content>
    
    
    <summary type="html">　　这款游戏你玩过吗？是不是经常”重来“？</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>和 lvgo 一起学设计模式（十六）行为型责任链模式之模式</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-chain-of-responsibility.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-chain-of-responsibility.html</id>
    <published>2020-11-28T13:20:32.000Z</published>
    <updated>2020-11-28T13:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/11/28/25fjXDYo4VriF9l.png" alt="chain-of-responsibility.png"></p><blockquote><p>图片来源：<a href="https://refactoringguru.cn/design-patterns/chain-of-responsibility">https://refactoringguru.cn/design-patterns/chain-of-responsibility</a></p></blockquote><h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><blockquote><p>把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</p></blockquote><p>通过上面的图其实也能看个差不多了，在这幅图中水桶就是整个链路中被传递的对象。它可以在链路上的任意一个节点被消费，如果你觉得剩的水可以继续给下一个节点用，你甚至可以将它继续传递下去。这样设计的好处就行定义中说的那样，去除对象将的耦合。</p><p>假设这个业务场景需要请求的对象是存在联系的，比如具有一定顺序去消费同一个对象，又比如他们消费对象的方法相同，具体逻辑略有差异。此时如果这个水桶对象的传递不通过责任链这种模式，看看会有什么问题。</p><p><img src="https://i.loli.net/2020/11/28/UuO5PtAK6Xwvx1q.png" alt="chain-of-responsibility-none"></p><p>王二需要分为4个时刻与4个不同的对象进行交互，这无疑增加了系统的复杂性。并且这里其中任意一个请求目标发生变化，王二都必须要跟着调整。再比如下面这个生活中的例子。</p><p>王二因为一些原因不能上班，需要和领导请假，卑微的王二在单位的职位级别比较低，需要多级领导审批，甚至同事都是一个坎，让我们看看没有责任链模式介入时王二的请假过程。</p><p><img src="https://i.loli.net/2020/11/28/f2Vca1v5tFpGPhn.png" alt="chain-of-responsibility-wanger"></p><p><strong>王二卒。</strong></p><p>王二这件事被同事张三知道后，张三决定为了纪念王二的悲催经历。他决定向领导提出一个流程调整方案，具体的意见如下；</p><ol><li>请假时每个人的动作相同，均为审批。至于审批是同意或拒绝由审批者自己决定。</li><li>对请假流程中涉及的人员使用链式传递。不得跨越（即每个人必须都需要经过处理后才能继续传递）。</li></ol><h2 id="责任链模式类图-📌"><a href="#责任链模式类图-📌" class="headerlink" title="责任链模式类图 📌"></a>责任链模式类图 📌</h2><p><img src="https://i.loli.net/2020/11/28/VwsODFXe7ISup6c.png" alt="chain-of-responsibility-UML.png"></p><h2 id="张三请假-📃"><a href="#张三请假-📃" class="headerlink" title="张三请假 📃"></a>张三请假 📃</h2><p>张三使用责任链模式请假流程示意图</p><p><img src="https://i.loli.net/2020/11/28/QKCPk5Ixmpir7to.png" alt="chain-of-responsibility-zhangsan"></p><p>抽象处理类，各个环节处理时统一标准。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractHandler</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> AbstractHandler next;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractHandler <span class="hljs-title">getNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(AbstractHandler next)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(String request)</span> </span>&#123;<br>        conCreteHandle(request);<br>        <span class="hljs-keyword">if</span> (getNext() == <span class="hljs-keyword">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;流程结束&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            getNext().handle(request);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">conCreteHandle</span><span class="hljs-params">(String request)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QingJia</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractHandler</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">conCreteHandle</span><span class="hljs-params">(String request)</span> </span>&#123;<br>        System.out.println(request);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractHandlerTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>&#123;<br>        AbstractHandler qingJia = <span class="hljs-keyword">new</span> QingJia();<br>        AbstractHandler renShi = <span class="hljs-keyword">new</span> RenShi();<br>        AbstractHandler shangjiLingdao = <span class="hljs-keyword">new</span> ShangjiLingdao();<br>        AbstractHandler tongShi = <span class="hljs-keyword">new</span> TongShi();<br>        AbstractHandler zuZhang = <span class="hljs-keyword">new</span> ZuZhang();<br><br>        qingJia.setNext(tongShi);<br>        tongShi.setNext(zuZhang);<br>        zuZhang.setNext(shangjiLingdao);<br>        shangjiLingdao.setNext(renShi);<br><br>        qingJia.handle(<span class="hljs-string">&quot;张三请假&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试张三请假</p><figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">张三请假<br>同事审批：同意<br>组长审批：同意<br>上级领导审批：同意<br>人事审批：同意<br>流程结束<br></code></pre></td></tr></table></figure><blockquote><p>完整代码文末关注，回复 “源码” 获取。</p></blockquote><h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>使用责任链模式可以使原本的对象间耦合度降低。各个模块间功能更加具体专注。同时链上的处理也可以更加灵活，可以通过处理请求的时候进行判断来过滤自己关注的内容来处理，或者在生成链的时候将无关节点去掉。</p><p>同时可以配合创建型模式中的工厂模式，来封装链的维护，这样在链上节点发生变化时（算法实现发生改变、新增或删除）对于高层模块是没有感知的。扩展起来非常的方便。或使用建造者模式来更加灵活地创建这条“责任链”，以达到客户端的自定义目的。总之，责任链模式在处理链式问题是个利器。</p>]]></content>
    
    
    <summary type="html">　　“张三为了纪念王二请假的悲催经历想出来的一种设计模式”</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>和 lvgo 一起学设计模式（十五）行为型之观察者模式</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-observer.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-observer.html</id>
    <published>2020-11-24T14:38:41.000Z</published>
    <updated>2020-11-24T14:38:41.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/11/24/NYiKTrU5G2BnkEs.png" alt="observer-title.png"></p><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><blockquote><p>多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</p></blockquote><p>提到观察者，就一定有“被观察者”。</p><p>被观察者发生改变时，通知给每个观察者，这就是观察者模式。放到生活中的例子就是</p><ul><li>天气预报的短信通知，在很早以前，我们的天气预报服务可以通过短信的信息订阅。在这个业务场景中，天气预报就是被观察者，每个付费的用户就是观察者，当有最新的天气预报的消息时，会以短信的形式通知给曾经付过费订阅的用户。如果不订阅是不会收到的。</li><li>你现在在使用的通讯软件中的’群聊’功能，这个相对较为复杂一点，可以抽象的理解一下，用一个人去理解，群里的每个人都是被观察者，每个人都是观察者。当一个人发出消息的时候，所有在群里的人都会收到消息也包括自己。反之，不在群里的人则收不到。</li><li>还记得小区单元门口一个一个小盒子吗？有的小盒子里是有当天的报纸的。甚至里面的报纸内容可能是不相同的，这里就涉及到了多个被观察者和观察之间的关系，这个小盒子能收到自己订阅的报社报纸，当然你可以同时订阅多个，这样你就可以收到多个报社送过来的报纸了。</li></ul><p>对于上面的例子，天气预报需要用户自己付费订阅、群聊需要先进群、在家看报需要联系报社订阅报纸。这里就能看出来。这种关系是一个一对多的关系。被观察者是同一个，而观察者却可以是很多个不同的对象。还有就是观察者需要自己主动的去找被观察者“提前”说明好，“一旦有消息，请通知我一声”。所有这里可以抽象出来几个角色和动作。</p><ol><li>被观察者（1个）</li><li>观察者（n个）</li><li>被观察者负责管理观察者对象</li><li>观察者自己负责被观察者给予的通知内容</li></ol><h2 id="观察者模式类图-📌"><a href="#观察者模式类图-📌" class="headerlink" title="观察者模式类图 📌"></a>观察者模式类图 📌</h2><p><img src="https://i.loli.net/2020/11/24/ybnYo1RH5wNC9Gk.png" alt="observer-UML.png"></p><ol><li>被观察者（Observable）</li><li>观察者（Observer）</li><li>被观察者负责管理观察者对象(Observable.obs)</li><li>观察者自己负责被观察者给予的通知内容(Observer.update)</li></ol><p>如果对 JDK 熟悉的同学可能早已看穿，这个类图画的其实就是 JDK 提供的观察者框架，我们可以用它轻松的实现一个订阅通知功能。而这一功能在 JDK 1.0 的版本就已经存在了。</p><h2 id="代码-📃"><a href="#代码-📃" class="headerlink" title="代码 📃"></a>代码 📃</h2><p>JDK 源码，篇幅原因只保留了核心代码</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util;<br><span class="hljs-comment">// 观察者</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Observable var1, Object var2)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>JDK 源码，篇幅原因只保留了核心代码</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util;<br><span class="hljs-comment">// 被观察者</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observable</span> </span>&#123;<br><span class="hljs-comment">// 管理观察者对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Vector&lt;Observer&gt; obs = <span class="hljs-keyword">new</span> Vector();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(Observer var1)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.obs.contains(var1)) &#123;<br>            <span class="hljs-keyword">this</span>.obs.addElement(var1);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 通知给订阅的观察者</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">(Object var1)</span> </span>&#123;<br>        Object[] var2 = <span class="hljs-keyword">this</span>.obs.toArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var3 = var2.length - <span class="hljs-number">1</span>; var3 &gt;= <span class="hljs-number">0</span>; --var3) &#123;<br>            ((Observer)var2[var3]).update(<span class="hljs-keyword">this</span>, var1);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自己实现部分</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Observable</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setChanged</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.setChanged();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Observable o, Object arg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是 consumer1 我收到了&quot;</span> + o + <span class="hljs-string">&quot;的通知，通知内容：&quot;</span> + arg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Observable o, Object arg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是 consumer2 我收到了&quot;</span> + o + <span class="hljs-string">&quot;的通知，通知内容：&quot;</span> + arg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Observable o, Object arg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是 consumer3 我收到了&quot;</span> + o + <span class="hljs-string">&quot;的通知，通知内容：&quot;</span> + arg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试，定义了 2 个被观察者（生产者），3 个观察者（消费者）来分别使用12生产者来发布消息。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">jdkOb</span><span class="hljs-params">()</span> </span>&#123;<br>    Producer producer1 = <span class="hljs-keyword">new</span> Producer();<br>    producer1.setChanged();<br>    Producer producer2 = <span class="hljs-keyword">new</span> Producer();<br>    producer2.setChanged();<br>    Consumer1 consumer1 = <span class="hljs-keyword">new</span> Consumer1();<br>    Consumer2 consumer2 = <span class="hljs-keyword">new</span> Consumer2();<br>    Consumer3 consumer3 = <span class="hljs-keyword">new</span> Consumer3();<br><br>    producer1.addObserver(consumer1);<br>    producer1.addObserver(consumer2);<br>    producer1.addObserver(consumer3);<br>    producer2.addObserver(consumer1);<br>    producer2.addObserver(consumer2);<br>    producer2.addObserver(consumer3);<br><br>    producer1.notifyObservers(<span class="hljs-string">&quot;我是生产者1，我现在给你们通知一条消息，收到赶紧去消费掉&quot;</span>);<br>    producer2.notifyObservers(<span class="hljs-string">&quot;我是生产者2，我现在给你们通知一条消息，收到赶紧去消费掉&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">我是 consumer3 我收到了Producer@57cd70的通知，通知内容：我是生产者1，我现在给你们通知一条消息，收到赶紧去消费掉<br>我是 consumer2 我收到了Producer@57cd70的通知，通知内容：我是生产者1，我现在给你们通知一条消息，收到赶紧去消费掉<br>我是 consumer1 我收到了Producer@57cd70的通知，通知内容：我是生产者1，我现在给你们通知一条消息，收到赶紧去消费掉<br><br>我是 consumer3 我收到了Producer@1a7504c的通知，通知内容：我是生产者2，我现在给你们通知一条消息，收到赶紧去消费掉<br>我是 consumer2 我收到了Producer@1a7504c的通知，通知内容：我是生产者2，我现在给你们通知一条消息，收到赶紧去消费掉<br>我是 consumer1 我收到了Producer@1a7504c的通知，通知内容：我是生产者2，我现在给你们通知一条消息，收到赶紧去消费掉<br></code></pre></td></tr></table></figure><h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>使用观察者模式需要注意的几个点</p><ol><li>观察者数量，如果一个被观察者被很多观察者观察（订阅）时，在通知时的时间将会变得漫长；</li><li>不能出现被观察者和观察者之间存在循环观察情况，否则系统会直接崩溃；</li></ol><p>观察者模式的代码虽然很简单，但是它所创造的价值却远不止这些。相信你同我一样，通过观察者模式联想到了消息通知、binlog订阅、注册中心等技术组件。其核心内容也只是在此简单的不能再简单的思想上去做更多更复杂的功能迭代。</p><p>万变不离其宗。在复杂的系统，在复杂的功能，都能找到其根本所在。知识，亦是如此。</p><p>当然，你也可以尝试在现有的代码中进行一些修改，比如通知的情况改为有新的观察者加入时？通知的数据变得更丰富一些？异步通知？等等等等。</p><p>如果你有更好的点子可以关注并分享给我们（欢迎加群）！</p>]]></content>
    
    
    <summary type="html">　　“原来观察者模式是JDK与生俱来的”</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>和 lvgo 一起学设计模式（十四）行为型之模板方法模式</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-template-method.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-template-method.html</id>
    <published>2020-11-24T14:38:03.000Z</published>
    <updated>2020-11-24T14:38:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/11/24/65JlOrxysH82ivQ.png" alt="template-method-title.png"></p><h1 id="冲啊！"><a href="#冲啊！" class="headerlink" title="冲啊！"></a>冲啊！</h1><p>最近经常看《四驱兄弟》，脑子已经被“冲啊”洗掉了。</p><p>“冲啊，就让我们一路领先到底吧！”，“冲啊，看我的胜利冲锋！”，“冲啊！先驱音速！”，“去吧！三角箭！”，“冲啊！疾速斧头！”，“冲啊！二郎丸特别号！”，“冲啊！”</p><p>终于来到了设计模式的“人性”部分，行为型模式，为什么说行为型模式是“人性”部分呢，因为行为型模式当中的 11 种设计模式对理解都非常的友好啊。所以接下来的内容可能让我学起来说不定更有趣些。</p><h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><blockquote><p>定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p></blockquote><h2 id="如何理解"><a href="#如何理解" class="headerlink" title="如何理解"></a>如何理解</h2><p>定义一个操作中的算法骨架，说白了这不就是一个步骤约束吗？在看第二段，将算法的一些步骤延迟到子类中，意思就是步骤里的一部分留给你了，具体怎么做看你（子类）自己了。使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤，这句就更好理解了，有了步骤的约束，你负责执行具体的步骤，说白了，步骤只要执行就可以，不管你怎么做，所以也就有了不改变结构的情况下可以重新定义特定的步骤，这里的特定指的就是约束步骤里留给你的那部分步骤。</p><ul><li><p>比如我们经常写 PPT 的小伙伴知道，在 PPT 中，点击新增一页 PPT ，创建出来的页面，大部分的布局格式都是已经设置好的，我们只需要去填充里面的内容就可以了。</p></li><li><p>再比如经常写需求说明书的时候，会和同事要一份“模板”，这也是一种模板方法模式的体现。</p></li><li><p>还有如果你使用过 maven 创建过项目，那这个你一定不陌生</p></li></ul><p><img src="https://i.loli.net/2020/11/24/1mWL2Nnue5A3yrF.png" alt="template-method-maven.png"></p><h2 id="重新定义"><a href="#重新定义" class="headerlink" title="重新定义"></a>重新定义</h2><p>模板方法模式就是：提供一个具体的步骤，1,2,3,4，现在1,2,4都写好了，步骤3的实现由具体的执行者说了算，只要步骤符合要求，随你发挥。</p><h2 id="模板方法模式类图-📌"><a href="#模板方法模式类图-📌" class="headerlink" title="模板方法模式类图 📌"></a>模板方法模式类图 📌</h2><p><img src="https://i.loli.net/2020/11/24/RsQzpH46XNZTWcd.png" alt="template-method"></p><p>看类图就是抽象和子类的样子，而实际模板方法模式就是利用了”抽象”。是一个完全遵守开闭原则的设计模式。可以这么说，搞懂了模板方法模式，开闭原则基本就通了。</p><p><strong>注意：模板方法模式中与我们平时继承抽象类有一个关键性的区别，就是入口方法，正常抽象类继承是不需要有这个所谓的入口方法，可以通过入口方法来确定算法的执行顺序，即算法骨架。</strong></p><h2 id="我怎么用模板方法模式📃"><a href="#我怎么用模板方法模式📃" class="headerlink" title="我怎么用模板方法模式📃"></a>我怎么用模板方法模式📃</h2><p>模板方法模式可以说是非常简单的一种设计模式了，虽然简单，但它的作用却很大。比如我们经常使用的lock 锁，它的实现就利用了 AQS ，而 AQS 就是使用 <strong>模板方法模式</strong> 维护的一个锁框架，通过它可以快速的开发出一个锁。这步可以结合 AQS 的代码来看一看。</p><p>第一步：通过 Lock 接口来约束一个锁所需要的几个关键方法（其实这也可以说是一种模板，只是约束力很小）</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MutexLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync = <span class="hljs-keyword">new</span> Sync();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.release(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sync.newCondition();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>核心代码</strong></p><p>第二步：具体的锁实现，这个类的约束力比较强，因为我们想偷懒，借助 AQS 来实现一个锁，所以就要按照它所提供的模板要求来完成对应步骤的代码逻辑，也就是上面提到的（使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。）这些需要我们去写的步骤就是 AQS 留给我们的 “特殊步骤”</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, arg)) &#123;<br>                setExclusiveOwnerThread(Thread.currentThread());<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">1</span>, arg)) &#123;<br>                setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function">Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConditionObject();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>关于 AQS 留给我们的 “特殊步骤”可以在源码中看到</p><p>我们自己定一个锁，然后调用 acquire 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MutexLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync = <span class="hljs-keyword">new</span> Sync();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>之后 AQS 按照它的模板继续执行，在需要的时候（特殊步骤）会调用我们自己提供的方法，锁具体的实现要自行实现，模板类 AQS 不提供具体实现。</p><p><img src="https://i.loli.net/2020/11/24/ruJo4M3l1SF9ILO.png" alt="template-method-AQS1.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">      <span class="hljs-comment">// 重写 AQS 的特殊步骤，如果不写会抛出上述异常</span><br><span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>          <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, arg)) &#123;<br>              setExclusiveOwnerThread(Thread.currentThread());<br>              <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>          &#125;<br>      &#125;<br></code></pre></td></tr></table></figure><p>通过一个图来理解这个过程</p><p><img src="https://i.loli.net/2020/11/24/Vl3LZn1STyj8MbU.png" alt="template-method-AQS2.png"></p><p>其中“<strong>特殊步骤</strong>”就是 AQS 模板留给我们要实现的地方。</p><p>最后，测试一下我们自己写的锁</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MutexLockTest</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> f = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Lock lock = <span class="hljs-keyword">new</span> MutexLock();<br>        <span class="hljs-keyword">int</span> threadCount = Runtime.getRuntime().availableProcessors();<br>        CountDownLatch signal = <span class="hljs-keyword">new</span> CountDownLatch(threadCount);<br>        <span class="hljs-keyword">int</span> loop = <span class="hljs-number">100000</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadCount; i++) &#123;<br>            Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (l &lt; loop) &#123;<br>                    lock.lock();<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        f++;<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        lock.unlock();<br>                    &#125;<br>                    l++;<br>                &#125;<br>                signal.countDown();<br>            &#125;);<br>            thread.start();<br>        &#125;<br>        signal.await();<br>        Assertions.assertEquals(threadCount * loop, f);<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://i.loli.net/2020/11/24/bXn3FYOSryAseka.png" alt="template-method-test.png"></p><p>这里建议大家配合源码学习，同时也能学习一些与锁实现上的一些相关知识，如果有不清楚或觉得有疑问的地方，欢迎加我微信一起讨论（lvgocc）</p><h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>通过模版模式可以将一些我们想要约束的执行步骤固定下来，同时对于步骤中重复的内容可以进行抽象，这样就可以简化很多子类的操作，也避免了一些不必要的冗余代码产生。</p><p>使用模板方法模式可以非常简单的来约束一段逻辑的执行要求。在做程序扩展限制时，非常有用。定义好具体的逻辑流程抽象类，将公共部分代码写在抽象类中，然后将其中需要使用者自行实现的方法定义为抽象方法，这样当他继承这个类的时候，只需要将对应的抽象方法实现就好了，不需要关系其具体的执行顺序。</p><p>但同样的，这样会使<strong>执行顺序对使用者完全透明</strong>，如果抽象的方法较为复杂时，对于一个初次使用该逻辑的人来说，出现 bug 可能会使他很“难受”，因为他需要搞清楚整个抽象类中每个方法的执行顺序才能更好的去解决问题。这一点，<strong>增加了系统的复杂性</strong>。不过，设计模式的复杂性，是不可避免的。<strong>在功能复用、提高生产力上来说，这点复杂性的代价，还是能够接受的。</strong></p>]]></content>
    
    
    <summary type="html">　　“你知道AQS它是干什么的吧，那这个框架是怎么设计的呢？”</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>和 lvgo 一起学设计模式（十三）行为型之策略模式</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-strategy.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-strategy.html</id>
    <published>2020-11-22T15:20:57.000Z</published>
    <updated>2020-11-22T15:20:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/11/22/EbcfqsQpOhvYCad.png" alt="strategy-title.png"></p><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略模式最早的时候是在马老师的坦克大战看的，讲的很干，也挺清楚。现在回想起来更是记忆犹新。</p><p>说到策略模式，最应该关注的应该就是策略这个词语了吧。这个词我直接贴一段百度的翻译，大家看一下</p><p><img src="https://i.loli.net/2020/11/21/nYyQ4dELalKpr25.png" alt="image-20201121172440172"></p><p>提取和设计模式相关的两个含义</p><ol><li>可以实现目标的方案集合</li><li>根据不同情况选择不同的策略</li></ol><p>然后我们再看看标准的策略模式定义</p><blockquote><p>定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</p></blockquote><p>有了这个基本的清晰概念再学起来就很轻松了。</p><h2 id="策略模式类图-📌"><a href="#策略模式类图-📌" class="headerlink" title="策略模式类图 📌"></a>策略模式类图 📌</h2><p><img src="https://i.loli.net/2020/11/21/xRjFyEgXSmHnidp.png" alt="strategy-uml.png"></p><p>定义了一个策略接口，然后将每种不同的策略实现同一个接口。这样各个策略之间就可以进行切换。在使用的过程中，可以将策略当成参数传到具体的方法中执行（这里要用函数接口），或者在客户端调用之前就将指定好具体的策略。</p><h2 id="站点的主题切换-🎨"><a href="#站点的主题切换-🎨" class="headerlink" title="站点的主题切换 🎨"></a>站点的主题切换 🎨</h2><p>相信大家都使用过可以切换主题的站点，这次我也是尝试使用策略模式来实现这个功能。</p><p><strong>需求：</strong></p><ol><li>用户可以根据自己的喜欢自行选择预设的 3 个主题配色</li></ol><p><strong>3 个主题配色：</strong></p><ol><li><strong>七彩斑斓的黑</strong><ul><li>背景色：backgroundColor 黑色</li><li>字体颜色：fontColor 灰色</li></ul></li><li><strong>五颜六色的黑</strong><ul><li>背景色：backgroundColor 黑灰色</li><li>字体颜色：fontColor 白色</li></ul></li><li><strong>绚烂多彩的黑</strong><ul><li>背景色：backgroundColor 灰黑色</li><li>字体颜色：fontColor 黑色</li></ul></li></ol><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Theme 主题接口</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 欢迎跟我一起学习，微信（lvgocc）公众号：星尘的一个朋友</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@blog</span> <span class="hljs-doctag">@see</span> http://lvgo.org</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CSDN</span> <span class="hljs-doctag">@see</span> https://blog.csdn.net/sinat_34344123</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/11/21</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Theme</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Context</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 欢迎跟我一起学习，微信（lvgocc）公众号：星尘的一个朋友</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@blog</span> <span class="hljs-doctag">@see</span> http://lvgo.org</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CSDN</span> <span class="hljs-doctag">@see</span> https://blog.csdn.net/sinat_34344123</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/11/21</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Theme theme;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Theme <span class="hljs-title">getTheme</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> theme;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTheme</span><span class="hljs-params">(Theme theme)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.theme = theme;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        theme.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ThemeTest</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 欢迎跟我一起学习，微信（lvgocc）公众号：星尘的一个朋友</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@blog</span> <span class="hljs-doctag">@see</span> http://lvgo.org</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CSDN</span> <span class="hljs-doctag">@see</span> https://blog.csdn.net/sinat_34344123</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/11/21</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThemeTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        Context context = <span class="hljs-keyword">new</span> Context();<br>        System.out.println(<span class="hljs-string">&quot;七彩斑斓的黑&quot;</span>);<br>        context.setTheme(<span class="hljs-keyword">new</span> ColorfulBlack());<br>        context.show();<br><br>        System.out.println(<span class="hljs-string">&quot;五颜六色的黑&quot;</span>);<br>        context.setTheme(<span class="hljs-keyword">new</span> MotleyBlack());<br>        context.show();<br><br>        System.out.println(<span class="hljs-string">&quot;绚烂多彩的黑&quot;</span>);<br>        context.setTheme(<span class="hljs-keyword">new</span> SplendidBlack());<br>        context.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br>七彩斑斓的黑<br>- 背景色：backgroundColor 黑色<br>- 字体颜色：fontColor 灰色<br><br>五颜六色的黑<br>- 背景色：backgroundColor 黑灰色<br>- 字体颜色：fontColor 白色<br><br>绚烂多彩的黑<br>- 背景色：backgroundColor 灰黑色<br>- 字体颜色：fontColor 黑色<br><br></code></pre></td></tr></table></figure><p>其实要说这个策略模式的实现，它本身就是这么一个非常简单的写法。只是可以通过更多的思想融入可以使其变得更加灵活好用，同时也会变得复杂起来。这里一起看看一个经典的策略模式的实现，就是 JDK 中的比较器。在 JDK 中就是不同的类型有不同的比较算法，这也是符合了策略模式的思想。我再把策略模式的定义拿过来看一看</p><blockquote><p>定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</p></blockquote><p>JDK 为每种不同的数据类型定义了一系列的算法，并将每个算法封装起来，使他们可以通过 Comparator 接口进行相互替换，对于客户端来讲，尽管调用比较方法就可以了，即使算法发生了改变（替换其他算法）也不会影响到客户端的使用。</p><h2 id="JDK-比较器"><a href="#JDK-比较器" class="headerlink" title="JDK 比较器"></a>JDK 比较器</h2><p>JDK 中的比较实现有两种，一种是直接通过实现 Compareable 接口，定义其他对象与自己的顺序（比较）。而另一种就是通过使用策略模式来实现的比较器 Comparator 接口。接下来就一起看看 JDK 是怎么运用策略模式设计的比较器。</p><p>首先是策略模式中的第一个关键的定义，定义一系列算法。根据开闭原则，这里定义了一个接口，然后将具体的一系列算法实现延迟到子类当中去。</p><p>比较器 - 策略接口</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">T</span>&gt;</span><br></code></pre></td></tr></table></figure><p>一系列算法 - 具体策略</p><p>String 的比较算法</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER<br>                                     = <span class="hljs-keyword">new</span> CaseInsensitiveComparator();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CaseInsensitiveComparator</span></span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-comment">// use serialVersionUID from JDK 1.2.2 for interoperability</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">8575799808933029326L</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n1 = s1.length();<br>        <span class="hljs-keyword">int</span> n2 = s2.length();<br>        <span class="hljs-keyword">int</span> min = Math.min(n1, n2);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; min; i++) &#123;<br>            <span class="hljs-keyword">char</span> c1 = s1.charAt(i);<br>            <span class="hljs-keyword">char</span> c2 = s2.charAt(i);<br>            <span class="hljs-keyword">if</span> (c1 != c2) &#123;<br>                c1 = Character.toUpperCase(c1);<br>                c2 = Character.toUpperCase(c2);<br>                <span class="hljs-keyword">if</span> (c1 != c2) &#123;<br>                    c1 = Character.toLowerCase(c1);<br>                    c2 = Character.toLowerCase(c2);<br>                    <span class="hljs-keyword">if</span> (c1 != c2) &#123;<br>                        <span class="hljs-comment">// No overflow because of numeric promotion</span><br>                        <span class="hljs-keyword">return</span> c1 - c2;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n1 - n2;<br>    &#125;<br><br>    <span class="hljs-comment">/** Replaces the de-serialized object. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> CASE_INSENSITIVE_ORDER; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果对象本身支持比较，即实现了 Comparable 接口的对象，可以使用 Comparator 提供的下面这个方法</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T extends Comparable&lt;? <span class="hljs-keyword">super</span> T&gt;&gt; <span class="hljs-function">Comparator&lt;T&gt; <span class="hljs-title">naturalOrder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (Comparator&lt;T&gt;) Comparators.NaturalOrderComparator.INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 Comparators 这个类是专门为 Comparator 接口创建比较算法使用的默认类，是一个同包访问权限的类</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Package private supporting class for &#123;<span class="hljs-doctag">@link</span> Comparator&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comparators</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Comparators</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(<span class="hljs-string">&quot;no instances&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Compares &#123;<span class="hljs-doctag">@link</span> Comparable&#125; objects in natural order.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> Comparable</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NaturalOrderComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Object</span>&gt;&gt; </span>&#123;<br>        INSTANCE;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Comparable&lt;Object&gt; c1, Comparable&lt;Object&gt; c2)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> c1.compareTo(c2);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Comparator&lt;Comparable&lt;Object&gt;&gt; reversed() &#123;<br>            <span class="hljs-keyword">return</span> Comparator.reverseOrder();<br>        &#125;<br>    &#125;<br>    ....<br>    省略部分代码<br>    ....<br>&#125;<br></code></pre></td></tr></table></figure><p>其实对于比较这种算法，更多的是由使用者自己来决定谁大谁小，JDK 仅提供了一些基本的比较策略。比如如下几种比较策略</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">  <span class="hljs-comment">// 常规比较</span><br>  <span class="hljs-keyword">static</span> &lt;T extends Comparable&lt;? <span class="hljs-keyword">super</span> T&gt;&gt; <span class="hljs-function">Comparator&lt;T&gt; <span class="hljs-title">naturalOrder</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> NaturalOrderComparator.INSTANCE;<br>   &#125;<br><span class="hljs-comment">// 空值小于非空</span><br>   <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Comparator&lt;T&gt; <span class="hljs-title">nullsFirst</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; var0)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NullComparator(<span class="hljs-keyword">true</span>, var0);<br>   &#125;<br><span class="hljs-comment">// 空值大于非空</span><br>   <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Comparator&lt;T&gt; <span class="hljs-title">nullsLast</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; var0)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NullComparator(<span class="hljs-keyword">false</span>, var0);<br>   &#125;<br><span class="hljs-comment">// 等等，如果还想了解可以自行查看 java/util/Comparator.java</span><br></code></pre></td></tr></table></figure><p><strong>注意：两个空值比较只是提供了当两个元素为空时的比较策略，当两个比较元素都不为空时需使用调用者提供的比较算法</strong></p><p>下面我们一起看下如何使用 JDK 的比较器来达到策略模式定义的第二点<code>它们可以相互替换，且算法的改变不会影响使用算法的客户。</code></p><h3 id="‘你’-大还是-‘好’-大"><a href="#‘你’-大还是-‘好’-大" class="headerlink" title="‘你’ 大还是 ‘好’ 大"></a>‘你’ 大还是 ‘好’ 大</h3><p>我们就拿 ‘<strong>你</strong>‘ 和 ’<strong>好</strong>’ 这两个汉字来尝试一下。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestJDKComparator</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String you = <span class="hljs-string">&quot;你&quot;</span>;<br>        String fine = <span class="hljs-string">&quot;好&quot;</span>;<br>        <span class="hljs-comment">// String 的比较器</span><br>        <span class="hljs-keyword">int</span> ctic = you.compareToIgnoreCase(fine);<br>        System.out.println(<span class="hljs-string">&quot;compareToIgnoreCase:&quot;</span> + ctic);<br><br>        <span class="hljs-comment">// JDK 提供的默认比较器</span><br>        Comparator&lt;String&gt; comparator = Comparator.naturalOrder();<br>        <span class="hljs-keyword">int</span> compare = comparator.compare(you, fine);<br>        System.out.println(<span class="hljs-string">&quot;naturalOrder = &quot;</span> + compare);<br><br>        <span class="hljs-comment">// 自定义比较器1</span><br>        Comparator&lt;String&gt; stringComparator1 = Comparator.nullsFirst((o1, o2) -&gt; &#123;<br>            <span class="hljs-keyword">byte</span>[] bytes1 = o1.getBytes();<br>            <span class="hljs-keyword">byte</span>[] bytes2 = o2.getBytes();<br>            <span class="hljs-keyword">return</span> bytes1.length - bytes2.length;<br><br>        &#125;);<br>        <span class="hljs-keyword">int</span> compare1 = stringComparator1.compare(you, fine);<br>        System.out.println(<span class="hljs-string">&quot;nullsFirst&amp;customComparator1 = &quot;</span> + compare1);<br><br>        <span class="hljs-comment">// 自定义比较器2</span><br>        Comparator&lt;String&gt; stringComparator2 = Comparator.nullsFirst((o1, o2) -&gt; &#123;<br>            <span class="hljs-keyword">int</span> length1 = o1.length();<br>            <span class="hljs-keyword">int</span> length2 = o2.length();<br>            <span class="hljs-keyword">int</span> min = Math.min(length1, length2);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; min; i++) &#123;<br>                <span class="hljs-keyword">char</span> o1Char = o1.charAt(i);<br>                <span class="hljs-keyword">char</span> o2Char = o2.charAt(i);<br>                <span class="hljs-keyword">if</span> (o1Char != o2Char) &#123;<br>                    <span class="hljs-keyword">return</span> o2Char - o1Char;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> length2 - length1;<br>        &#125;);<br>        <span class="hljs-keyword">int</span> compare2 = stringComparator2.compare(you, fine);<br>        System.out.println(<span class="hljs-string">&quot;nullsFirst&amp;customComparator2 = &quot;</span> + compare2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">compareToIgnoreCase:-<span class="hljs-number">2589</span><br>naturalOrder = -<span class="hljs-number">2589</span><br>nullsFirst&amp;customComparator1 = <span class="hljs-number">0</span><br>nullsFirst&amp;customComparator2 = <span class="hljs-number">2589</span><br></code></pre></td></tr></table></figure><hr><p>在 JDK 的比较器中有一个方法，可以让我们学习。就是 naturalOrder() 返回来的这个比较器。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 常规比较</span><br><span class="hljs-keyword">static</span> &lt;T extends Comparable&lt;? <span class="hljs-keyword">super</span> T&gt;&gt; <span class="hljs-function">Comparator&lt;T&gt; <span class="hljs-title">naturalOrder</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">return</span> NaturalOrderComparator.INSTANCE;<br> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NaturalOrderComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Object</span>&gt;&gt; </span>&#123;<br>    INSTANCE;<br><br>    <span class="hljs-comment">// 实现比较器定义的抽象方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Comparable&lt;Object&gt; c1, Comparable&lt;Object&gt; c2)</span> </span>&#123;<br>        <span class="hljs-comment">// 使用参数自己的“策略”</span><br>        <span class="hljs-keyword">return</span> c1.compareTo(c2);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Comparator&lt;Comparable&lt;Object&gt;&gt; reversed() &#123;<br>        <span class="hljs-keyword">return</span> Comparator.reverseOrder();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个比较器里有一个参数限制，而这个参数限制的就是必须是 Comarable 的实现类，同时是这个实现类的子类。其实，这个参数就是一个策略模式的“策略接口”，传入的参数就是具体的策略。因为这个传入的参数必须要实现 compareTo 这个方法，也就是实现 Comarable 接口的抽象方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(T var1)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/11/22/6BejY1tkK3MaUZJ.png" alt="strategy-comparator.png"></p><p>在 JDK 中更灵活的使用比较器就是使用匿名类的写法</p><p><img src="https://i.loli.net/2020/11/22/AOCGdnXKmxrYFVJ.png" alt="image-20201122223734626"></p><h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>其实抛开这个模式本身，我们在一些逻辑实现的时候也会使用这种写法，最简单的就是对一个接口方法的实现。使得他们可以在不同的情况下进行不同的切换。所以，在我们系统中，如果可能出现一些相同的操作，但是却会有很多不同的实现的时候，就是在使用这种“策略模式”来实现。每个具体的实现算法不同，但是他们的操作是相同。使用开闭原则来控制算法的入口，具体的实现延迟到子类。但当我们的具体算法变多的时候，使用起来可能会有一些副作用，所以这个时候可以考虑使用工厂模式来辅助策略模式变得更好用。</p>]]></content>
    
    
    <summary type="html">　　“通过学习策略模式来了解JDK的比较器架构是如何设计的🤔”</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>和 lvgo 一起学设计模式（十二）结构型之组合模式</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-composite.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-composite.html</id>
    <published>2020-11-18T14:46:27.000Z</published>
    <updated>2020-11-18T14:46:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/11/18/X5GxW3w6OH9pijR.png" alt="composite-title.png"></p><h1 id="聊聊自己理想的“知识”"><a href="#聊聊自己理想的“知识”" class="headerlink" title="聊聊自己理想的“知识”"></a>聊聊自己理想的“知识”</h1><h2 id="知识该怎么分享"><a href="#知识该怎么分享" class="headerlink" title="知识该怎么分享"></a>知识该怎么分享</h2><p>周末的时候去了图书馆，去计算机技术区域想找一些书看，于是翻到了一本《零基础读懂云计算》，我发现我和作者的心态非常相似，他所谈及的就是因为“云计算”被太多太多的人去层层定义，结果导致人们对“云计算”这个词语已经开始有了一些丢失本质的理解了。他站在了“云计算”的本身出发，去掉了对它的层层包装，让读者真正的明白了什么是“云计算”（通过自己的思考），而不是将“云计算”给你定义一个什么什么高大上的名词来让你觉得很神奇的一种姿态来讲，字里行间也流露着他书名的意图。至少我看了之后，可以拨开很多营销或应用谈及的“云计算”虚伪的面纱，如果某人给我说哪个应用是怎么怎么利用“云计算”来完成的某个什么什么业务的时候，我也知道该怎么去追问他然后去判断到底他是不是应用了“云计算”。</p><p>我写下的，记录的这个设计模式系列文章《和 lvgo 一起学习设计模式》也是这个初衷。我希望能把每个设计模式也当成一个单纯的“套路”记录下来，然后希望自己以后复习和现在正在阅读的你都能自己去思考其中具体的内容。而不是走马观花或<strong>强行应用某种模式</strong>写一个案例来对自己甚至是正在阅读的你来一个“<strong>洗脑式</strong>”学习。</p><p>想要掌握一个知识，一门技术，一定要有自己的理解在其中，保持着怀疑的态度可以学到更多。因为你想知道的更多，随着你知道的越多，你不知道的就越多。<strong>但要注意这个过程是一个体系的深入，而不是发散，不然你会发现自己“虚胖”。</strong></p><p><img src="https://i.loli.net/2020/11/18/cUJtwMWhu84FZxV.gif" alt="timg.gif"></p><h2 id="知识该怎么学习"><a href="#知识该怎么学习" class="headerlink" title="知识该怎么学习"></a>知识该怎么学习</h2><p>网络中的知识多如牛毛，很多内容大多都是每篇文章作者自己的理解写出来的，还有一些利用“原型模式“写出来的，无关怎么写的，作为读者的我们都应该具备一些内容虚实辨别能力，多去抽象的理解，抛开层层包装，看其本质。而不是”双兔傍地走，安能辨我是雌雄“。举个不恰当就像你怎么辨别一个人是男人还是女人，无关他穿什么衣服，是否化妆，是否整容，是不是长发，等等等等这些外在的包装。（如果是分辨正常人，一定有一个非常准确的办法，我不说你也知道）</p><h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><blockquote><p>将对象组合成树形结构以表示“部分 -整体”的层次结构。组合使得用户对单个对象和组合对象的使用具有一致性</p></blockquote><p>今天要学习的东西有点意思，因为我看到了很多有意思的内容，也在这里记录分享给现在正在阅读的你。</p><p>被拉来图书馆，电脑马上扛不住了，搞快。</p><p><img src="https://i.loli.net/2020/11/14/sMd83J2oN79yTFt.png" alt="image-20201114112656175"></p><h2 id="如何理解"><a href="#如何理解" class="headerlink" title="如何理解"></a>如何理解</h2><p>上面的定义是 <strong>Gang Of Four 在《可复用面向对象软件的基础》</strong>中对组合模式的意图阐述的内容。</p><p>不兜圈子，我先说下我是怎么理解这个设计模式的：<strong>把对象以树形结构放在一起，想要用的时候，操作组合（抽象）对象和操作任意一个对象是一样一样的。</strong> </p><p>在学习组合模式之前，我认为它就是把多个对象组装放在一起变成一个更大的对象，这就是我对组合模式最初的理解。但当我自己亲手使用组合模式来编写一段代码的时候我发现，实际情况和我所理解的还是有所差别的。当然这其中的差别只是在于具体的实现上，如果你对组合模式的理解停留在 A + B = C，我觉得这也是正确的。不过还有一个关键的内容，就是 <strong>操作组合对象和操作任意一个对象是一样一样的</strong>。</p><p>在这过程中，我问了身边的几个小伙伴，大家都说了组合模式是一个树结构。这也说明了 A + B = C 的形式体现是以树结构形式体现的，后来又在攀谈中聊到了具体的应用，比如：应用的菜单、组织架构，还有 <strong>pom</strong>（这里的 pom 要站在maven角度来看，而不是站在 xml 这种树结构来看）。</p><h3 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h3><p>上面的内容说到了 <strong>组合</strong> 模式的一个关键的定义内容，就是它的表现形式是以树形结构来呈现的，这里还想在墨迹一点东西就是组合模式只是利用了树结构这种形式的结构。</p><h3 id="一致的访问"><a href="#一致的访问" class="headerlink" title="一致的访问"></a>一致的访问</h3><p>至于后半段的定义，<code>对单个对象和组合对象的使用具有一致性</code> 理解成对树形结构当中的根节点、子节点、叶节点的访问方式都是一样的。</p><p><strong>放一张图</strong></p><p><img src="https://i.loli.net/2020/11/18/ix4bmnCvVeZt1WB.png" alt="composite-tree.png"></p><blockquote><p>图片来源 <a href="http://c.biancheng.net/view/1373.html">http://c.biancheng.net/view/1373.html</a></p></blockquote><h2 id="组合模式类图-📌"><a href="#组合模式类图-📌" class="headerlink" title="组合模式类图 📌"></a>组合模式类图 📌</h2><p><img src="https://i.loli.net/2020/11/18/IBSMYHvNkALojDb.png" alt="composite-UML.png"></p><h2 id="让我们一起利用它做点事"><a href="#让我们一起利用它做点事" class="headerlink" title="让我们一起利用它做点事"></a>让我们一起利用它做点事</h2><blockquote><p>这个案例的想法来自<code>傅哥</code>火遍全网的《重学设计模式》中组合模式的案例</p></blockquote><p>现在有一个需求，新注册的用户要进行关键信息的填写，性别、年龄。然后在首页根据用户信息进行一些商品的推送。拿到这个需求的时候是不是想着一顿 if else 猛如虎的操作来完成呢？当然我一开始也是这样想的哦，但谁知道产品经理哪天头皮发痒再给我来一个职业、地区、消费能力。。。为了满足产品未来的欲望，我想到了这个。</p><p><img src="https://i.loli.net/2020/11/18/PRYgzetrOd1uB9p.png" alt="composite-code"></p><p>通过代码实现以上结构后，</p><blockquote><p>篇幅原因完整代码关注回复“<strong>源码</strong>”获取</p></blockquote><p><img src="https://i.loli.net/2020/11/18/o7aBkLicKZWnz6G.png" alt="composite-code1.png"></p><p>核心代码</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 决策</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> user 用户信息</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 决策结果</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> DecisionComponent <span class="hljs-title">decision</span><span class="hljs-params">(User user)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (judge(user)) &#123;<br>           logger.info(<span class="hljs-string">&quot;进入 &#123;&#125; 决策分支&quot;</span>, getName());<br>           <span class="hljs-keyword">for</span> (DecisionComponent decisionComponent : decisionComponents) &#123;<br>               <span class="hljs-keyword">if</span> (decisionComponent.judge(user)) &#123;<br>                   <span class="hljs-keyword">return</span> decisionComponent.decision(user);<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>输入参数：男性、35岁</p><p>输出结果：</p><p><img src="https://i.loli.net/2020/11/18/ZRQotEphMvnbeL8.png" alt="composite-test-result.png"></p><h2 id="还有个内容要知道"><a href="#还有个内容要知道" class="headerlink" title="还有个内容要知道"></a>还有个内容要知道</h2><p><strong>透明方式和已知（安全）方式</strong></p><p>关于组合模式除了树形结构、一致的访问，还有一个就是它具体的呈现方式，这个呈现方式指的是对于 <strong>客户端</strong> 也就是高层模块，呈现方式有两种</p><ul><li>透明的，高层模块不需要去区分是子节点还是叶子节点，一样的去使用，但是对于叶子节点，某些功能可能会失效或出现一些特殊的情况</li><li>已知（安全）的，需要高层模块自己对子节点或是叶子节点的使用进行选择。</li></ul><p>对于透明和已知再通过一个 UML 类图和上面的类图对比加以说明</p><p><strong>透明的组合模式类图</strong></p><p><img src="https://i.loli.net/2020/11/18/IBSMYHvNkALojDb.png" alt="composite-UML.png"></p><p>透明的组合模式希望各个节点（子节点、叶节点）行为与抽象节点一致，这样即高层模块无需关心是否是子节点还是叶节点，方法一样的使用，但是对于子节点，因为其没有继续的分支，所以一些方法是没有具体的实现的，这就导致这些“空方法”高层模块是不知情的，所以称为透明的。</p><p><strong>已知的组合模式类图</strong></p><p><img src="https://i.loli.net/2020/11/18/Sy2Ed9eG6LOlbZz.png" alt="composite-safe-UML"></p><p>这个已知的名字是我起的，书上大多说的是安全方式。要表达的意思就是高层模块需要知道自己调用的节点是子节点还是叶子节点。</p><h2 id="发现身边的组合模式-📚"><a href="#发现身边的组合模式-📚" class="headerlink" title="发现身边的组合模式 📚"></a>发现身边的组合模式 📚</h2><p>相信大家都用过 maven 来管理多模块项目，maven的结构主要分为三类，继承、聚合、依赖，以下这些命令在 root 模块执行的时候，就可以将整个项目完成对应的操作，当你在单个模块中使用的时候，他也只会影响单个模块或该模块以下的模块。</p><p><img src="https://i.loli.net/2020/11/18/J67uzqmg8YcAPUd.png" alt="maven-lifecycle.png"></p><h1 id="再墨迹一点"><a href="#再墨迹一点" class="headerlink" title="再墨迹一点"></a>再墨迹一点</h1><p><em>设计模式这东西，我最早的理解就是武功秘籍，一招一式都是固定的。丢了一招半式可能就没用了，就像《武状元苏乞儿》中“星爷”饰演的苏乞儿最后来与赵无极那里，降龙十八掌少一掌都打不赢。而后又有无名的无名剑法、张三丰的太极剑法，万变不离其宗、无招胜有招。武学的真正奥义实为融会贯通，设计模式其便是技术这片江湖的一本绝世武功秘籍，幸运的是现在的武功秘籍人手一本。</em></p>]]></content>
    
    
    <summary type="html">　　“使用组合模式做一个简单的推荐功能，还不错哦😁~”</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>和 lvgo 一起学设计模式（十一）结构型之享元模式</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-flyweight.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-flyweight.html</id>
    <published>2020-11-12T15:03:06.000Z</published>
    <updated>2020-11-12T15:03:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/11/12/CKNbypcrJwdgflx.png" alt="flyweight-title"></p><h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><blockquote><p>运用共享技术来有效地支持大量细粒度对象的复用。</p></blockquote><p>这个设计模式在 GOF 的书中是用 flyweight 这个词来定义这种模式的，然后翻译成中文就叫 享元 了，讲真挺不自在，首先这个词是一个自造词（享元）</p><p><img src="https://i.loli.net/2020/11/12/b8iZeYslH47DO6a.png" alt="flyweight-search.png"></p><p>再者就是这个词语我认为用轻量化的解释更合适，不过现在被翻译成享元肯定是有他的原因的，至于为什么翻译享元已经不重要了，这都不会影响我们学习的对不对！</p><h2 id="如何理解"><a href="#如何理解" class="headerlink" title="如何理解"></a>如何理解</h2><p>我们先一起来理解一下这个词的意思，然后再说这个模式解决的问题，希望我的解释能帮你快速的了解这个设计模式的意图。</p><p>我是这样理解的。享元，共享单元。什么意思呢，将一些资源共享，以减少一些不必要的资源消耗。我接着举几个例子说明一下；为了代入感更强，我就拿游戏举例了。</p><p><strong>声明：以下内容只为学习类比使用，并不代表游戏设计方案，游戏如何设计实现，我未参与，也未研究，感兴趣的可自行了解。</strong></p><h3 id="1-我的世界"><a href="#1-我的世界" class="headerlink" title="1. 我的世界"></a>1. 我的世界</h3><p><img src="https://i.loli.net/2020/11/12/qOtZ4YdgxePj1Iy.jpg" alt="mc"></p><h4 id="游戏地图"><a href="#游戏地图" class="headerlink" title="游戏地图"></a>游戏地图</h4><p>我们都知道我的世界是一个自由度超高的沙盒游戏。进到游戏之后我们应该会看到一个画面，就是地图在不断的渲染。这里可能以前玩的时候大家都没有注意过，只是觉得游戏好大，但是不怎么卡。不卡的原因有很多。我们今天要说的就是如何通过享元模式来减少资源负担。</p><p>假如我的世界地图中每个单位格子的内容大小为1kb，粗略估计一个画面内格子的数量为1,000,000，此时加载地图需要 1GB 的内存，如果每个格子2kb则 2GB。如果一个单元格内容所用的贴画是 10kb 呢。目前来看 10G 内存也都能接受，可这款游戏放在当年的话，估计不会有人玩了。</p><h4 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h4><p>其实这个方案非常的正常，也非常的简单。首先我们可以这样做，事先将需要用到的格子贴画统计好，然后一次加载到内存中，记录一下内存的地址，需要用的时候，直接取出来渲染就好了。他们的样子都差不多，只是摆放的位置不同。还有一种方式呢，就是我用一个先去我的 <strong>资源库</strong> 找，找不到就创建一个放到资源库中，如果能够找到，就直接返回。这两种方式都可以。第一种方式将压力放在了启动过程，第二种的方式将压力放在第一次渲染的过程。而一般情况下，游戏的开发都是用第一种方式，也就是我们所说的“过图”，”地图加载“。这个时候去做的，因为一次卡顿加载完和你走着走着卡一下当然第一种更容易接受。</p><h3 id="2-英雄联盟"><a href="#2-英雄联盟" class="headerlink" title="2.英雄联盟"></a>2.英雄联盟</h3><p><img src="https://i.loli.net/2020/11/12/Wxw5741lX6ThejY.jpg" alt="lol"></p><p>英雄联盟这款游戏大家应该并不陌生，S10 刚刚结束（10月31日全球总决赛），SN来年再战，加油。</p><h4 id="“兵线”"><a href="#“兵线”" class="headerlink" title="“兵线”"></a>“兵线”</h4><p>游戏中一共有 3 路兵线，每次出现几只我不清楚，8只好了。 3路乘以2（双方）然后在乘以8，这应该是48个对象。而且他们还包含各自的动作，比如魔法兵吐得“口水“，炮车喝奶茶吐的“珍珠”等等，如果是你在开发兵线系统的时候，内存爆炸了，比如有的玩家搞怪，不杀小兵，积攒了很多小兵，然后他卡了，说你游戏垃圾。你该如何去做呢。</p><p>其实我们分析下来的话，这里只会出现三种不同的兵种，步兵、魔法兵、炮车。然后再分为红蓝两方。在加上两个子弹。是不是就只有这8个对象呢，至于他们的轨迹，那些是每个对象的<strong>“外部状态”</strong></p><h2 id="如何构成"><a href="#如何构成" class="headerlink" title="如何构成"></a>如何构成</h2><p>知道了这种设计模式思路，就要继续了解一下享元模式具体的构成角色都有哪些了。比如以英雄联盟的兵线为例吧。</p><p><strong>客户端</strong></p><p>首先有一个客户端，负责获取对象，然后渲染，这里我们通过#get、#draw(x,y)来表示获取和画来代替这步动作，（x，y）表示渲染出来的对象坐标。</p><p><strong>享元工厂</strong></p><p>然后还有一个为我们提供小兵的统一接口，这里使用的就是我们前面学习的工厂方法，小兵工厂。这里顺便复习一下之前的工厂和抽象工厂两个设计模式。如果我通过一个工厂来实现小兵对象的创建，那么就是一个工厂模式，但是我现在想在应用的时候，在灵活一些，我们可以从小兵身上抽取特征，比如步兵、魔法兵、炮车、这是小兵类别，但我们有两个不同的作战方，红方和蓝方，所以此时可以使用抽象工厂模式来生产小兵，红方小兵工厂生产出来的都是红方的步兵、魔法兵、炮车。蓝方生产出来的就是蓝方的步兵、魔法兵、炮车。</p><p><strong>享元对象</strong></p><p>有了工厂之后，我们就要有具体的共享对象了，共享对象就是我们上面所说的那 8 个。</p><p>下面这个类图顺便复习了一下 <strong>抽象工厂模式</strong>。</p><p><img src="https://i.loli.net/2020/11/12/dKDUbQ9sJRvFmTA.png" alt="flyweight-bingxian"></p><h2 id="享元模式类图-📌"><a href="#享元模式类图-📌" class="headerlink" title="享元模式类图 📌"></a>享元模式类图 📌</h2><p><img src="https://i.loli.net/2020/11/12/YgS7J51GWuwZPBX.png" alt="flyweight.png"></p><h2 id="代码-📃"><a href="#代码-📃" class="headerlink" title="代码 📃"></a>代码 📃</h2><p>下面就使用 <strong>享元模式</strong> 来模拟一下英雄联盟的兵线的开发。</p><p><img src="https://i.loli.net/2020/11/12/stDkSmh83HpK1TV.png" alt="flyweight-coder.png"></p><p><img src="https://i.loli.net/2020/11/12/Yrh3FlIOuH5jREd.png" alt="flyweight-test.png"></p><blockquote><p>关注回复 “源码” 获取享元模式创建LOL兵线代码。</p></blockquote><h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><ol><li>通过享元模式可以让我们用更小的空间来构造一个更大对象。这也是利用了池技术来实现的。</li><li>使用享元模式可以有效的缓解内存使用的问题。</li><li>你会发现，当你有外部状态的时候（具体体现在红蓝两方在创建小兵对象的时候，需要指定颜色），享元模式会变得稍显复杂。</li></ol>]]></content>
    
    
    <summary type="html">　　“享元模式：如果让你开发英雄联盟的兵线，你会怎么设计？”</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>和 lvgo 一起学设计模式（十）结构型之外观模式</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-facade.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-facade.html</id>
    <published>2020-11-02T14:37:09.000Z</published>
    <updated>2020-11-02T14:37:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/11/02/EhWVb7JoP3mCi9j.png" alt="facade"></p><p>今天用5分23秒，搞懂外观模式，计时~开始！</p><h1 id="书生的家书"><a href="#书生的家书" class="headerlink" title="书生的家书"></a>书生的家书</h1><p>从前，有一个书生，去到很远的地方读书。离开家里久了，难免会思念家乡，于是他便带着书童收拾好行囊，来到城门口登记 —— 接收包裹检查 —— 赶路 ——  到家。几次折腾之后，书生的成绩下滑了，身体也吃不消了，家里觉得这也不是一个长期的办法，于是商量出来一个办法：想家的时候，他便写一封家书，叫自己的书童给他带到老父亲家里。这样一来，书童便拿着他的家书，在城门口进行登记、检查包裹、然后出了城赶路。这使得书生可以专心读书，传递家书的事情，都由书童来做。</p><p><img src="https://i.loli.net/2020/11/01/wIdcHjVJ6P5fK8S.png" alt="facade"></p><p>书生再也不用为了每次登记检查包裹赶路这些事情费心了，可以<strong>专心的学习做好自己的事情</strong>了。即使哪一天不需要登记了，书生也不需要管，只需要努力学习和想家的时候写好家书送给书童就可以了。</p><p><img src="https://i.loli.net/2020/11/01/GvzmfKdp8UrjDeP.png" alt="facade1"></p><p>书生为了使自己能够更好的学习，更加专注于自己的 “业务”，将一些复杂的过程交给了书童去处理。至于书童要经历什么，书生并不关心，他只关心你给我提供传递书信的 “服务”，我给你 ”信“，你再回给我 ”信“。</p><p>这让我想到了汽车加油，好多人他们只知道没有了去加油站加油就好了，但是并没有多少人清楚石油石化业的艰辛历程。扯远了，回来说我们的问题。</p><p>对于书童这种行为，慢慢的演变成了现在的<strong>邮局</strong>。</p><h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><blockquote><p>为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</p></blockquote><h2 id="SLFJ"><a href="#SLFJ" class="headerlink" title="SLFJ"></a>SLFJ</h2><p><strong>第一个想到的外观模式具体的应用.</strong></p><p>在我学习外观模式之前，我一直在想的事情就是我哪里用到了这个设计模式，脑子里第一个蹦出来的就是 SL4J 这个日志 api 框架，他就是一个日志门面。主要的核心思想就是外观模式，他所负责的，就是书童干的事。提供你一个方法，你把参数给他，他给你返回一个记录日志的对象，至于这中间的复杂过程，你不需要知道。</p><p>赠送一个用不到的知识点：log4j、logback、sl4j 都是出自同一个作者，这也是为什么 logback 天然支持 sl4j 真香的原因之一。</p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>我想，基本上知道编程的人，应该都知道什么是 <strong>MVC</strong> ，<strong>model</strong> 、<strong>view</strong> 、<strong>control</strong> 。但大家仔细研究过这三者的关系吗？当然今天不是主要来介绍 <strong>MVC</strong> 的，而是通过 <strong>MVC</strong> 来认识外观模式。其中 <strong>V</strong> 就是书生，<strong>C</strong> 就是书童， <strong>M</strong> 就是具体的送信执行过程。<strong>书生</strong>（客户端 view）永远都不需要知道 <strong>书童</strong>（服务端 control）是如何把<strong>信送</strong>（服务端 model 业务实现）<strong>过去和拿回来</strong>的。</p><p><img src="https://i.loli.net/2020/11/01/bUaKr8cfMwG5LX4.png" alt="facade2"></p><h2 id="外观模式类图-📌"><a href="#外观模式类图-📌" class="headerlink" title="外观模式类图 📌"></a>外观模式类图 📌</h2><p><img src="https://i.loli.net/2020/11/02/O4ebA9Ma3noDVR6.png" alt="facade3.png"></p><h2 id="代码-📃"><a href="#代码-📃" class="headerlink" title="代码 📃"></a>代码 📃</h2><blockquote><p>回复“源码”获取书童送信全部代码</p></blockquote><p>我们通过代码在看一下书童是如何帮助书生完成送信的，<del>看看他路上有没有偷懒</del> 。</p><p><img src="https://i.loli.net/2020/11/02/F8Iv1RbrgnxSlKw.png" alt="shutongsongxin.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 书生送信 - 书生</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 欢迎跟我一起学习，公众号搜索：星尘的一个朋友</span><br><span class="hljs-comment"> * 也可以加我微信（lvgocc）拉你进群</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@blog</span> <span class="hljs-doctag">@see</span> http://lvgo.org</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CSDN</span> <span class="hljs-doctag">@see</span> https://blog.csdn.net/sinat_34344123</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/11/2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShuSheng</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ShuSheng.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        LOGGER.info(<span class="hljs-string">&quot;书生写好信给了书童&quot;</span>);<br>        ShuTong shuTong = <span class="hljs-keyword">new</span> ShuTong();<br>        shuTong.songXin();<br>        LOGGER.info(<span class="hljs-string">&quot;书童拿回了信给了书生&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/11/02/Lmv8Uq7wo4pNWQx.png" alt="shutongsongxin1.png"></p><p>我们通过代码可以看出，整个过程书生也没有参与送信的具体过程，这些全部都由书童（外观角色）来完成，这其中设计了 2 个子系统，城门和老父亲。</p><h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>迪米特法则又叫作最少知识原则 LOD/LKP ，1987 年美国东北大学👨‍🎓（Northeastern University）的一个名为迪米特（Demeter）的研究项目….(更多内容关注公众号点击“设计模式”专题序章查看)；</p><p>外观模式是一个遵循了迪米特法则的一种设计模式。书生只知道送信找书童，但他不需要知道还要登记、检查等等其他的事情。</p><p>外观模式又称作门面模式，理解成门面感觉会更好的理解是不是。至少我认为更好理解一些。就像人的脸面嘛，比如有一件事叫我做，你就跟我说嘛，你也不知道我怎么想的，怎么做的，我给你反馈结果就好了。当然例子可能不是很恰当，希望我要表达的意思能让你看的清楚。</p><p>外观模式主要特征</p><ol><li>√ 降低了系统间的耦合度，子系统的变化不会影响高层模块的调用。</li><li>√ 提高了高层模块的使用理解。我只想送信，给我接口。</li><li>× 违背了开闭原则，其实你只要没有遵循依赖倒置，就一定会在功能增加或变更的时候违反开闭原则。如果想要不违背开闭原则，那就需要将依赖的具体的类，转成依赖抽象的类或接口。</li></ol><p><strong>外观模式的扩展</strong> ：上面的案例还可以可以使用一个接口来代替书童的位置，然后让书童来实现这个接口，后面如果想要新增一种送信的工具人实现或者继承送信的接口就可以了。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>一转眼设计模式已经学了 10 种了。时间也过去 3 周了，有些内容可能已经慢慢的开始忘记了，我偶尔也会打开之前的文章在看上一下，如果第一遍第二遍仔细的看过，那后面再看就可以很快的复习一遍。学习任何知识也是如此，如果第一遍第二遍都是走马观花的看，后面每次看都会觉得很陌生，如果前面可以仔细的看过，然后定期的复习，很多东西都可以很容易做到，只是时间的问题。当然我这种都是比较笨的学习方法，但是还是蛮有效的。也特别希望大家能够在群里一起讨论一起学习复习，因为每次交流都是一次加深印象的时刻。</p><p><strong>真正掌握一个知识的时候，便是你能把它教给别人的时候。</strong></p>]]></content>
    
    
    <summary type="html">　　“书生的家书是谁送的？书童到底是个什么角色？”</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>和 lvgo 一起学设计模式（九）结构型之适配器模式</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-adapter.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-adapter.html</id>
    <published>2020-10-29T15:37:09.000Z</published>
    <updated>2020-10-29T15:37:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/10/29/ir7LvpWXUykRABw.png" alt="adapter-title.png"></p><h1 id="什么是”榫”"><a href="#什么是”榫”" class="headerlink" title="什么是”榫”"></a>什么是”榫”</h1><p>嘶衣唔嗯ěn损，fao喽密，榫！</p><p>首先，让我们面向百度学习一波。</p><p><img src="https://i.loli.net/2020/10/28/aDRfCgLMbvmUZnS.png" alt="sun.png"></p><p>榫[sǔn]：制木竹等器物时，为使两块材料接合所特制的凸凹部分。</p><p>感觉不够直观，找点图看看。</p><p><img src="https://i.loli.net/2020/10/28/xPUfBl5RESaKW8J.png" alt="sun-picture.png"></p><p>再来点</p><p><img src="https://i.loli.net/2020/10/28/k4rIqmhKWfe5L76.png" alt="sun-picture2.png"></p><p>这里我借花献佛一下，榫说的是两块材料接合凸起的部分，凹进去的部分叫卯。</p><p>这东西是干什么用的呢，我不说大家也知道，是两块材料接合所用（切，这不废话吗，就是百度百科上说的么）。在中国建筑当中这个榫卯的用途可以说是处处皆是。现在已经火到了国外。</p><h1 id="榫卯"><a href="#榫卯" class="headerlink" title="榫卯"></a>榫卯</h1><p>本来两种材料，一榫、一卯搭配的天衣无缝，怪就怪这建筑用的多了起来之后，各种各样的榫，各种各样的卯。也没办法统一，垄断法了解一下。</p><blockquote><p>以下图片资源来自《设计模式之禅（第2版）》对其进行了一些简单的调整。</p></blockquote><p><strong>原来都是这样进行搭配</strong></p><p><img src="https://i.loli.net/2020/10/28/Qx7Om2BNFEro8fW.png" alt="adapter.png"></p><p><strong>突然有一天给了我一个</strong></p><p><img src="https://i.loli.net/2020/10/28/TzyObZe9FwC8GEh.png" alt="adapter1.png"></p><p>这两个材料怎么接，榫不对卯，卯不对榫，接不上啊。</p><p><img src="https://i.loli.net/2020/10/29/1h7yW2JRQPDzpgl.png" alt="adapter2.png"></p><p>这可难不倒伟大的工匠艺人们，他们做出来了一个 榫卯，大概是这个样子。</p><p><img src="https://i.loli.net/2020/10/28/w165r3qAvaLFNXO.png" alt="adapter3.png"></p><p>这样他们就能完美的接在一起使用了。这就是榫卯。</p><p><img src="https://i.loli.net/2020/10/28/Enzvuswex8IKpDX.png" alt="adapter4.png"></p><p>榫卯使得本来不能直接接合的材料能够接合起来了。看到这里让我想到了插在大哥电脑上的扩展坞</p><img src="https://i.loli.net/2020/10/28/bxq2FramOUyuzh1.jpg" alt="kuozhanwu" style="zoom:25%;" /><p>这是华为的扩展坞，整个电脑上就两个外接口，一个充电口，一个这个扩展坞的口。想接 USB 设备必须要经过这个扩展坞才可以。</p><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><blockquote><p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p></blockquote><p>首先大家要知道一个可能一直被大家忽略的一个问题就是，适配器模式一共有两种，一种是类适配器，另一种叫做对象适配器。这两个是什么东西呢。</p><p><strong>类适配器：通过类的继承或者接口的实现来达到适配目的；</strong></p><p><strong>对象适配器：通过对象的组合来达到适配目的；</strong></p><h2 id="适配器模式类图-📌"><a href="#适配器模式类图-📌" class="headerlink" title="适配器模式类图 📌"></a>适配器模式类图 📌</h2><p>再来看看图，消化吸收一下。</p><p><img src="https://i.loli.net/2020/10/28/FcmQRrVDGqSCsuz.png" alt="adapter-class.png"></p><p>目标接口为应用期望的一个接口格式，源接口为已经存在的一种接口规范格式。</p><p>代码不能重写。（工作量，系统稳定性，等等原因。）</p><p>这时我们需要引入一个中间类，继承原来的业务逻辑类，也就是源接口，然后实现我们所期望的目标接口，通过中间的类将源接口中的方法，封装到我们自己所期望的目标接口方法中。这种方式就是<strong>类适配器</strong>。</p><p><img src="https://i.loli.net/2020/10/28/Vc71iPM6j3BXfvl.png" alt="adapter-object"></p><p><strong>对象适配模式</strong>是通过对象的组合来替代类的继承，好处我真的不想再说了，合成复用原则中讲过优先使用对象组合，其次考虑类的继承。</p><p>就像上一篇的桥接模式一样，继承虽方便，但扩展性太差。同时耦合度很多，如果真的是使用继承，一定是具备一定强度的耦合条件时才会考虑。</p><p>像对象四佩奇这种方式会更加的灵活。一般适配器更多会选为这种方式来进行两个接口的连接。</p><h2 id="代码-📃"><a href="#代码-📃" class="headerlink" title="代码 📃"></a>代码 📃</h2><p>学习适配器模式的时候，我没有再去找一些应用的案例来学习，因为我就一直在用这个模式。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateUtil</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String YYYY_MM_DD = <span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String YYYY_MM_DD_TIGHT = <span class="hljs-string">&quot;yyyyMMdd&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getTightDate</span><span class="hljs-params">(Date date)</span> </span>&#123;<br>        Calendar calendar = <span class="hljs-keyword">new</span> GregorianCalendar();<br>        calendar.setTime(date);<br>        SimpleDateFormat df = <span class="hljs-keyword">new</span> SimpleDateFormat(YYYY_MM_DD_TIGHT, Locale.CHINA);<br>        <span class="hljs-keyword">return</span> df.format(calendar.getTime());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">format</span><span class="hljs-params">(Date date)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (date == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleDateFormat(YYYY_MM_DD, Locale.CHINA).format(date);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这个是日期工具类，我们经常会有这种场景，数据库存放的是 Date 类型，但接口给过来的是 String 类型，或者这两者相反，总之需要将其正常存储或返回，这个时候我们通常会采取使用一个日期工具类，将数据格式进行一个转换，这其中，工具类担任的角色，我认为就是适配器的一个职责，”将两个本不能直接结合的材料进行了接合“。这个看起来很简单，但这就是适配的模式的精髓，就是为了解决类似问题而存在的。如果把上面的程序用一个类图来表示的话，就是这个样子。</p><p><img src="https://i.loli.net/2020/10/29/ZOHQ6bjR3otV9MP.png" alt="dateUtil-adapter.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 数组工具类</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 欢迎跟我一起学习，公众号搜索：星尘的一个朋友</span><br><span class="hljs-comment"> * 也可以加我微信（lvgocc）拉你进群</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@blog</span> <span class="hljs-doctag">@see</span> http://lvgo.org</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CSDN</span> <span class="hljs-doctag">@see</span> https://blog.csdn.net/sinat_34344123</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/10/29</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArraysUtil</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">asList</span><span class="hljs-params">(T... a)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(a);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">            <span class="hljs-keyword">implements</span> <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><br><span class="hljs-class">    </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">2764017481108945198L</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> E[] a;<br><br>        ArrayList(E[] array) &#123;<br>            a = Objects.requireNonNull(array);<br>        &#125;<br>        .......<br>            ......<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个数组工具类，大家应该都很熟悉，没错，这就是 JDK 中的 Arrays 工具类中的 asList 方法。记住哦，这种方式创建出来的 List 是不能够使用 add 方法的哦，因为此 ArrayList（java.util.Arrays.ArrayList） 非彼 ArrayList (java.util.ArrayList)，这个 ArrayList 里面没有重写 add 方法，这个知识点是送的，别客气。</p><p>在列举一下 JDK 中的适配器大家看一看，随便感受一下就好了。</p><p><img src="https://i.loli.net/2020/10/29/iEl5pgUCJtTqYbQ.png" alt="jdk-adapter1.png"></p><p><img src="https://i.loli.net/2020/10/29/EPbLzTx47Oljfu8.png" alt="jdk-adapter2.png"></p><p><img src="https://i.loli.net/2020/10/29/acZyqYIs7onLUVw.png" alt="jdk-adapter3.png"></p><p>哦，这里还有群里小伙伴@ruize 提供的一个他写的适配器，一起和大佬学习一下</p><p><img src="https://i.loli.net/2020/10/29/qHFrDaKclkP8MOY.png" alt="ruize-adapter.png"></p><h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>适配器模式叫我总结，只有两字。”能用就行“，为什么用这两个字来总结，是因为适配器本身就是一个在出现问题以后用来补救的。像一个补丁一样。一般人不会上来就在系统初期写一些适配器在那里，如果是像上面列的一些对象转换的话合情合理。</p><p>适配器模式的出现是为了解决系统一些牵一发而动全身的事情，我们可以想象一下我的电脑没有 USB 接口（华为今年的最新款）难道我要把电脑拆了装个 USB 模组在里面吗？这显然是不可能的。所以有了扩展坞这东西。他就是为了解决这个问题的。（华为电脑这个是设计就没把外接设备接口留着，只留了一个充电的，和一个扩展坞的两个口）</p><ol><li>首先，适配器模式不会用在系统初期。</li><li>其次，他是一个亡羊补牢一样的存在，你永远不知道系统的发展会遇到什么变故。只有出现需要的时候才会使用，不是故意设计的。就像你本来好好的接的 A 厂商接口，系统都开发完上线一年了，A 厂商说啥都不干了，你怎么办，现在有 B 厂商一样功能的接口，但接口规范不一样。这个时候就需要用适配器去补救了。</li><li>代码复用，适配器模式可以充分的体现出代码复用。用一个适配类，解决修改老代码的尴尬局面。体现粗了老的代码可以完美的继续使（复）用。否则需要将老代码重构成新接口的规范，如果 B 厂商在换一次，估计开发人员头要炸了。</li></ol>]]></content>
    
    
    <summary type="html">　　“今天轻松点，就说说什么是“榫”，什么是“卯”，什么是“榫卯”！干杯🍻”</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>和 lvgo 一起学设计模式（八）结构型之桥接模式</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-bridge.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-bridge.html</id>
    <published>2020-10-28T12:24:18.000Z</published>
    <updated>2020-10-28T12:24:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/10/29/YIpkj5QDBHb7ytN.png" alt="timg"></p><h1 id="科普闲聊"><a href="#科普闲聊" class="headerlink" title="科普闲聊"></a>科普闲聊</h1><blockquote><p>复杂度守恒定律由Larry Tesler于1984年提出，也称泰斯勒定律（Tesler’s Law）。复杂度守恒定律（Law of conservation of complexity）由Larry Tesler于1984年提出，也称泰斯勒定律（Tesler’s Law）。<br>根据复杂度守恒定律，每个应用程序都具有其内在的、无法简化的复杂度。无论在产品开发环节还是在用户与产品的交互环节，这一固有的复杂度都无法依照我们的意愿去除，只能设法调整、平衡。</p></blockquote><p>这一观点主要被应用在交互设计领域。我们不得不面对的问题是，该由谁来为这一固有的复杂度埋单。打个比方，应该由软件开发工程师花费额外的时间来使软件变得更加简单好用，还是应该让用户自己去解决软件使用中可能存在的问题？</p><p>以上出自百度百科：<a href="https://baike.baidu.com/item/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AE%88%E6%81%92%E5%AE%9A%E5%BE%8B/7508660?fr=aladdin">复杂度守恒定律 - 百度百科</a></p><hr><p>如上所述，复杂度守恒定律是一个规避不掉的东西，最早的时候我接触到这个词是发出的一个提问，当时有各种大佬出来解答，大家感兴趣可以去看看。</p><p> <a href="https://bbs.csdn.net/topics/392308895">到底什么是RPC?远程调用有什么好处?</a></p><figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">迷惑不解,不知是何.<br>我了解了一下dubbo框架,很多的术语搞得是更加模糊不清.<br>顺便提一点,<br>为什么深奥的东西就是被人向往的?<br>将复杂的东西弄成粗浅易懂的这不是更好吗?<br><br>2018-01-15 09:04:03<br></code></pre></td></tr></table></figure><p>但我一直以为，技术的东西，本就不复杂。让它变得复杂的是我那迫切想要得到结果的心。</p><p>学习从来都没有捷径，你只是想要速成。学的快慢是一个问题，学与不学是另一个问题，听懂掌声。</p><hr><h1 id="学习时间"><a href="#学习时间" class="headerlink" title="学习时间"></a>学习时间</h1><h2 id="2020年10月的某一天午饭后"><a href="#2020年10月的某一天午饭后" class="headerlink" title="2020年10月的某一天午饭后"></a>2020年10月的某一天午饭后</h2><p>“桥接模式？，那是个啥” 心中突然蹦出这么一个想法。我心血来潮，打开 Google ，输入 <code>桥接模式</code> ，回车走你，等了半天。</p><p><img src="https://i.loli.net/2020/10/26/dJ7BuUjW9RcpQiE.png" alt="google-error.png"></p><p>这丝毫没有影响到我的情绪<del>（艹）</del>，随即我快速的切换搜索引擎视图忘掉刚刚发生的这一切。又是一记回车敲出，这次，它出现了</p><p><img src="https://i.loli.net/2020/10/26/uZGN4z3ckbvI72T.png" alt="baidu-bridge.png"></p><p>不知道是我手不行了，还是键盘要坏了，总之模式两字没带上，出来个桥梁，想着都差不多（呸，差不多个鬼）就看看吧，顺便学习了一下桥梁的专业释义（我就是这样东西越看越多，越看越杂的！龇牙咧嘴中！）。</p><p>不行，得回过神来，继续找<code>桥梁模式</code>去。这怎么都一样啊，<strong>抽象化</strong>、<strong>实现化</strong>、<strong>脱耦</strong>看不懂啊，然后就是那个到处都是，其实出自菜鸟教程的图形案例。</p><p><img src="https://i.loli.net/2020/10/26/vcIRdKGbMN4teTD.png" alt="runoob-bridge.png"></p><blockquote><p>图片来源：<a href="https://www.runoob.com/w3cnote/bridge-pattern2.html">https://www.runoob.com/w3cnote/bridge-pattern2.html</a></p></blockquote><p>先看看问题吧，一个图形有2种形状（圆形、矩形）和2种颜色（红色、蓝色）的时候怎么去用类表示，我啥也不说，那肯定继承啊，我这 <strong>封装、继承、多态老扎实了</strong>。</p><p>心里念着”首先有一个<strong>图形</strong>的基类，然后开始继承走起 <strong>红色的圆形</strong>、 <strong>红色的矩形</strong>、 <strong>蓝色的圆形</strong>、<strong>蓝色的矩形</strong>。“ 没毛病，一个抽象类，四个实现类，搞定。</p><p><img src="https://i.loli.net/2020/10/28/qcKwM42eOFBg6Vu.png" alt="bridge.png"></p><p>代码写完，测一手。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shape</span><span class="hljs-params">()</span></span>&#123;<br>    Shape blueCircle = <span class="hljs-keyword">new</span> BlueCircle();<br>    Shape blueRectangle = <span class="hljs-keyword">new</span> BlueRectangle();<br>    Shape redCircle = <span class="hljs-keyword">new</span> RedCircle();<br>    Shape redRectangle = <span class="hljs-keyword">new</span> RedRectangle();<br><br>    blueCircle.create();<br>    blueRectangle.create();<br>    redCircle.create();<br>    redRectangle.create();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs reStructuredText">蓝色の圆形<br>蓝色の长方形<br>红色の圆形<br>红色の长方形<br></code></pre></td></tr></table></figure><p>感觉还可以，这时坐在我边上的大哥说了句，如果再加一种形状呢？</p><p>我：“卧槽，你啥时候来的，想要偷窥我学习？”</p><p>大哥：“先回答问题，别转移话题” </p><p>我：“再加两个类不就行了”， <strong>RedTriangle</strong>、<strong>BlueTriangle</strong>，</p><p>大哥：“也还行，如果再这基础上再加一种绿颜色呢？” </p><p>我：“额。。。再加三个类 <strong>GreenCircle</strong>、 <strong>GreenRectangle</strong>、<strong>GreenTriangle</strong>。。。（开始声音微弱）”</p><p>大哥：“再加一个椭圆呢” </p><p>“emm… 我刀呢！”</p><p>“老弟别激动，大哥帮你看看”</p><h2 id="大哥帮忙诊断代码"><a href="#大哥帮忙诊断代码" class="headerlink" title="大哥帮忙诊断代码"></a>大哥帮忙诊断代码</h2><p>大哥：“你这个是 <strong>乱用继承</strong> 导致的类爆炸晚期啊，要是不拔除对这种继承的理解，基本是废了啊”</p><p>我：“大哥我还不想放弃，救救我，咳…咳（一口老血咳出）”</p><p>大哥：“那你说说看，你都是什么时候用的继承？”</p><p>我：“多个类有共同特征的时候，会抽象出来特征，然后使用继承来扩展”</p><p>大哥：“嗯，看来你还有救，那你看你现在抽象出来的东西对吗？”</p><p>我小声嘀咕：“很多图形，抽象出来个图形，没问题啊”</p><p>大哥：“那颜色呢？颜色和图形是什么关系？”</p><p>我：“emm….，什么什么关系啊？大哥，给点提示吧”</p><p>大哥：“UML中的聚合组合我没教你么？”</p><p>我：“这个真没有”</p><p>大哥：“那这个地方我再教你一次，记着点奥。咳咳！”</p><p><img src="https://i.loli.net/2020/10/27/RQfH3ho9Zg7TJmG.png" alt="uml"></p><p>大哥：“这个就是组合和聚合的意思，同时他们与主体之间的关联关系的表达。”</p><p>大哥：“现在在看你的 <strong>类爆炸</strong> 知道怎么医治了么？”</p><p>我：“我应该把颜色也抽象出来，然后使用聚合与图形进行关联！对不对！”</p><p>大哥：“还不赖嘛，你继续看吧，我忙我的去了”</p><h2 id="重构代码"><a href="#重构代码" class="headerlink" title="重构代码"></a>重构代码</h2><p>领悟了大哥的意思之后，我对代码进行了重构。</p><p>仍然将图形类抽象出来，同时将颜色作为一个接口引入，因为图形的形状和颜色本来就是两个不同的维度，所以它现在的类图应该是这个样子的。</p><p><img src="https://i.loli.net/2020/10/27/DUeGhk2pIcoKdwW.png" alt="bridge1.png"></p><p>有了类图，很快我就重构好了代码，测试一下。</p><blockquote><p>完整代码关注公众号回复：“源码” 获取</p></blockquote><p><img src="https://i.loli.net/2020/10/27/EPTuQae6DofyFSG.png" alt="bridge-test.png"></p><p>当我要新增一种图形或者一个颜色时，只需要增加一个类就可以了。真香。</p><h1 id="bridge-桥梁（接）模式"><a href="#bridge-桥梁（接）模式" class="headerlink" title="bridge 桥梁（接）模式"></a>bridge 桥梁（接）模式</h1><blockquote><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p></blockquote><h2 id="把这绕口的东西看清楚"><a href="#把这绕口的东西看清楚" class="headerlink" title="把这绕口的东西看清楚"></a>把这绕口的东西看清楚</h2><p>将抽象部分与它的实现部分分离，使他们都可以独立地变化。这句话我不知道别人能不能读的懂，就我而言，刚看到这句话实在是没有搞清楚在表达什么，我猜想其中的原因，一个是因为设计模式是搞建筑的人提出来了，另一个原因是老外写的软件设计模式。翻译成中文为了达到统一的标准，所以很多知识变得晦涩难懂。</p><p><em>这里在顺带提一下所谓的统一的标准，就像开放平台的接口一样。他为了有更好的扩展性，定义了统一的对外接口，以后无论哪方想要对接，都需要适应我的标准，而不是给每个人都定制化一个接口。所以知识的传播也一样，要以一定的官方标准来定义和传播，不然可能传着传着就出现了歧义。这也就是复杂度守恒定律的根本，它本身其实真的并不复杂。以上个人见解，可以无视。</em></p><h2 id="在看抽象化、实现化、脱。脱。脱你妹啊脱，解耦。"><a href="#在看抽象化、实现化、脱。脱。脱你妹啊脱，解耦。" class="headerlink" title="在看抽象化、实现化、脱。脱。脱你妹啊脱，解耦。"></a>在看抽象化、实现化、脱。脱。脱你妹啊脱，解耦。</h2><p>因为之前有大哥的帮忙，所以很容易就理解了<code>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</code>这句话。</p><p>就拿我刚刚学的图形的那个案例。</p><ul><li>抽象部分就是图形的形状+颜色，图形它一定是有形状和颜色的。存在自身上的两个不同的维度变化</li><li>实现部分就是具体的形状和颜色。形状和颜色一定有具体的体现。要么圆形红色，要么方形透明。而形状又是图形本身的一部分，所以可以跟在主体后通过继承进行变化。颜色可以独立出去进行单独的扩展。</li></ul><p>独立的变化就是讲到抽象部分和实现部分的两个实现</p><ul><li>抽象部分的一个变化就是通过一个矩形类继承图形抽象类。同时完善一个构造函数，这是对抽象部分的矫正或者完备。</li><li>实现部分的变化遵循了<strong>里式替换</strong>与抽象部分的关联又根据<strong>依赖倒置</strong>原则设计。所以实现部分可以在自己的接口定义范畴能进行自由变化，同时又可以与抽象部分进行关联<strong>（桥接）</strong></li></ul><p>我试着把晦涩的东西简化一下</p><p><strong>一个对象的多个维度状态独立变化时，将其通过类组合的方式进行关联，使其每个维度自由变化，降低与主体的耦合。</strong></p><h2 id="桥接模式类图-📌"><a href="#桥接模式类图-📌" class="headerlink" title="桥接模式类图 📌"></a>桥接模式类图 📌</h2><p><img src="https://i.loli.net/2020/10/27/eQgjH6wkB2pSLfO.png" alt="bridge2.png"></p><h2 id="代码-📄"><a href="#代码-📄" class="headerlink" title="代码 📄"></a>代码 📄</h2><blockquote><p>完整代码关注公众号回复：“源码” 获取</p></blockquote><p><img src="https://i.loli.net/2020/10/27/iXWcetHJUxyBFNT.png" alt="bridge-code.png"></p><h2 id="总结-🐱‍💻"><a href="#总结-🐱‍💻" class="headerlink" title="总结 🐱‍💻"></a>总结 🐱‍💻</h2><p>哎呀，这个桥接模式我是万万没想到它会是这个样子。同样又是学完不知道在哪用的一种模式，但这就是我放弃学习的理由？那可真是太可笑了。</p><ul><li>当一个对象内存在多个维度多种状态时，可以使用桥接模式解耦，以防新增维度状态时导致 <strong>类爆炸</strong></li><li>维度的体现可以延迟到使用阶段，比如上述例子，颜色被分离出去，当需要具体对象时，在通过 set 方法对维度赋值（回复源码，获取全部源码和文章原稿）</li></ul><p>桥接模式的好处大家都看在眼里，记在心里。用了桥接模式首先解决的就是因为乱用继承导致的类爆炸问题，同时无论之后怎么扩展类，都只需要在对应维度维护新的实现就可以了，降低了对象间的耦合。</p><p>不好的地方，整个设计模式的缺点全都包含这一条： <strong>增加了系统的复杂性，对系统设计的理解多了一层内容。维护的类变多了。</strong> 这更能体现出一劳永逸的感觉，先吃苦，后舒坦。其实对于桥接模式还有一点，就是需要你能正确的去划分出一个对象的多维度状态，不然又成了“手里拿个锤子，看什么都像钉子”的感觉了。</p><h1 id="打工人的早高峰"><a href="#打工人的早高峰" class="headerlink" title="打工人的早高峰"></a>打工人的早高峰</h1><p>今天的公交车一点都不挤！就是下车的时候鸡蛋不知道咋回事碎了！还好是鸡蛋碎了，听懂掌声。</p>]]></content>
    
    
    <summary type="html">　　“这个不常用的设计模式居然被我学的最透，草率了！一起学习技术，为了梦想。干杯🍻”</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>和 lvgo 一起学设计模式（七）结构型之装饰者模式</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-decorator.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-decorator.html</id>
    <published>2020-10-25T07:40:27.000Z</published>
    <updated>2020-10-25T07:40:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>一直都有看到“包装者模式“ 出现在一些文章，甚至书中。它们被应用在装饰者模式和适配器模式中，这个原因笔者猜测源自 GOF 最早在书中给模式命名的时候提到了这两个模式的别名 wrapper同时还有适配器也被成为 wrapper, 所以有人将这几个名称混来混去。后来 GOF 在结尾讲书的简史的时候有提到一些模式的名称变化，其中 glue 改成了 facade， wrapper 改为 decorator ，walker 变成了 visitor 。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前阵子出于自己学习使用的原因开发了一个 chrome extension ，这样我的 chrome 变得比以前更强了，我赋予了它一个可以保存某个页面的某个片段的位置，后续通过点击这个记录可以快速的回到并高亮当时浏览的记录。</p><p><img src="https://i.loli.net/2020/10/24/hb75jWUIlHGdmu1.png" alt="memo1"></p><p><img src="https://i.loli.net/2020/10/24/HamO9V56Y3bMKJP.png" alt="memo"></p><p><strong>我给 chrome 简单的装饰了一下（加了一个插件），它就变强了</strong></p><p><code>插件开源，可以作为基础进行二次开发，想要开发 chrome 插件但是不知道如何开始的可以参考。关注</code><strong>星尘的一个朋友</strong><code>公众号，回复源码获取</code></p><h2 id="不知不觉你已经知道了装饰者的概念。"><a href="#不知不觉你已经知道了装饰者的概念。" class="headerlink" title="不知不觉你已经知道了装饰者的概念。"></a>不知不觉你已经知道了装饰者的概念。</h2><blockquote><p>动态地给一个对象添加一些额外的职责</p></blockquote><p><img src="https://i.loli.net/2020/10/24/j7fU3RozypgGWAN.png" alt="chrome"></p><p><img src="https://i.loli.net/2020/10/24/EqQbkpzTeP6n5t3.png" alt="chrome"></p><p>上面两个举出的例子在实际过程中只要你想，你可以无限的装饰它，所以装饰者的类，可以一直嵌套下去。就像</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">InputStream in = <span class="hljs-keyword">new</span> DataInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;filePath&quot;</span>)));<br></code></pre></td></tr></table></figure><p>如果IO不熟，看得不理解，那再看看这个</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;Object&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list = Collections.synchronizedList(list);<br></code></pre></td></tr></table></figure><p>其实，当我写到这里的时候已经很清楚装饰者的概念了，它就是通过“套娃”变强了😂！</p><p>让我继续深入看看它的结构图👀。</p><h2 id="装饰者模式类图-📌"><a href="#装饰者模式类图-📌" class="headerlink" title="装饰者模式类图 📌"></a>装饰者模式类图 📌</h2><p><img src="https://i.loli.net/2020/10/25/L2a951Jf7cIspGK.png" alt="装饰者模式类图"></p><p>一个浏览器的接口，一个 Chrome 实现类，一个 ChromeExtension 插件的实现类（用以装饰 Chrome），扩展中的构造函数为 浏览器类型，在插件类中会对浏览器 Brower 的 browse 方法进行一层装饰（增强，或减弱），在不改变对象的情况下，对对象行为进行动态的改变。</p><p>上面的类图在抽象一层的话就变成了了这个样子</p><p><img src="https://i.loli.net/2020/10/24/iJMe7mblkcOGTV2.png" alt="装饰者模式类图"></p><blockquote><p>为了示意，名称使用了中文，当然如果能够让人清楚你在干什么，无所谓你怎么表达。</p></blockquote><p>通过对象的组合来实现类的增强要比继承更加的灵活。这也是软件设计原则中的组合复用原则的一种体现，优先使用组合，然后考虑继承。</p><h2 id="代码-📄"><a href="#代码-📄" class="headerlink" title="代码 📄"></a>代码 📄</h2><blockquote><p>关注公众号：星尘的一个朋友 回复：<code>源码</code>，获取全部代码和类图</p></blockquote><p><img src="https://i.loli.net/2020/10/25/qsjOMU9HLpcnlzP.png" alt="decorator-code"></p><p>代码演示通过一个游戏获取道具的方式来理解装饰者模式的具体实现；</p><p>想来想去，我没有选择超级玛丽，图难找，代码不好表达🤣</p><p>所以我选择了它 <strong>Tank Battle</strong> <img src="https://i.loli.net/2020/10/24/KED9OZhFk7WGtbl.jpg" alt="tank">😂</p><p><code>很多回忆都在这里</code>而且好表达😁</p><p>在这游戏中，我们吃到一个星星⭐的时候，就会变强，可以发射两发子弹，同时样子也会发生改变。</p><p><img src="https://i.loli.net/2020/10/25/hfzJVmHCj6sNIEq.png" alt="image-20201025111349260"> 吃了这个星（装饰），我变得更强 <img src="https://i.loli.net/2020/10/24/uQvdNDEV7JmLBCZ.gif" alt="p1tankU">  ==&gt;&gt;  <img src="https://i.loli.net/2020/10/24/QvIyB28tdxSjnrK.gif" alt="star"> ==&gt;&gt; <img src="https://i.loli.net/2020/10/25/ANrTSZUghK5lcot.gif" alt="enemy3U"></p><h3 id="结构组成"><a href="#结构组成" class="headerlink" title="结构组成"></a>结构组成</h3><ol><li>被装饰者接口</li><li>具体的装饰者类</li><li>抽象装饰者</li><li>具体的装饰者</li></ol><p>因为星星强化一共有 3 个级别</p><ul><li><p>移动、子弹加速</p></li><li><p>连发</p></li><li><p>打掉白色方块</p></li></ul><p>所以我们应该有 3 个装饰者。类角色。</p><ol><li>被装饰者接口 -&gt; 坦克 Tank</li><li>具体的被装饰者 -&gt; 玩家坦克 PlayerTank</li><li>抽象装饰者 -&gt; 用来抽象定义装饰者基本信息，如构造函数等 TankDecorator</li><li>具体的装饰者 -&gt; OneStarTankDecorator -&gt; TwoStarTankDecorator -&gt; ThreeStarTankDecorator</li></ol><p><img src="https://i.loli.net/2020/10/25/LySXmYe7CJov9wx.png" alt="decorator"></p><p><strong>部分代码</strong></p><blockquote><p>关注公众号：<code>星尘的一个朋友</code> 回复：<code>源码</code>，<strong>获取全部代码和类图</strong></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 玩家坦克</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/10/25 11:40</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlayerTank</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tank</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 玩家默认坦克数据，移动，设计速度 1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PlayerTank</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义坦克抽象装饰者</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/10/25 11:40</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TankDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tank</span></span>&#123;<br><br>    <span class="hljs-keyword">protected</span> Tank tank;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TankDecorator</span><span class="hljs-params">(Tank tank)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.tank = tank;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">()</span> </span>&#123;<br>        tank.move();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fire</span><span class="hljs-params">()</span> </span>&#123;<br>        tank.fire();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果</p><p><img src="https://i.loli.net/2020/10/25/FaRXJTVbftoL3sY.png" alt="image-20201025141131981"></p><h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>坦克增强的过程是一颗星一颗星获取的一个过程，一直在动态的增强。这个案例中只是一个维度，坦克吃星星。如果在增加一些额外的功能时，比如坦克变身，进化等等，不断的增加装饰时，就可以体会到装饰者模式组合的可扩展性。当然使用继承来实现的话，如果是单一不变的多种状况是很好的，比如说我的玩家坦克的选择不同的外观，可通过不同的子类来确定下来，但如果动态的想要增加一个类的时候，继承就显得非常的困难。</p><p>装饰者模式在不改变原对象的情况下，动态的增强具有较好的可扩展性。这也体现了<code>开闭原则</code>。但我们发现，如果你不合理的使用装饰者模式，类的数量会变的更多，且多重装饰使一个对象的维护变的更加复杂。所以，就像前面说的，具体的特性就完全可以用继承来实现而非装饰者模式，装饰者模式一定是使用在想要动态的给对象增加一些功能的时候使用。</p><ul><li><p>比如 JDK 中对 IO 的操作有一个 read() 操作，对它进行装饰之后就变成了 readLine().<br><img src="https://i.loli.net/2020/10/25/hBN54spCA7yaqto.png" alt="image-20201025143102142"><br><img src="https://i.loli.net/2020/10/25/thRfTdxnbvZpNEV.png" alt="image-20201025143124892"><br><img src="https://i.loli.net/2020/10/25/abst7No5EjLGFQY.png" alt="image-20201025143158945"></p></li><li><p>再比如 JDK 中的 Collections 工具类，通过对集合类的装饰，使其变得线程安全，而对象本身却没有发生改变</p></li></ul><p><img src="https://i.loli.net/2020/10/25/qfHuhsSwnGMLY4F.png" alt="image-20201025143320753"></p><p><img src="https://i.loli.net/2020/10/25/VXEMplcQaYkmHBy.png" alt="image-20201025143355998"></p><p>仅仅是对原来的方法前面都加了 <code> synchronized</code> 关键字来对原对象做了增强</p><p><img src="https://i.loli.net/2020/10/25/MFXhDSzmRg3lAoT.png" alt="image-20201025143507646"></p><p>而 List 本身仍有更多的子类。Collections 工具类提供的就是对 List 对象做增强。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>当我们明白了一件事物的本质之后，再去看表象会变的轻而易举。而这最关键的是要去亲自的操作它，看着再简单不过的东西，你第一次动手都会有很大的收获。这也让我想起了初中物理课本最常见的一句话</p><p><img src="https://i.loli.net/2020/10/25/TI5ECVzNZQgqi6A.jpg" alt="img"></p><p>任何情况下，看会和听懂都不是掌握。再不济语文课也学过“书读百遍其义自见”也是要动动嘴的🗣。加油！</p>]]></content>
    
    
    <summary type="html">“玩了把坦克大战居然彻底搞懂了装饰者模式。💥”</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>《1024，程序人生，这个属于我们的特殊日子》</title>
    <link href="http://lvgo.org/post/example.html"/>
    <id>http://lvgo.org/post/example.html</id>
    <published>2020-10-24T07:19:53.000Z</published>
    <updated>2020-10-24T07:19:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我第一次知道 1024 这个特殊的日子应该是在2年前（我总是一个后知后觉的家伙），而且还要感谢 <strong>CSDN</strong> 让我“提前”知道了特殊的日子<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那是在浏览博文的时候看到了 1024 的徽章。<br><img src="https://img-blog.csdnimg.cn/img_convert/36dc6a962df45e8c0b04c6065ce9d871.png#pic_center" alt="在这里插入图片描述"><center>这是现在的，可能当时不长这样毕竟 CSDN 这几年的 UI 变化还是挺多的</center></p><h1 id="如何与编程结缘"><a href="#如何与编程结缘" class="headerlink" title="如何与编程结缘"></a>如何与编程结缘</h1><blockquote><p>上学的时候我可不是个“好学生”，每天玩的忘了时间，现在想想可真后悔。</p></blockquote><h3 id="上课的时候第一次写代码"><a href="#上课的时候第一次写代码" class="headerlink" title="上课的时候第一次写代码"></a><center>上课的时候第一次写代码</center></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 记得那是第一次上机课，老师还是在黑板上写下了一段汇编代码，叫我们自己照着写然后运行观察有没有 <code>error</code> 字样出现，果不其然，我照着写报错了。但当时不以为然，和同学哈哈大笑“这啥玩应啊”。那是第一次写代码。</p><hr><h3 id="临毕业开始校招找工作"><a href="#临毕业开始校招找工作" class="headerlink" title="临毕业开始校招找工作"></a><center>临毕业开始校招找工作</center></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 时光总是短暂的，很快大学快毕业了，自己开始为大学这几年欠下的“<strong>债</strong>”开始担心，没有优秀的成绩，老师传授的硬件编程也没有学到手，可以说只是一个<code>到了考试自习室通宵</code>过完了“<code>枯燥</code>”的三年。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 记得那是大四下学期，九月份的校招，室友们都去参加校招，而我还在寝室打游戏。是的，还在打游戏，指挥着那个打了 4 年的副本—— 血战天策。我现在回想起来都不知道自己当时到底要干什么，家里也没矿啊？也没看到我爸和谁谈过石油的生意啊。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  室友回来了，“今天咋样？”，“没玄晶，你呢？”，“不怎么样，你明天也去看看吧，工作不太好找啊。”这是我大学四年最要好的一个玩伴，然而他背着我可是学了不少东西！我跟他玩游戏，我真玩，他是假玩啊，我清晰的记得跟他 lol 在读条进游戏的时候他可是在看书！！渣男！“嗯，明天去看看”。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  “上啊”， “人太多了，等等吧”，“那我先去了”。大概10分钟他出来之后问他如何，“英语自我介绍，感觉没戏”，“走吧”，“你不试试啊”。“我这英语咋试啊”，“试试呗，万一呢”。我硬着头皮进去了，结果中午吃饭他们要休息了，老天不让我去啊。突然被叫住，“过来吧，我等会去吃。”，可能是因为吃饭比较急，大概聊了10多分钟？我不记得时间了，结果是通过了，<code>‘测试工程师’</code>明天到xxx签三方协议。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  我做梦也没想到我能这么顺利找到工作，想着我都能过，那室友肯定不能差，结果他没有通过，我当时就不想去了。我说不能跟你在一起，没意思，不去。他劝我先别急，跟家里商量商量，然后再看看其他机会。</p><hr><h3 id="阴差阳错的培训"><a href="#阴差阳错的培训" class="headerlink" title="阴差阳错的培训"></a><center>阴差阳错的培训</center></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  我赶紧把这个做测试“<code>工程师</code>”“<code>喜讯</code>”告诉了家里，本以为会高兴，结果因为地方太远，家里都不同意。我这个人倔强的很，跟爸妈拧了很久，没定妥，后来有一天我爸给我打电话说他找到一个地方，让我去看看，从此，那里成了我程序人生的起点—— 达内，对于达内我不想评价太多。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  当我打开 eclipse 写下代码，看到控制台输出 Hello World 的时候，我便从此爱上了编程。因为签了三方协议，然后现在在培训，没办法实习，毁约给他们转了2000块钱，取消了原本的实习计划。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  四个月在那里当了四个月的技术班长，周末自习给大家讲过数不清次数的课，帮同学解决了多少问题也记不清，班级活动做了一个抽奖的程序，总之，那里的每一天都让我对编程的喜爱越来越深。</p><h1 id="程序人生"><a href="#程序人生" class="headerlink" title="程序人生"></a>程序人生</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  当我第一次坐在办公室开发第一个需求的时候，我没有担心哪个需求可不可以实现，从一开始我最担心的事情是<strong>我开发的功能会不会有人使用</strong>。我不知道有多少伙伴会有和我一样的想法，对待自己成程序，从开始设计它到实现它，我都在为它“将来”考虑。事实证明是没有，我写的功能很多情况下是无人使用。所以从那个时候我就励志！我做的功能一定要有人用！。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  在老家做了1年多，当个小组长，领了3个人一起开发，但我开始不安，因为我听到了很多我没听过东西，而我所接触到的却没人提及，强烈的危机感每天都在提醒着我自己。最终还是选择了背井离乡，我将地图折了一下，将老家的点对应的地方定为了目的地，是的，我现在跨了半个中国在异乡。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  到了外面的难，异乡人懂异乡人。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  没想到来到大都市之后，我便经历了公司倒闭、老板跑路，我欠了一屁股债第一年回家借钱回去的。我恨自己，恨自己没有好好学习，没有好的技术能力跑出来，但从没想过放弃。因为我所热爱的程序人生它一定就在这里。在出来的第一份工作，在那个倒闭的公司中，度过了我职业生涯的第二年的后半年，没错，我荒废了这半年的经历，因为每天都在想着下顿饭怎么省钱，感谢强哥和马爸爸那段时间的大力支持，不然真不知道自己会不会被网贷逼死。每天喝着“鸡汤”过日子，留着泪吃饭的日子经历的人才会懂。那段时间凭着一丝丝希望，坚持接触了 netty、springboot、springcloud、dubbo、redis、mysql、ibatis、mybatis。是的，只是接触。我想很多人都应该知道空虚的学习有多难。我学的再多无处施展，我用不到。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  老板跑路之后，开始寻找我的第三份工作，我每次都相信好运会降临，可每次都是倒霉到家。以为自己找到了归宿，可没干半年，警察陪着我上班，那一年的关键词，P2P 暴雷、我老板、300 亿、又跑路。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  我再一次被迫离职。当时被没有太多的难过心情了，因为当你经历过绝望过后，这点痛算什么呢？</p><h1 id="为何坚持"><a href="#为何坚持" class="headerlink" title="为何坚持"></a>为何坚持</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  在我出来的那一年，也就是17年，我虽经历了难堪的一年多，但那个时候我想到的是自己出发时的立志“<strong>死都要死外面</strong>”，同时也是最凄惨的那一年</p><ul><li>认识了<code>傅政委</code>，当时傅哥叫我去大厂试试，害，那时能活下来就是我最开心的事了，但我很高兴认识他。</li><li>接触到了<code>CSDN</code>，那一年开始试着写博客，我也不知道这是什么东西，我也不会写，完全当笔记来用。</li><li>注册了<code>码云</code>，不然我一直都不知道还有“码云”，也就只知道“马云”。</li><li>知道了<code>马云</code>、知道了<code>阿里巴巴</code>。我可能是唯数不多做了<code>一年多将近两年</code>程序员才知道阿里的人吧。这也是为什么我是在两年前才知道<code>1024</code>的。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  我一直相信上学老师说的一句话，“只要你肯学，永远都不晚”。我把这句话当成真理。同时又送给自己“不要抱怨、坚持下去。”我写过幸存者偏差的文章，我没幸存下来，我说的所有的言论屁都不如，这就是我为什么坚持的原因。我要坚持下去，要证明自己。我不想输。当你幸存下来，放个屁都是香的。</p><h1 id="如何坚持"><a href="#如何坚持" class="headerlink" title="如何坚持"></a>如何坚持</h1><blockquote><p>追求我所向往的程序人生，为开源做贡献，为社区做贡献。</p></blockquote><p><strong>不要给我说 5 点起床，1 点钟睡觉，我试过，天天累得跟狗一样，学习效率低，工作效率差，等死？我想做一个正常人，一个稍微有点理想，有点动作的正常人，偶尔拼一拼命而已。</strong></p><hr><h4 id="1-拿别人来刺激自己"><a href="#1-拿别人来刺激自己" class="headerlink" title="1. 拿别人来刺激自己"></a>1. 拿别人来刺激自己</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  拿别人来刺激自己。每次我看到优秀的大佬在学习的时候就是我最有劲的时候，我想着的是，当他松懈的时候，我便能超过他！这一招屡试不爽，找个你喜欢的人，关注他！</p><hr><h4 id="2-尝试动手做一点东西"><a href="#2-尝试动手做一点东西" class="headerlink" title="2. 尝试动手做一点东西"></a>2. 尝试动手做一点东西</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  看看自己口口声声说着热爱的编程，你用它做过什么？它为你带来了什么？emm… 我现在做了一堆稀里糊涂的东西，爬虫、并发任务执行工具、浏览器插件、博客模版？总之乱七八糟，但一直在尝试动手</p><hr><h4 id="3-专注，成为“T”型人才"><a href="#3-专注，成为“T”型人才" class="headerlink" title="3. 专注，成为“T”型人才"></a>3. 专注，成为“T”型人才</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  我以前一直都在东看看，西望望，这也学那也学，结果都知道个皮毛，深一点啥都不会。现在专注 Java 技术，并发网络编程方面，偶尔研究研究大数据，感觉方向也清楚了，学的是什么也明白了，最主要的，迷茫的时候少了。坚持努力让自己成为“幸存的人”。然后狠狠的“装一次逼！”。</p><hr><h4 id="4-为了一次完美的装逼。（意会）"><a href="#4-为了一次完美的装逼。（意会）" class="headerlink" title="4. 为了一次完美的装逼。（意会）"></a>4. 为了一次完美的装逼。（意会）</h4><hr><h1 id="1024"><a href="#1024" class="headerlink" title="1024"></a><center>1024</h1><div align='center'><p>1024，程序人生，这个属于我们的特殊日子。感触良多。</p><p>我因热爱而在这里。因热爱而坚持。</p><p>仍在路上坚持，希望同你一样，一起坚持！为了梦想、学习技术，不要抱怨，坚持下去。</p></div>]]></content>
    
    
    <summary type="html">我不是一个合格的程序员</summary>
    
    
    
    <category term="程序人生" scheme="http://lvgo.org/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
    <category term="程序人生" scheme="http://lvgo.org/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>和 lvgo 一起学设计模式（六）结构型之代理模式</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-proxy.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-proxy.html</id>
    <published>2020-10-22T11:31:38.000Z</published>
    <updated>2020-10-22T11:31:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/10/22/5l9eIS7tXdofFAE.png" alt="代理模式"></p><h1 id="设计模式的学习问题⁉❔"><a href="#设计模式的学习问题⁉❔" class="headerlink" title="设计模式的学习问题⁉❔"></a>设计模式的学习问题⁉❔</h1><p>我一直都在想如何学会一个新东西，和掌握一个旧东西🤔，有很多前辈给过一些建议和意见📑，（当然不是直接给我，都是看大佬的文章或者书籍当中。）先去用，再去学。嗯，我想是的，这样肯定是个很正常的学习过程。但是对于一些你暂时无法使用的东西，你如何去掌握它呢？我认为应该抛开表象去了解本质，通过本质的类比去掌握那些暂时无法使用的东西。设计模式就是这种情况，在平常的开发中，常用的设计模式就那么几种，其它的那些没有机会去接触，干学，如何才能掌握呢？🗃</p><p>我从小就是一个好为人师的家伙🤓，然而自己学习却一直都不怎么样😢。人太实在，也不懂的包装，我只知道我学习这么差的能学会的东西，讲给别人应该差不哪去。😊</p><p>在学习算法的时候，学到一个特别巧妙而且很好用的解题思路或者说逻辑思维<code>”分而治之“</code>，还有之前和网友讨论的一个叫做<code>”复杂度守恒定律“</code>的东西。这两个东西放在一起，可以说是很”矛盾“⚔🛡了。</p><p>说了这么多我想说的就是，设计模式这个知识点，真的很简单又很难。简单是因为每种设计模式的定义拿出来都能看的懂，难是难在如何，何时的应用。而我希望我写的这个设计模式系列是去应用化的，就是单纯的把设计模式的思想记录下来。我所理解的设计模式就该如此。</p><p>GOF的<strong>《设计模式.可复用面向对象软件的基础》</strong>通过一个应用案例的实现，串起了23种设计模式，我想在系列更新完之后也更新一个应用，将 23 种设计模式尽可能的应用到一个应用案例中去，而不是每个设计模式都涉及具体的应用，因为我觉得这可能会带的人们更关注应用的实现，而不是设计模式的应用，这是我的一些想法。</p><p><strong>不要纠结每种模式的具体实现，把它们抽象出来，你能够清楚的描述每种模式是为了解决什么问题而存在的时候，就已经掌握它了，就可以把它用在任何当你需要的时候。而不是问什么时候需要它，这可能有点绕，不过它是真的。不要问我设计模式可以解决哪些问题，把问题给我，我告诉你用什么设计模式可以解决它！</strong></p><p><em>我发现我更适合写一些畅谈型的文章🤣</em></p><h1 id="代理模式-👥"><a href="#代理模式-👥" class="headerlink" title="代理模式 👥"></a>代理模式 👥</h1><blockquote><p>为某对象提供一种代理以控制对该<strong>对象的访问</strong>。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</p></blockquote><p>代理模式是为了解决<strong>对象的访问控制</strong>，特别是当你的目标对象不可改变的时候。效果更佳明显。</p><p>先来几段对话，简单感受一下这个“代理”</p><ul><li>“这 google 好慢啊，搞个代理”</li><li>“您好，请问明年3月-12月有档期吗？” ”和我经纪人联系“</li><li>“我要告你” “好啊，有什么问题跟我的律师说吧”</li><li>“哦？是海大富海公公” “这是皇上口谕” “啊？（急忙下跪）“</li><li>“您好，这里是 12345 市长热线”</li></ul><p><strong>“控制一个实际的对象访问，同时可以达到一定的目的”</strong></p><h2 id="生活中的比喻"><a href="#生活中的比喻" class="headerlink" title="生活中的比喻"></a>生活中的比喻</h2><p>希望可以用生活中的一些例子能让我更好的去表达和梳理代理模式</p><h3 id="明星-amp-经纪人"><a href="#明星-amp-经纪人" class="headerlink" title="明星&amp;经纪人"></a>明星&amp;经纪人</h3><p>比如经纪人，他代理了明星（主体），负责主体功能以外的事情，主体可以进行商演，但在商演以前或以后的事情，都不需要主体去关系，全部都由经纪人去处理。</p><h3 id="公园门-amp-门禁"><a href="#公园门-amp-门禁" class="headerlink" title="公园门&amp;门禁"></a>公园门&amp;门禁</h3><p>一个公园的门禁，通过门禁系统，代理了公园的入口，公园入口只负责放人进入公园，不关心什么时候什么情况，来人就表示可以进入。门禁系统则负责什么时候，什么情况可以进。</p><p>通过使用代理模式，可以让我们的业务代码结构更加完整清晰，而将一些控制和辅助型的逻辑处理交给代理类，这其中体现的就是单一职责原则与迪米特法则。</p><p>上面的两个例子，我所想要表达的意思就是说明代理模式是为了<strong>控制一个实际对象的访问</strong>而存在的一种模式。不知道我说清了没有。</p><h2 id="程序中的例子"><a href="#程序中的例子" class="headerlink" title="程序中的例子"></a>程序中的例子</h2><h3 id="mybats-的数据访问接口"><a href="#mybats-的数据访问接口" class="headerlink" title="mybats 的数据访问接口"></a>mybats 的数据访问接口</h3><p>在代理模式中我们最常用到的应该就是 ORM 框架中的应用了，我们熟知的 mybatis 对<strong>数据库的访问控制</strong>就是使用了代理模式，通过一个接口的定义，来代理了数据库的访问操作。</p><p>在 mybatis 的代理模式处理思想如果翻译成白话：”你将你要执行的 SQL 告诉我在哪（mapper 映射，statement space），语句写好（xml）剩下的你都不用管“，这里的 mapper 接口即代理了数据库的访问工作。</p><p><strong>甚至 #{} ${} 占位符，也是一种代理模式的体现，不一定非要有完整的接口，具体的实现类，代理类才是代理模式。</strong>可能这理解起来会让你觉得有点强词夺理。</p><h2 id="代理模式类图-📌"><a href="#代理模式类图-📌" class="headerlink" title="代理模式类图 📌"></a>代理模式类图 📌</h2><p><img src="https://i.loli.net/2020/10/22/ziGBmy81YFw7kts.png" alt="prxy-UML"></p><h2 id="代码-📄"><a href="#代码-📄" class="headerlink" title="代码 📄"></a>代码 📄</h2><blockquote><p>完整代码获取关注公众号：星尘的一个朋友 回复 “源码”</p></blockquote><p>为了在深入的理解一下代理模式，我选择使用 mybatis 的代理模式实现原理伪代码。以及挖掘一下JDK动态代理的一些细节内容，当然我不会去写源码的东西（毕竟道理大家都懂，不可能凭空 new 出来一个接口的实例，这当中定有蹊跷，我相信你在任何一篇博文中都能看到这部分内容，当然也欢迎加我微信（lvgocc）进群讨论）</p><p><strong>mybatis的核心代理模式伪代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户接口</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/10/21 22:51</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 用户id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">selectByUserId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">UserMapper o = (UserMapper) Proxy.newProxyInstance(<br>        UserMapper.class.getClassLoader(),<br>        <span class="hljs-keyword">new</span> Class[]&#123;UserMapper.class&#125;,<br>        (proxy, method, arg) -&gt; &#123;<br>            <span class="hljs-comment">// 这里会执行具体的连接数据库执行 SQL 的操作 感兴趣可以查看 mybatis 源码继续了解。</span><br>            <br>            <span class="hljs-comment">// 打印参数</span><br>             logger.info(<span class="hljs-string">&quot;statement position: &#123;&#125;, args: &#123;&#125;&quot;</span>, method.getDeclaringClass().getCanonicalName() + <span class="hljs-string">&quot;#&quot;</span> + method.getName(), Arrays.toString(arg));<br>             <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;用户id：&quot;</span> + arg[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;公众号：星尘的一个朋友，加群一起学习设计模式&quot;</span>;<br>        &#125;);<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs reStructuredText">14:25:43.966 [main] INFO io.github.lvgocc.App - Hello World!<br>14:25:44.251 [main] INFO io.github.lvgocc.App - statement position: io.github.lvgocc.proxy.UserMapper#selectByUserId, args: [2333]<br>14:25:44.258 [main] INFO io.github.lvgocc.App - 查询结果：用户id：2333公众号：星尘的一个朋友，加群一起学习设计模式<br></code></pre></td></tr></table></figure><p>mybatis 使用动态代理，让一个接口去代理了真实的数据库对象，当你需要的时候，再去建立连接、访问数据库、执行SQL、返回结果。如果之前有了解过 mybatis 的代理模式，这里应该不难理解。</p><p><strong>下面再看一个简单的例子，当然用图说明可能会更容易</strong></p><p><img src="https://i.loli.net/2020/10/22/MpN1wxuCjrBH96t.png" alt="大洋彼岸的服务器"></p><blockquote><p>请忽略图中示意具体内容，只是借图表达代理的意义，控制对象的访问。</p></blockquote><h2 id="总结一下-🐱‍💻"><a href="#总结一下-🐱‍💻" class="headerlink" title="总结一下 🐱‍💻"></a>总结一下 🐱‍💻</h2><p>代理模式为了解决对象的访问控制而存在。</p><ul><li>当你想要抢一张<code>回家的车票</code>，你选择了<code>候补</code>，他选择了<code>加速</code>.此时 12306 或是 第三方 成了你的购票代理人。</li><li>当你来到一个<code>陌生的小区</code>，需要刷<code>门禁</code>卡才能进入。此时<code>门禁</code>成了<code>小区</code>的代理。</li></ul><p>通过上面的总结，我知道</p><ol><li>当我选择了候补，我和购票<strong>解耦了</strong>✔，不需要等它的结果，等通知就行。但中间多了一个候补，<strong>链路更长</strong>❌了。</li><li>我进门要刷卡，<strong>维护的对象多了</strong>❌，虽然<strong>系统变得复杂</strong>❌了，但小区<strong>更安全</strong>✔了，保护了小区。</li></ol>]]></content>
    
    
    <summary type="html">　　“有什么问题跟我律师说吧。”</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>和 lvgo 一起学设计模式（五）创建型之建造者模式</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-build.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-build.html</id>
    <published>2020-10-17T17:13:22.000Z</published>
    <updated>2020-10-17T17:13:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/10/17/8NsSJTuzyraGeOV.png" alt="build"></p><h1 id="建造者模式-🔨"><a href="#建造者模式-🔨" class="headerlink" title="建造者模式 🔨"></a>建造者模式 🔨</h1><blockquote><p>指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示</p></blockquote><p>根据建造者模式的定义，我们可以先简单的了解一下建造者模式要解决的问题，它是指将一个复杂对象的构建与它的表示分离，这句话的意思是指一个对象的构建过程与表示不再绝对。即一个构建过程对应多个结果，这取决于客户端如果指挥构建者进行对象的构建。这里的构建者就是我们接下来要讲的建造者模式内容。</p><h2 id="理解程序中的建造-🗯"><a href="#理解程序中的建造-🗯" class="headerlink" title="理解程序中的建造 🗯"></a>理解程序中的建造 🗯</h2><p>对于建造这个词语没什么好说的，在软件程序中建造是什么呢？我相信看到下面这个例子你应该就已经掌握了什么是建造者模式，当然这还不够，让我们慢慢来。</p><h3 id="JDK-中的-StringBuilder"><a href="#JDK-中的-StringBuilder" class="headerlink" title="JDK 中的 StringBuilder"></a>JDK 中的 StringBuilder</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringBuilderTest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>        stringBuilder.append(<span class="hljs-number">1</span>).append(<span class="hljs-string">&quot;个张三，和&quot;</span>).append(<span class="hljs-number">4</span>).append(<span class="hljs-string">&quot;个李四&quot;</span>);<br>        System.out.println(stringBuilder.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">1个张三，和4个李四<br>Process finished with exit code 0<br></code></pre></td></tr></table></figure><p>上面的例子是妇孺皆知的 JDK 中提供的一个为了解决复杂 String 对象的 String 对象生成器。它还有个孪生姐夫<code>StringBuffer</code>用在并发环境下。</p><h3 id="Netty-中的-ServerBootstrap"><a href="#Netty-中的-ServerBootstrap" class="headerlink" title="Netty 中的 ServerBootstrap"></a>Netty 中的 ServerBootstrap</h3><p>再比如这个，netty 的启动器</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>bootstrap.group(parentGroup, childGroup)<br>        .channel(NioServerSocketChannel.class)<br>        .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>        .childHandler(<span class="hljs-keyword">new</span> NettyProtobufChannelInitializer());<br><br><span class="hljs-keyword">try</span> &#123;<br>    ChannelFuture sync = bootstrap.bind(<span class="hljs-number">2333</span>).sync();<br>    sync.channel().closeFuture().sync();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>通过建造者 <code>ServerBootstrap</code> 来完成一个启动器的构建，同一个构造过程，却有着千差万别的结果。</p><h3 id="lvgo-的-Slient-并发任务处理器"><a href="#lvgo-的-Slient-并发任务处理器" class="headerlink" title="lvgo 的 Slient 并发任务处理器"></a>lvgo 的 Slient 并发任务处理器</h3><p>如果建造者被我们自己应用的话，我个人将它使用到了程序插拔配置上了，就像 netty 的启动器一样。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> TaskHandler&lt;String&gt;(testData) &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000L</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        log.info(<span class="hljs-string">&quot;第&quot;</span> + s + <span class="hljs-string">&quot;个任务&quot;</span> + Thread.currentThread());<br>    &#125;<br>&#125;.sync(<span class="hljs-keyword">false</span>).overRun(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;我所有的任务执行结束了&quot;</span>);<br>&#125;).execute(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>上面我写的这个组件已发布到 maven 仓库，源码仓库：<a href="https://github.com/lvgocc/silent">https://github.com/lvgocc/silent</a></p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.lvgo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>silent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过上面的几个例子我们大概知道什么是建造者模式了，它可以通过同一个构造过程来创建出不同的表示对象，比如</p><ul><li>StringBuilder 通过不同的参数传入 append 方法，得到结果是不一样的；</li><li>ServerBootstrap 的不同参数设置，启动出来的 netty 服务端有着不同作用；</li><li>TaskHandler 通过指定不同的参数，可以使任务的执行效果产生不同的变化；</li></ul><h2 id="建造者模式类图-📌"><a href="#建造者模式类图-📌" class="headerlink" title="建造者模式类图 📌"></a>建造者模式类图 📌</h2><blockquote><p>注：在 GOF 的原著中对建造模式的理解与本篇差别较大。所以类图看起来会和很多资料中有所差异，望读者知悉。</p></blockquote><p><img src="https://i.loli.net/2020/10/17/Aqzo6p4f1FPlasD.png" alt="build-UML"></p><p>GOF 中定义的建造者类图</p><p><img src="https://i.loli.net/2020/10/17/jVEaygYQd7rOscR.png" alt="gof-build-UML"></p><p>这里说明一下，GOF 的建造者模式中体现的是将要构建的对象、构建者、具体构建者、指挥者4部分独立开来，可以做很好的水平扩展。而 lvgo 将建造者的抽象类与具体的构建者合成一个，通过参数的方式将具体的构建者体现出来。将指挥者的角色延迟到了客户端，直接由客户端 client 来代替 Director 的工作。</p><h2 id="代码-📄"><a href="#代码-📄" class="headerlink" title="代码 📄"></a>代码 📄</h2><blockquote><p>避免篇幅过长，完整代码及单元测试结果点击查看 <a href="https://github.com/lvgocc/java-design-patterns/tree/main/build">https://github.com/lvgocc/java-design-patterns/tree/main/build</a></p></blockquote><p>为了能够更好的去理解 lvgo 与 GOF 中类图的差异，这里准备了两种写法，以诠释上面的说明。</p><p><strong>GOF 类图的实现</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> PlayerRole playerRole = <span class="hljs-keyword">new</span> PlayerRole();<br><br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHairColor</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setShape</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSkinColour</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">PlayerRole <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> playerRole;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Director</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Builder builder;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Director</span><span class="hljs-params">(Builder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.builder = builder;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PlayerRole <span class="hljs-title">construct</span><span class="hljs-params">()</span> </span>&#123;<br>        builder.setHairColor();<br>        builder.setShape();<br>        builder.setSkinColour();<br>        <span class="hljs-keyword">return</span> builder.build();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PlayerRole <span class="hljs-title">construct2</span><span class="hljs-params">()</span> </span>&#123;<br>        builder.setHairColor();<br>        <span class="hljs-keyword">return</span> builder.build();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PlayerRole <span class="hljs-title">construct3</span><span class="hljs-params">()</span> </span>&#123;<br>        builder.setSkinColour();<br>        <span class="hljs-keyword">return</span> builder.build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlayerRoleBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Builder</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setHairColor</span><span class="hljs-params">()</span> </span>&#123;<br>        playerRole.setHairColor(<span class="hljs-string">&quot;褐色&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setShape</span><span class="hljs-params">()</span> </span>&#123;<br>        playerRole.setShape(<span class="hljs-string">&quot;健硕&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setSkinColour</span><span class="hljs-params">()</span> </span>&#123;<br>        playerRole.setSkinColour(<span class="hljs-string">&quot;古铜色&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlayerRole</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String hairColor;<br>    <span class="hljs-keyword">private</span> String shape;<br>    <span class="hljs-keyword">private</span> String skinColour;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>    Builder playerRoleBuilder = <span class="hljs-keyword">new</span> PlayerRoleBuilder();<br>    Director playerRoleBuildDirector = <span class="hljs-keyword">new</span> Director(playerRoleBuilder);<br>    PlayerRole construct = playerRoleBuildDirector.construct();<br>&#125;<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">construct = PlayerRole&#123;hairColor=<span class="hljs-string">&#x27;褐色&#x27;</span>, shape=<span class="hljs-string">&#x27;健硕&#x27;</span>, skinColour=<span class="hljs-string">&#x27;古铜色&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>个人觉得这种写法稍为复杂，不过他的水平扩展性和隔离性都比较好。</p><p><strong>lvgo 整理的写法如下</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlayerRole</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String hairColor;<br>    <span class="hljs-keyword">private</span> String shape;<br>    <span class="hljs-keyword">private</span> String skinColour;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlayerRoleBuilder</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PlayerRole playerRole = <span class="hljs-keyword">new</span> PlayerRole();<br><br>    <span class="hljs-function">PlayerRoleBuilder <span class="hljs-title">hairColor</span><span class="hljs-params">(String color)</span> </span>&#123;<br>        playerRole.setHairColor(color);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function">PlayerRoleBuilder <span class="hljs-title">shape</span><span class="hljs-params">(String shape)</span> </span>&#123;<br>        playerRole.setShape(shape);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function">PlayerRoleBuilder <span class="hljs-title">skinColour</span><span class="hljs-params">(String skinColour)</span> </span>&#123;<br>        playerRole.setSkinColour(skinColour);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function">PlayerRole <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> playerRole;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    PlayerRoleBuilder playerRoleBuilder = <span class="hljs-keyword">new</span> PlayerRoleBuilder();<br>    playerRoleBuilder.hairColor(<span class="hljs-string">&quot;红色&quot;</span>).shape(<span class="hljs-string">&quot;健硕&quot;</span>).skinColour(<span class="hljs-string">&quot;古铜色&quot;</span>);<br>    PlayerRole build = playerRoleBuilder.build();<br>    System.out.println(<span class="hljs-string">&quot;build = &quot;</span> + build);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">build = PlayerRole&#123;hairColor=<span class="hljs-string">&#x27;红色&#x27;</span>, shape=<span class="hljs-string">&#x27;健硕&#x27;</span>, skinColour=<span class="hljs-string">&#x27;古铜色&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结-🐱‍💻"><a href="#总结-🐱‍💻" class="headerlink" title="总结 🐱‍💻"></a>总结 🐱‍💻</h2><p><strong>相同的资源，不同的结果</strong>是我对建造者模式创建对象的理解。就像建造我们的人生，提供了相同的世界，相同的空气，每个个体的表现均不同。</p><p>通过使用建造者模式，我们可以更加灵活的去处理一个构建过程复杂的对象。将它的构建过程与表示分离开。例如如果你正在为<strong>一长串的 set 方法</strong>苦恼的时候可以考虑一下建造者模式。它使代码更整洁，可读性更好。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">xxx.setA();<br>xxx.setB();<br>xxx.setC();<br>xxx.setD();<br>xxx.setE();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">xxx.A().B().C().D().E().build();<br></code></pre></td></tr></table></figure><p>当你想要给一个对象组装一个特有的结果的时候，不妨试试 GOF 的思路，很不错的。</p><p><strong>缺点：</strong></p><p>建造者模式因为需要维护一个单独的建造者类，同时要为每个属性单独维护一个方法，当类中有属性调整的时候，要一起调整对应建造者中的方法，这也是随它的优势而带来的一些副作用。<strong>但如果有需要它的地方尽管去用。没有什么比混沌的代码更糟糕的事情了。</strong></p><h2 id="案例应用"><a href="#案例应用" class="headerlink" title="案例应用"></a>案例应用</h2><p>这里为了应读者要求，想有对应的案例可以参考，不然不清楚设计模式到底在什么地方用。</p><ol><li>餐饮系统有23道素材、18道荤菜，老板今天推出 8 种 2素 1 荤套餐，你如何实现？</li><li>试想一下在我的世界（mc）中，提供了各种不同的道具，相同的道具组合，你做出来的房子和我做出来的房子看起来不那么一样。</li><li>在塔防类游戏中，同一个射手，每次攒钱给他升级，最终有的变成了单体攻击高的神射手，有的变成散射群里攻击低的散箭手。</li></ol><h2 id="返璞归真"><a href="#返璞归真" class="headerlink" title="返璞归真"></a>返璞归真</h2><p>我认为学习设计模式的过程就像拿到一台游戏机，玩到最后，我都会拆开看看里面是什么，而早已不关心游戏好不好玩了。</p><p>知识也是一样，知其然而知其所以然。</p><p><strong>我们为了学会使用某种东西看他的操作手册就可以了；</strong></p><p><strong>我们如果想要学会修某种东西就需要看他的设计手册；</strong></p><p><strong>当我们想要创造某种东西，你就需要掌握很多很多设计手册，将他们的经验进行吸收、消化、提炼。才能有更好的结果。</strong></p><p><em>当然，如果你只想会用，有一份差不多的操作指南也就够了。</em></p><p>抱歉这一篇说了一些题外话。</p>]]></content>
    
    
    <summary type="html">　　“相同的资源，不同的结果是我对建造者模式创建对象的理解。就像建造我们的人生，提供了相同的世界，相同的空气，每个个体的表现均不同。”</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
