<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Star Dust 星尘</title>
  
  <subtitle>亦或繁星、亦或尘埃。不要抱怨，坚持下去</subtitle>
  <link href="http://lvgo.org/atom.xml" rel="self"/>
  
  <link href="http://lvgo.org/"/>
  <updated>2021-04-13T09:29:36.000Z</updated>
  <id>http://lvgo.org/</id>
  
  <author>
    <name>lvgo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>写一些友好的代码（下），对虚拟机友好</title>
    <link href="http://lvgo.org/post/code-for-machine.html"/>
    <id>http://lvgo.org/post/code-for-machine.html</id>
    <published>2021-04-13T09:29:36.000Z</published>
    <updated>2021-04-13T09:29:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写一些友好的代码（下），对虚拟机友好"><a href="#写一些友好的代码（下），对虚拟机友好" class="headerlink" title="写一些友好的代码（下），对虚拟机友好"></a>写一些友好的代码（下），对虚拟机友好</h2><blockquote><p>关于编码，我想这应该是程序员最熟悉不过的事儿了。也是作为一个程序员最基本的职能了，而恰恰是最常做的事，最容易产生自信。而这种自信，有时便会成为理所应当的坏习惯。</p></blockquote><p>之前听郑雨迪（Oracle 高级研究员）说他的工作就是怎么让程序员写的代码在虚拟机上跑的更快，听起来很伟大，但细想想，作为程序员的我们。是不是也可以贡献一点力量呢？</p><p>上一篇我整理了一些对人友好的代码内容，简单来说就是不要写一些让人看不懂，或者看着不舒服的代码。</p><p>这一篇我想要分享的内容，就是让我们通过学习虚拟机的一些执行过程来优化我们的代码，为虚拟机分担一些压力。也想借此文章谈谈自己理解的 Java 程序员为什么要去学习虚拟机。</p><p>听过很多朋友说过，我做开发根本都碰不到虚拟机，学这有啥用？还有很多朋友自己在被问到，或者自己正在学习虚拟机时也会觉得“你问我这东西是啥意思？故意难我？我学玩虚拟机能干啥？到底学这东西有啥用？”。这些疑问让我来回答的话，那就是今天的题目了。为了写出对机器友好的代码。</p><h3 id="无奈的虚拟机"><a href="#无奈的虚拟机" class="headerlink" title="无奈的虚拟机"></a>无奈的虚拟机</h3><p>随着时代的发展，我发现越来越明显的一件事，就是更多人，不喜欢 ”浪费时间“。这里的浪费时间想要说的意思是，懒。</p><p>当你注册一个应用程序的账号时候，如果他的流程过于繁琐。那么他可能就因此失去你这个用户。又或者一个游戏如果他的玩法过于复杂，那自然也没什么人会选择继续玩下去。但假如，这个应用是你必须要注册的，而且没有其他的备选应用去选择，那么即使他注册需要再多的流程，在怎么繁琐，你也是要硬着头皮去做，而且边做边觉得让你”恶心“。</p><p>就像我们的 JAVA 虚拟机，即使你的代码写的在怎么糟糕，只要语法没有问题，虚拟机都要去完成代码的执行。但你有没有想过，你写的代码，可能也是虚拟机没有选择余地的那种，他没办法不执行，所以它也边做边觉得“恶心”呢？</p><h3 id="程序编译和代码优化"><a href="#程序编译和代码优化" class="headerlink" title="程序编译和代码优化"></a>程序编译和代码优化</h3><blockquote><p>如果不想让虚拟机“恶心”，我们一起看看虚拟机是怎么处理我们写下的代码吧，从中理解一些对虚拟机友好的代码吧。</p></blockquote><h4 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h4><p>Java 程序编译有两个意思，一个是将源码编译成 class 格式，一个是将 class 格式文件内容编译成可以被机器可直接执行的本地机器码格式。</p><p>在这个过程共分为三类编译器</p><ul><li><p>前端编译器：jdk 的 javac、eclipse 的 JDT</p></li><li><p>即时（JIT）编译器：hotspot 的 c1 c2 graal</p></li><li><p>提前（AOT）编译器：jdk 的 jaotc GNU Compiler for the Java（GCJ）、Excelsior JET。</p></li></ul><h5 id="前端编译-（Javac-编译）"><a href="#前端编译-（Javac-编译）" class="headerlink" title="前端编译 （Javac 编译）"></a>前端编译 （Javac 编译）</h5><p>这里可以参考之前的文章《Java 类的一生》当中的 Javac 的孕育了解更多内容。下面说下前面文章没有提到的内容。</p><h6 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h6><p>可以帮助我们提高开发效率、程序严谨，没有实质的功能提升。</p><ol><li><p>泛型 使参数动态化</p></li><li><p>自动拆装箱、增强 for 循环、变长参数</p></li><li><p>条件编译优化</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String args[])</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">true</span>) &#123;<br>        System.out.println(<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>条件编译优化后</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String args[])</span> </span>&#123;<br>    System.out.println(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Java语言还有不少其他的语法糖，如内部类、枚举类、断言语句、数值字面量、对枚举和字符串的switch支持、try语句中定义和关闭资源、Lambda表达式（从JDK 8开始支持，Lambda不能算是单纯的语法糖，但在前端编译器中做了大量的转换工作）</p><h5 id="后端编译（JVM中的编译）"><a href="#后端编译（JVM中的编译）" class="headerlink" title="后端编译（JVM中的编译）"></a>后端编译（JVM中的编译）</h5><p><em>IR：程序语言的一种中间表示形式（Intermediate Representation）</em></p><p>后端编译包括</p><ul><li>即时编译技术 JIT</li><li>提前编译技术 AOT</li></ul><h6 id="即时编译"><a href="#即时编译" class="headerlink" title="即时编译"></a>即时编译</h6><p>带着下面问题来看后面的内容</p><ul><li>为何HotSpot虚拟机要使用解释器与即时编译器并存的架构？</li><li>为何HotSpot虚拟机要实现两个（或三个）不同的即时编译器？</li><li>程序何时使用解释器执行？何时使用编译器执行？</li><li>哪些程序代码会被编译为本地代码？如何编译本地代码？</li><li>如何从外部观察到即时编译器的编译过程和编译结果？</li></ul><p>在解释执行的过程中，当虚拟机发现某部分代码执行频繁，称为热点代码。虚拟机就会把这部分代码提前变成本地可以执行的机器码以提高执行效率。</p><h6 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h6><p><strong>解释执行</strong></p><p>当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行。</p><p><strong>编译执行</strong></p><p>当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率</p><p><strong>逆优化</strong></p><p>当程序执行过程中的类不断的变化，发生一些特殊情况（优化效果不如不优化）便会发生逆优化操作继续使用解释执行。</p><p><img src="https://img-blog.csdnimg.cn/20210413164156632.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM0MzQ0MTIz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>即时编译器分为客户端编译器 <code>C1</code> 和服务端编译器 <code>C2</code> 还有目前在 JDK 10 中处于实验阶段的 <code>Graal</code>编译器（为了替换 <code>C2</code>）</p><p>可以通过参数来强制虚拟机仅使用 <code>C1</code> 或 <code>C2</code> 执行</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">-client”或“-server<br></code></pre></td></tr></table></figure><p>解释器与编译器搭配使用的方式在虚拟机中被称为“混合模式”（MixedMode）.可以通过 <code>java -version</code> 命令查看</p><ul><li><p>使用参数<code>“-Xint”</code>强制虚拟机运行于<code>“解释模式”</code>（Interpreted Mode），这时候编译器完全不介入工作，全部代码都使用解释方式执行。</p></li><li><p>使用参数<code>“-Xcomp”</code>强制虚拟机运行于<code>“编译模式”</code>（CompiledMode），这时候将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/202104131642204.png#pic_center" alt="在这里插入图片描述"></p><p>使用参数切换执行方式</p><p><img src="https://img-blog.csdnimg.cn/20210413164229221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM0MzQ0MTIz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h5 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h5><p>hotspot 中包含多个即时编译器，C1（客户端编译器） C2（服务端编译器） Graal（JDK10引入的实验性质编译器，目标是替换 C2）</p><p>JDK 7 以前需要程序特性选择即时编译器</p><ul><li>执行时间短、需要快速启动的程序选择 <strong>编译速度快</strong>  的C1 编译器（参数 -client）</li><li>执行时间长、对峰值有要求的，选择 <strong>执行速度快</strong> 的 C2 编译器 （参数 -server）</li></ul><p><strong>0 层</strong></p><p>解释执行，不开启性能监控</p><p><strong>1 层</strong></p><p>执行C1 编译的代码，这部分代码是由 C1 快速编译成本地代码，进行一些基本的简单优化（如：方法内联、公共子表达式消除、冗余代码消除，包括冗余访问和冗余存储冗余赋值）</p><p><strong>2 层</strong></p><p>执行C1 编译的代码，这部分代码是带有方法执行次数和循环回边次数的 profiling （性能监控状态的数据）</p><p><strong>3 层</strong></p><p>执行 C1 编译的代码，这部分为带所有 profiling 的 C1 代码。</p><p><strong>4 层</strong></p><p>执行 C2 编译的代码，进行更加复杂的优化内容，同时可能会根据 profiling 做一些激进的优化。</p><p><strong>总结</strong></p><p>分层编译也可大致分为三层：</p><ul><li>0层：解释执行</li><li>1层：C1 编译执行 对应 1/2/3 层</li><li>2层0.：C2 编译执行 对应 4 层</li></ul><p>其中 1 层和 4 层为最终状态层，当一个方法进入到 C1 的 1 层编译优化后或到达了 C2 的 4 层编译优化后虚拟机在之后的执行中是不会再发出编译请求的了。</p><h4 id="编译的对象和条件"><a href="#编译的对象和条件" class="headerlink" title="编译的对象和条件"></a>编译的对象和条件</h4><p><strong>编译器编译的对象一般为方法级。</strong></p><p>常说“热点代码”会被虚拟机通过即时编译技术进行优化，那什么样的代码才算热点代码？</p><ul><li>被多次调用的方法</li><li>多次执行的循环体（具体有回边次数值）</li></ul><p><strong>辨别方法多次调用：</strong></p><ol><li>基于采样<ul><li>虚拟机会周期检测各个线程的栈顶，如果某个方法经常出现在栈顶，则视为热点代码<ul><li>特点：简单、高效</li><li>缺点：不准</li></ul></li></ul></li><li>基于计数器：hotspot 使用这种方式<ul><li>为每一个方法维护一个调用次数计数器<ul><li>特点：准确</li><li>缺点：复杂</li></ul></li></ul></li></ol><p><strong>识别循环体多次：</strong></p><p>根据循环的回边次数进行优化的技术又称为 <strong>OSR（On Stack Replacement）</strong> —— <strong>栈上替换</strong>，因为这部分代码是在执行过程中被优化的，在非方法入口处进行解释执行的代码和编译后的代码进行替换。这个触发条件是有参数 （<code>-XX:CompileThreshold</code>）控制的，计算公式如下</p><p><code>CompileThreshold * （OnStackReplacePercentage - InterpreterProfilePercentage）/ 100</code></p><p>参数 <code>-XX:InterpreterProfilePercentage</code>  默认值 33</p><p>C1 情况下 <code>OnStackReplacePercentage</code> 默认值 933</p><p>C2 情况下 OnStackReplacePercentage 默认值 140</p><p>所以在默认情况下， C1 的循环回边次数达到 13500 时会启用 <code>OSR</code> 技术进行即时编译优化代码， C2 则在 10700 时启用。</p><p><em>通常情况下，程序代码不会触发 OSR，在测试中常见</em></p><p><strong>循环回边次数触发的 OSR 技术优化的对象为 代码块。</strong></p><p><strong>方法调用次数的优化对象为 整个方法。</strong></p><h3 id="提前编译"><a href="#提前编译" class="headerlink" title="提前编译"></a>提前编译</h3><p>关于提前编译，我这里只是简单的理解一下。如果对这个感兴趣的话，需要继续找资料深入。我就简单说下我的理解在这里。</p><p>Java 程序在早期就拥有这项技术，就是提前把字节码文件编译成机器码。这样就可以加快执行速度。 但是 Java 又想拥有跨平台的小目标，所以也就不好推进。不过另一个弟兄，Android 做的很好，不过后来是因为提前编译时间太长（安装包安装时间），又不得不使用解释执行和即时编译技术。</p><h3 id="编译优化技术"><a href="#编译优化技术" class="headerlink" title="编译优化技术"></a>编译优化技术</h3><p>除了上面的两个“热点代码”优化，编译器是如何优化普通的字节码的？首先两个关键的技术 <strong>方法内联</strong> <strong>逃逸分析</strong></p><h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><p>将方法的调用，优化成调用者内部代码，省去入栈出栈操作。例如 set get 方法均会被方法内联所优化掉</p><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>分析一个对象的动态作用域，举例来说：</p><ul><li>一个对象当做参数传给了另外方法称为 <strong>方法逃逸</strong>。</li><li>对一个类变量进行了赋值称为 <strong>线程逃逸</strong>。</li></ul><p>通过这两种逃逸方式，可以进行相关优化操作，比如：</p><ul><li>一个对象如果没有发生 <strong>方法逃逸</strong> ，可以进行栈上分配或者 <strong>标量替换</strong>（hotspot 使用这种方式进行优化代码）</li><li>如果一个变量没有发生过 <strong>线程逃逸</strong> ，可以进行 <strong>同步（锁）消除</strong> 优化。</li></ul><p>通过逃逸分析，我们可以利用到一点，就是锁消除，即不加锁。而不用是去加了锁，然后等到真正执行时由虚拟机去优化。</p><h4 id="循环优化"><a href="#循环优化" class="headerlink" title="循环优化"></a>循环优化</h4><ol><li>循环无关代码外提：将循环过程中不变的代码外提至循环外，减少重复的冗余计算</li><li>循环展开：再循环过程中进行多次迭代，减少循环次数。特殊形式是完全展开；</li><li>循环判断外提：无关循环的判断移到循环外。</li><li>循环剥离：循环的前几次或后几次一般可以被优化掉，减少循环次数。</li></ol><h4 id="冗余代码消除"><a href="#冗余代码消除" class="headerlink" title="冗余代码消除"></a>冗余代码消除</h4><ol><li>公共子表达式消除（对相同的表达式只计算一次，后面的代码复用之前的结果）</li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = b * c + d * e + c * b;<br><span class="hljs-comment">// 优化后 b * c 等于 c * b;</span><br><span class="hljs-keyword">int</span> a = f + d * e + f;<br></code></pre></td></tr></table></figure><p>   关于这里，我们是不是可以直接写出 <code>int a = 2f + d * e</code> 的代码呢？让虚拟机也不那么“累”。</p><ol start="2"><li><p>冗余访问、存储消除</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = obj.getValue();<br><span class="hljs-comment">// 冗余访问</span><br><span class="hljs-keyword">int</span> b = obj.getValue();<br><span class="hljs-comment">// 消除后</span><br><span class="hljs-keyword">int</span> a = b;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = obj.getValue();<br><span class="hljs-comment">// 冗余存储</span><br><span class="hljs-keyword">int</span> b = a;<br>sum = a + b;<br><span class="hljs-comment">// 消除后</span><br>sum = a + a;<br></code></pre></td></tr></table></figure><p>还有一些其他的优化手段了解一下。</p></li><li><p>数组范围检查消除</p></li><li><p>空值检查消除</p></li><li><p>自动装箱消除</p></li></ol><hr><h3 id="学习虚拟机的思考"><a href="#学习虚拟机的思考" class="headerlink" title="学习虚拟机的思考"></a>学习虚拟机的思考</h3><p>关于虚拟机的学习东西很多，而且很枯燥。能坚持学完除了兴趣，还要有耐心。虽然自己只学习了一些虚拟机的皮毛，但再去写代码的时候，也会有很多帮助，比如你定义的常量值，在 javac 的时候就会被替换成具体的值。也是那为什么你替换了一个常量值文件导致这个值没生效的原因。比如在写代码的时候也能利用一些优化知识来写一些相对精致的代码。比如对自己写下的代码它将来会发生什么比较清楚等等。总之这些价值都不能够直接的体现出来，因为只有你自己才知道。</p><p>不要因为一时看不到结果而放弃一些追求，凡事坚持下去终会有结果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写一些友好的代码（下），对虚拟机友好&quot;&gt;&lt;a href=&quot;#写一些友好的代码（下），对虚拟机友好&quot; class=&quot;headerlink&quot; title=&quot;写一些友好的代码（下），对虚拟机友好&quot;&gt;&lt;/a&gt;写一些友好的代码（下），对虚拟机友好&lt;/h2&gt;&lt;blockquo</summary>
      
    
    
    
    <category term="虚拟机" scheme="http://lvgo.org/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="虚拟机" scheme="http://lvgo.org/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>写一些友好的代码（上），对人友好</title>
    <link href="http://lvgo.org/post/code-for-people.html"/>
    <id>http://lvgo.org/post/code-for-people.html</id>
    <published>2021-02-27T04:52:45.000Z</published>
    <updated>2021-02-27T04:52:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写一些友好的代码（上），对人友好"><a href="#写一些友好的代码（上），对人友好" class="headerlink" title="写一些友好的代码（上），对人友好"></a>写一些友好的代码（上），对人友好</h2><blockquote><p>这是一篇关于程序员的一个最基本条件的文章——编码。也是我学习虚拟机之后最大感触的一些内容。</p></blockquote><p><code>作者：小米(lvgocc)</code></p><p><code>公众号：星尘的一个朋友</code></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>正文之前，还是想强调一下今天关于编码的分享，要 <strong>区别 “好” 与 “友好”</strong>。毕竟还是有差距。就像好的论文、好的书籍，专业性很强，内容质量很高。但它并不一定是友好的，就像现在大多数人在写作都在追求 “通俗易懂”，这就是友好。他们这些人负责把难理解的内容消化掉然后换一种方式来表述出来，同时尽可能的不丢失原来的“本色”。这样的内容就是友好的，同时它也一定是好的。（这个一定，可以通过反证法得出）</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>今天分享的主题是 “对人友好的代码”。希望看过文章的朋友们，能够有所收获。</p><p>关于编码，我想这应该是程序员最熟悉不过的事儿了。也是作为一个程序员最基本的职能了，而恰恰是最常做的事，最容易产生自信。而这种自信，有时便会成为理所应当的坏习惯。</p><h3 id="对人友好"><a href="#对人友好" class="headerlink" title="对人友好"></a>对人友好</h3><p>对人友好的代码怎么理解?</p><p>在很多时候，比如公司内部代码走查、阅读开源代码，甚至看自己写过的代码。都会有一种冲动，什么冲动？重构的冲动！</p><p>我想，有这种想法的人肯定不止我一个。首先我很肯定，有这种想法的人，都是想要写出更加优秀的代码的人。但事实上呢？是不是很多时候是因为别人的代码不如你意呢？又或者只是单纯的觉得这样写就是不合适，原因不知道?。不管怎么说，我还是认为有这种想法的开发人员是很好的。</p><p><img src="https://i.loli.net/2021/02/27/SDxbAr1TV57vaJ3.png" alt="vant 演示中 dialog 的截图 | 写一些友好的代码 作者：小米 公众号：星尘的一个朋友"></p><h3 id="好的代码-友好的代码"><a href="#好的代码-友好的代码" class="headerlink" title="好的代码?友好的代码?"></a>好的代码?友好的代码?</h3><p>我要写一手好的代码！这个问题我也经常在敲代码的时候在想。可事实你想写出好的代码并没那么容易，既然<strong>我写不出来好的代码，那我能不能写出一些对人友好的代码？</strong> 我想这应该就是我能写出来好的代码的第一步吧。所以我从写出一些友好的代码下手了。</p><h3 id="我认为对人友好的代码"><a href="#我认为对人友好的代码" class="headerlink" title="我认为对人友好的代码"></a>我认为对人友好的代码</h3><p>对人友好的代码实在是太多了，我列一些自己随便想到的一些，算是抛砖引玉，希望能够和更多人产生友好的代码共鸣。</p><h4 id="首先一定要能读"><a href="#首先一定要能读" class="headerlink" title="首先一定要能读"></a>首先一定要能读</h4><p>最基本的对人友好，就是代码不要看起来很脏，给人一种不能够阅读的感觉。下面举个不可阅读的例子</p><p><img src="https://i.loli.net/2021/02/27/3ikxfuoFXqIEL7V.png" alt="不可阅读代码 | 写出一些友好的代码 作者：小米 公众号：星尘的一个朋友"></p><p><code>这种代码我亲身经历在线上版本见到过</code></p><p>对人友好的代码基本条件，能读。</p><h4 id="其次，不要让人误会"><a href="#其次，不要让人误会" class="headerlink" title="其次，不要让人误会"></a>其次，不要让人误会</h4><p><img src="https://i.loli.net/2021/02/27/ntVLATYmFj1g7xW.png" alt="让人误会的代码 | 写出一些友好的代码 作者：小米 公众号：星尘的一个朋友"></p><p>仔细看，这里的 ① 和 ② 是不在一个条件中的。同事因为这种写法，出过生产问题。当时他说代码没问题叫我帮他看看。说实话，当时挺懵的。</p><h4 id="三，不要做复杂分支的判断鬼才"><a href="#三，不要做复杂分支的判断鬼才" class="headerlink" title="三，不要做复杂分支的判断鬼才"></a>三，不要做复杂分支的判断鬼才</h4><blockquote><p>例子为最基本示意例子，实际情况判断中或更为复杂</p></blockquote><p>在 <strong>复杂</strong>  的逻辑分支判断这一点，我想应该是最常见。因为前面两个完全可以通过 IDE 帮你规避，不过这一点，稍不留意，就会变得有点放肆了。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// A B C 条件同时满足</span><br><span class="hljs-keyword">if</span> (A &amp;&amp; B &amp;&amp; C) &#123;&#125;<br><br><span class="hljs-keyword">if</span> (!A || !B || !C) &#123;&#125;<br></code></pre></td></tr></table></figure><p>在开发组内我一直强调的就是，在 <strong>复杂</strong> 逻辑判断要简单而且使用正向思维。就是多用与，少用或非，注意是少用，不是不允许用。能用与就用与，能不用非就不用非。因为这更能提高理解速度。特别是在一些 <strong>复杂</strong> 的逻辑判断分支中。</p><p>同时，如果分支内容判断条件过多时，建议拆解。比如</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((A != AA || A != AB ) &amp;&amp; B &amp;&amp; C) &#123;&#125;<br></code></pre></td></tr></table></figure><p>可替换为</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">boolean</span> a = A != AA || A != AB;<br><span class="hljs-keyword">if</span> (a &amp;&amp; B &amp;&amp; C) &#123;&#125;<br></code></pre></td></tr></table></figure><p>关于 <strong>复杂</strong> 分支的判断的关键点就在于理解，所谓对人友好，就是让人很快就能看明白你代码的意思。这就需要根据实际的逻辑语境做一些合理的判断写法了。</p><p>下面随便列了一个逻辑判断的代码，简单感受一下。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">int</span> age = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 0 male 1 female 2 demale</span><br><span class="hljs-keyword">int</span> gender = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> height = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> weight = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 筛选出 年龄大于 18 小于 60 , 非人妖, 身高 140 以下, 体重80 以下的人</span><br><span class="hljs-keyword">if</span> (age &gt; <span class="hljs-number">18</span> &amp;&amp; age &lt; <span class="hljs-number">60</span> &amp;&amp; gender != <span class="hljs-number">2</span> &amp;&amp; height &gt; <span class="hljs-number">140</span> &amp;&amp; weight &gt; <span class="hljs-number">80</span>) &#123;<br>    <span class="hljs-comment">// 合格人</span><br>&#125;<br><br><span class="hljs-keyword">if</span> (!((age &lt; <span class="hljs-number">18</span> || age &gt; <span class="hljs-number">60</span>) || gender == <span class="hljs-number">2</span> || height &lt; <span class="hljs-number">140</span> || weight &lt; <span class="hljs-number">80</span>)) &#123;<br>    <span class="hljs-comment">// 合格人</span><br>&#125;<br><br><span class="hljs-keyword">boolean</span> ageFlag = age &gt; <span class="hljs-number">18</span> &amp;&amp; age &lt; <span class="hljs-number">60</span>;<br><span class="hljs-keyword">boolean</span> genderFlag = gender != <span class="hljs-number">2</span>;<br><span class="hljs-keyword">boolean</span> heightFlag = height &gt; <span class="hljs-number">140</span>;<br><span class="hljs-keyword">boolean</span> weightFlag = weight &lt; <span class="hljs-number">80</span>;<br><span class="hljs-keyword">if</span> (ageFlag &amp;&amp; genderFlag &amp;&amp; heightFlag &amp;&amp; weightFlag) &#123;<br>    <span class="hljs-comment">// 合格人 </span><br>&#125;<br>    <br><br></code></pre></td></tr></table></figure><h4 id="四，迷惑行为少一点"><a href="#四，迷惑行为少一点" class="headerlink" title="四，迷惑行为少一点"></a>四，迷惑行为少一点</h4><p>前方迷惑代码高能预警，以下代码为项目<strong>真实代码</strong>。请不要对号入座！请不要对号入座！请不要对号入座！</p><h5 id="存了个寂寞"><a href="#存了个寂寞" class="headerlink" title="存了个寂寞"></a>存了个寂寞</h5><p><img src="https://i.loli.net/2021/02/27/SUWeTCgv3QYmVcE.png" alt="存了个寂寞|写出一些友好的代码 作者：小米 公众号：星尘的一个朋友"></p><p>不清楚它要做什么，思来想去，应该只是来浪费了我代码审查的时间，怕我没事做，为我增加工作量。</p><h5 id="任性换行"><a href="#任性换行" class="headerlink" title="任性换行"></a>任性换行</h5><p><img src="https://i.loli.net/2021/02/27/Ztv4a6eOAKNzd5S.png" alt="随性换行与日志框架技术不了解|写出一些友好的代码 作者：小米 公众号：星尘的一个朋友"></p><p>这换行符我说了算，我觉得它该换行了。免疫 IDE 警告。</p><h5 id="截取寂寞"><a href="#截取寂寞" class="headerlink" title="截取寂寞"></a>截取寂寞</h5><p><img src="https://i.loli.net/2021/02/27/6ohMCjdSKyT8u3a.png" alt="截取寂寞|写出一些友好的代码 作者：小米 公众号：星尘的一个朋友"></p><p>免疫 IDE 警告+1。</p><h5 id="异常自己也没想到会这样"><a href="#异常自己也没想到会这样" class="headerlink" title="异常自己也没想到会这样"></a>异常自己也没想到会这样</h5><p><img src="https://i.loli.net/2021/02/27/vbqQ69mGyIFnuwB.png" alt="对于异常，我最了解|写出一些友好的代码 作者：小米 公众号：星尘的一个朋友"></p><p>如果你看不懂这段操作，请关注我。一起讨论一下这件关于异常处理怎么写能写飞这件事。还有，到底还要怎么样才能会用日志框架？</p><h5 id="谢大国的媳妇，香秀"><a href="#谢大国的媳妇，香秀" class="headerlink" title="谢大国的媳妇，香秀"></a>谢大国的媳妇，香秀</h5><p><img src="https://i.loli.net/2021/02/27/2kypgG89sn67KqO.png" alt="彪悍的人生，不需要太多解释|写出一些友好的代码 作者：小米 公众号：星尘的一个朋友"></p><p>免疫 IDE 警告+1。</p><h3 id="友好的代码"><a href="#友好的代码" class="headerlink" title="友好的代码"></a>友好的代码</h3><p>回到我们的主题，对人友好的代码，还是上面那句话，对人友好的代码实在是太多了！我想，任何一个程序员都可以写出对人友好的代码，就看你想不想去写。试想你自己写的代码，过了几个月回去看，心里喷了半天结果一看作者是自己。这就很尴尬了。对人友好的代码它可能并不一定是最好的代码，但最起码是认真写的代码，这将会是写出好代码的第一步，希望大家都能迈出去。</p><p><code>关于编码，我想这应该是程序员最熟悉不过的事儿了。也是作为一个程序员最基本的职能了，而恰恰是最常做的事，最容易产生自信。而这种自信，有时便会成为理所应当的坏习惯。</code></p><p>其实关于对人友好的代码并不是技术上的话题，我觉得这更像是社交上的话题，程序员可能会习惯通过你的代码来了解你这个人。至少我有这样的一点小习惯。见码如见人。</p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>最后用 vant demo 中的话结个尾吧：代码是给人看的，附带可以在机器上运行。</p><p>正文完</p><hr><p>欢迎关注我，下一篇分享 【写一些友好的代码（下），对机器友好】。谈谈如何面向虚拟机编程，写出对机器友好的代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写一些友好的代码（上），对人友好&quot;&gt;&lt;a href=&quot;#写一些友好的代码（上），对人友好&quot; class=&quot;headerlink&quot; title=&quot;写一些友好的代码（上），对人友好&quot;&gt;&lt;/a&gt;写一些友好的代码（上），对人友好&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;这</summary>
      
    
    
    
    <category term="虚拟机" scheme="http://lvgo.org/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="虚拟机" scheme="http://lvgo.org/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>MyChat，一个私有的&quot;微信&quot;</title>
    <link href="http://lvgo.org/post/mychat-01.html"/>
    <id>http://lvgo.org/post/mychat-01.html</id>
    <published>2021-02-06T06:10:10.000Z</published>
    <updated>2021-02-06T06:10:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="星尘的一个朋友"><a href="#星尘的一个朋友" class="headerlink" title="星尘的一个朋友"></a>星尘的一个朋友</h1><blockquote><p>不要抱怨、坚持下去💪。</p></blockquote><h2 id="MyChat"><a href="#MyChat" class="headerlink" title="MyChat"></a>MyChat</h2><p>我希望它是一个简单的沟通工具。使用简单的，开发简单的私有的，或可发展成企业级的聊天系统或是组件。但是，越是看起来简单，它的内部就越复杂。这个复杂不是指它的开发难度，而是设计。</p><p><img src="https://i.loli.net/2021/02/06/IHKsoxGCSYUnvp4.png" alt="mychat"></p><p>之前有人问我（面试官），你说设计模式可以让开发变得容易，又说使用设计模式会让程序变得复杂，这不是自相矛盾吗？我的回答是“如果你只创建一个对象还用工厂模式，那肯定是复杂了，但如果你想扩展你的对象创建，那他就不复杂。因为你开发一次，受用多次，算是一劳永逸了。”</p><p>这次 MyChat 的设计，推翻了几次，至少现在我仍不满意，但它确确实实已经做到了一定的扩展性，比如新增一个 UI 功能，我有为其考虑使用的 模板方法模式， 比如你想新增一种消息类型，我在 SDK 包中的监听器可以轻松应对，这些都已经在我迭代的过程中体现出来了。</p><h2 id="MyChat-由来"><a href="#MyChat-由来" class="headerlink" title="MyChat 由来"></a>MyChat 由来</h2><p>做这个项目的原因和契机有很多，说两个比较关键的。</p><p>一是因为一个叫傅政委的男人，关于这个人(<code>https://bugstack.cn/</code>)，以后再说，要讲的东西有点多，一篇写不下。</p><p>二是对自己一个交代吧，把自己对软件设计的理解，在这个行业的所学所得，还有自认为良好的编码习惯都倾注到这个项目上。如果以后你有机会能够看到 MyChat 项目源码，也希望能评价一番，好的坏的，我都接受。我多么希望有一个能指导自己的人。</p><h2 id="MyChat-项目介绍"><a href="#MyChat-项目介绍" class="headerlink" title="MyChat 项目介绍"></a>MyChat 项目介绍</h2><p>该项目适合 netty 学习者或进行 IM 相关系统开发者。可以基于该项目快速开发出一个带有通讯能力的应用。</p><p>UI 采用的 JavaFx ，了解过 JavaFx 的人都知道这东西在国内的文档表现，为使得页面开发便捷，专门为其开发了一些轮子，比如 FxmlObject ，让你可以轻松的来操作 fxml 文件对象。实现布局的快速调整，功能的快速迭代。</p><p>前端程序准备了 mychat-client 客户端模块 SDK（java语言） ，给你提供足够的 API，将前端开发的权利全都交给你。也就是说，你可以使用任何开发方案，不过要考虑集成问题，因为 JavaFx 可以直接调用 java 程序，所以我这没有集成问题。</p><p>后端可以自己部署（开源以后），也可以使用 mychat 云（暂未开放）。</p><h2 id="应用部分截图"><a href="#应用部分截图" class="headerlink" title="应用部分截图"></a>应用部分截图</h2><p><img src="https://i.loli.net/2021/02/06/WZe1txRyjhTUBfV.png" alt="登录页面"></p><p><img src="https://i.loli.net/2021/02/06/ljAnTBgLOhWvteG.png" alt="登录页面"></p><p><img src="https://i.loli.net/2021/02/06/KiOTJAuc8F3eL5g.png" alt="首页"></p><p><img src="https://i.loli.net/2021/02/06/8GJNBaysTpdFrXf.png" alt="添加好友"></p><p><img src="https://i.loli.net/2021/02/06/PZvpMJcDQqXgjNU.png" alt="创建群聊"></p><p><img src="https://i.loli.net/2021/02/06/RTU7cEGYvh41iFN.png" alt="群聊"></p><p><img src="https://i.loli.net/2021/02/06/XvZW2PIK5xQ9de3.png" alt="好友"></p><p><img src="https://i.loli.net/2021/02/06/BAhdfb6lmHQvI8J.png" alt="聊天"></p><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><p>开发 MyChat 遇到了很多问题,这里列举一些随手记的问题和大家分享一下,有的已经解决,有的在该项目中仍然存在.</p><p>解决的问题在 MyChat 后续相关文章中会给出我的解决方案.可以关注我一起交流学习.</p><h3 id="UI-问题"><a href="#UI-问题" class="headerlink" title="UI 问题"></a>UI 问题</h3><ol><li>stage 选择无边框模式后, 页面的拖拽. 缩放问题;</li><li>listview 空数据鼠标悬停背景色问题;</li><li>节点边距问题;</li><li>listview 鼠标点击,但不选中. 朋友页面使用 listview 实现, 标题也为 listcell 但可点击,不可选中;</li><li>sketch 文本过长,显示问题;</li><li>页面关闭问题, 关闭后断开连接并结束进程;</li><li>如何让某个页面置顶, 不可失去焦点?;</li><li>滚动条样式问题;</li><li>滚动条如何处理不占位置;</li><li>群头像如何生成?</li><li>聊天内容如何跟着主页面的缩放进行缩放?</li><li>聊天内容的文本域如何动态调整宽高?使文本合理的展示? (难搞)</li><li>javaFx 的边框?边距?背景?</li></ol><h3 id="功能问题"><a href="#功能问题" class="headerlink" title="功能问题"></a>功能问题</h3><ol><li>现在 UI 数据都存在缓存中,重启应用后消失,这部分数据如何处理?</li><li>后端哪些数据需要持久化?</li><li>怎么能提高程序的扩展性,增加一类消息时很简单?</li><li>UI 客户端没有使用 spring , 应用中使用的 bean 如何管理?</li><li>哪些内容需要做成配置?如何做?</li><li>本地存储使用序列化方式保存Java bean, 但要存储的对象没有实现序列化接口(组件中的类),如何存储.</li><li>离线消息如何处理?</li><li>心跳机制实现时, 出现偶发空闲检测事件.</li></ol><hr><p>欢迎关注我，关注 MyChat。</p>]]></content>
    
    
    <summary type="html">独立开发的 IM 系统</summary>
    
    
    
    
    <category term="MyChat" scheme="http://lvgo.org/tags/MyChat/"/>
    
    <category term="Netty" scheme="http://lvgo.org/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Java 类的一生</title>
    <link href="http://lvgo.org/post/lvgo-jvm-09.html"/>
    <id>http://lvgo.org/post/lvgo-jvm-09.html</id>
    <published>2021-01-24T10:37:09.000Z</published>
    <updated>2021-01-24T10:37:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章说实话，难产了🤪（手动捂脸）</p><a id="more"></a><h1 id="Java-类的一生"><a href="#Java-类的一生" class="headerlink" title="Java 类的一生"></a>Java 类的一生</h1><blockquote><p>首先要知道，我说的这个类，也就是我们上篇内容说的那个 <code>Class 文件</code> 通常指一串 “二进制字节流”。</p></blockquote><p>从我们码出 <code>public class Cafe</code> 的时候，可以说。这个种子 <code>bean</code> 就已经埋下了。然后我们将它通过前端编译器 <code>javac</code> 编译成了 <code>Class</code> 文件 。</p><p>紧接着它被 <code>JVM</code> 加载，后被应用到程序中，最后被 <code>JVM</code> 卸载。短短的几句话，概括了 <code>Java 类</code> 的一生。但这其中每一步，都有着可以用来喝一宿的故事。今天我还是长话短说，少喝点，讲一讲 <code>Java</code> 类的一生。</p><h2 id="Javac-的孕育"><a href="#Javac-的孕育" class="headerlink" title="Javac 的孕育"></a>Javac 的孕育</h2><p>当你敲完最后一个 <code>;</code> 或 <code>)</code> 时，你高兴的执行了你的代码。而此时，<code>类</code> 的一生，算是开始了。</p><p><code>类</code> 首先经历的就是被 <code>Javac</code> 这个前端编译器进行编译。因为这样，它才能被 <code>JVM</code> 所使用，这一步 <code>Javac</code> 都对它做了什么呢？</p><h3 id="第一步：词法、语法分析"><a href="#第一步：词法、语法分析" class="headerlink" title="第一步：词法、语法分析"></a>第一步：词法、语法分析</h3><p><code>Javac</code> 把 <code>.java</code> 文件中的每个 <code>标记</code> 通过词法和语法分析构建出一颗抽象语法树。我们在编码的时候，都是敲下 <code>abcde</code> 的单个字符为最小单元，但在 <code>Javac</code> 这里，最小的单元就是 <code>public</code> <code>int</code> <code>a</code> <code>=</code> <code>11</code>，这些，每一项都会作为一个 <code>标记</code>。把每个单元转成 <code>标记</code> 集合的过程称为词法分析，根据 <code>标记</code> 构建出来抽象语法树这个过程叫语法分析。有了这颗 <code>树</code> 就方便后面的操作了。</p><h3 id="第二步：填充符号表"><a href="#第二步：填充符号表" class="headerlink" title="第二步：填充符号表"></a>第二步：填充符号表</h3><p>对刚刚的语法树进行遍历，将出现的符号定义和符号信息保存到符号表中;</p><h3 id="第三步：注解处理器"><a href="#第三步：注解处理器" class="headerlink" title="第三步：注解处理器"></a>第三步：注解处理器</h3><p>这一步是干啥呢，这么跟你说吧， <code>lombok</code> 用过吗？就干那个了。没错，代码的修改。这些还要得益于 <code>插入式注解处理器</code> ，它可以让你很轻松的来操作第一步生成出来的那颗抽象语法树，来达到对代码进行额外的操作。哦对了，如果这一步有对抽象语法树进行过操作，那么需要重新执行填充符号表的动作。</p><h3 id="第四步：语义分析"><a href="#第四步：语义分析" class="headerlink" title="第四步：语义分析"></a>第四步：语义分析</h3><p>对程序进行语义逻辑分析。也是我们经常说的编译报错的地方，就在这了。比如你写个 <code>int i = 0</code> <code>boolean j = false</code> <code>int k = i + j</code> 你这样写肯定没问题，不过在编译的时候，就会报错了。不要说你在 <code>IDE</code> 中写的时候就会爆红。细品。还有一个例子，就是你定义的 <code>final</code> 的变量。你在编写的时候，是必须要初始化，而且不允许再被修改的，这个值有没有被改过，也是在这个阶段来检查的。你不要说在 <code>IDE</code> 编写的时候改就会爆红。</p><h3 id="第五步：解语法糖"><a href="#第五步：解语法糖" class="headerlink" title="第五步：解语法糖"></a>第五步：解语法糖</h3><p>关于 Java 的语法糖，我们几乎只要在编码，就会多多少少的使用到，比如 <code>泛型</code>、<code>自动拆装箱</code>、<code>增强 for 循环</code>。这一步就是将其还原成他们本来的样子。</p><h3 id="第六步：生成字节码文件"><a href="#第六步：生成字节码文件" class="headerlink" title="第六步：生成字节码文件"></a>第六步：生成字节码文件</h3><p>经历了上面几步之后，最终会得到一个 <code>.class</code> 的字节码文件。其使用的就是第二步填充的那个符号表的信息。这一步比较关键的内容就是生成 <clinit> 方法和 <init> 方法。类构造器和实例构造器。这个实例构造器和我们代码中的构造函数不同。<clinit> 和 <init> 的作用主要是代码收敛，比如 <clinit> 可以确定父类的 <code>static</code> 代码块一定先于子类执行。</p><blockquote><p>关于符号表的这里，我相信大家很多人都看过一些相关的博文或资料，不过几乎无人谈及这个符号表里到底是个什么东西，所以，我也就不说了。那必不可能，其实这个符号表是编译原理层面的内容，还是需要了解一下编译原理的这块内容才行，不过我之前也说过，关于编译原理这块自己真的是一概不知。所以这没办法在这里写清楚，不过抱着技术分享的认真态度，还是去了解了一些，这块还是相对较基础的。所谓的符号表，在编译原理中，它是讲，将程序中出现的有关标识的符号的属性信息保存下来。主要是用于语法分析和内存分配阶段。保存的形式也不单一，可以用数组、散列表、栈、树等数据结构来进行登记。内容的话，比如 Java 中的方法为例 <code>public void fun(param1,param2)</code> 那么在符号表中就要保存 <code>fun</code> 与之对应的值，<code>param1</code> 与之对应的值，以此类推。这里的举例为个人理解所写，真正编译原理所表达的符号与之类似。如感兴趣可进行编译原理内容学习。</p></blockquote><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p>当编译器 Javac 孕育出 .class 字节码之后，接下来类的生命周期就围绕以下 <strong>加载 - 验证 - 准备 - 解析 - 初始化 - 使用 - 卸载 7步</strong> 展开了。</p><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h3><p>将字节码二进制流加载到内存，当我们的代码经历过前端编译器，便成为了可以被虚拟机加载的字节码文件。当然，这个类，可能是我们自己写的（编码）也有可能是通过运行时生成的字节码内容，所以前面说加载的时候说的是 <code>将字节码二进制流加载到内存</code>，而不是 <code>class</code> 文件加载到内存，因为字节码包含了各种形式的内容，比如 <code>class</code> 文件，或者本地或网络传输的二进制流等。</p><p>加载的过程中，主要是将这个字节码二进制流转换成虚拟机所能使用的信息，基本内容包含</p><ol><li>通过全部限定名来获取一个二进制的字节流；</li><li>把字节流中定义的内容转到方法区中的数据结构；</li><li>生成一个可以表示这个二进制流的 Class 对象，作为访问方法区内容的入口；</li></ol><p>以上的操作，是由一个叫做 <strong>类加载器</strong> 的家伙完成的，关于这哥们，待会我们再好好看看它。</p><h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h3><p>验证加载的字节码内容是否合法，这一步主要是防止虚拟机遭到破坏</p><ul><li>验证文件格式</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ul><h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h3><p>准备阶段为类中定义的静态变量（类变量）分配内存并赋默认值（非程序中的默认值）</p><ul><li><code>public static int id = 123</code> 默认值赋值 0 而非 123</li><li>123 会在对应程序的类构造器（注意与实例构造器区别）中的<code>&lt;clinit&gt;()</code> 方法中完成，</li><li>如果是 <code>public static final int id = 123</code> 会在此阶段完成赋值</li></ul><p><strong>继续深入：</strong></p><p>123 会在对应程序的类构造器（注意与实例构造器区别）中的<code>&lt;clinit&gt;()</code> 方法中完成，这个 <code>&lt;clinit&gt;()</code> 方法是由 javac 编译器编译出来的方法</p><ul><li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有<strong>类变量的赋值动作和静态语句块（static{}块）</strong>中的语句合并产生的，编译器收集的顺序是由语句在<strong>源文件中出现的顺序决定</strong>的，静态语句块中<strong>只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问</strong></li><li><code>&lt;clinit&gt;()</code>方法与类的构造函数（即在虚拟机视角中的实例构造器<code>&lt;init&gt;()</code>方法）不同，它不需要显式地调用父类构造器，Java虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。因此在Java虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类型肯定是java.lang.Object</li><li>由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作</li><li>非必须，如果类或接口中没有静态变量或方法，编译器会省略生成<code>&lt;clinit&gt;()</code>方法这步操作</li><li><code>&lt;clinit&gt;()</code> 方法在多线程环境会被正确同步</li></ul><h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h3><p>解析阶段将类的符号引用替换为直接引用</p><ul><li>符号引用（Symbolic References）：还记得之前文章中提到的 Class 文件中存的内容吗，还记得那些表吗？这个符号引用就是那时的索引。</li><li>直接引用（Direct References）：可以直接或间接定位到目标的真实的内存地址的引用。可以是直接指针、偏移量。</li></ul><h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h3><p>对于类加载，虚拟机规范没有严格要求，具体可由虚拟机的实现自行决定。</p><p>但对类，虚拟机规范明确了类必须初始化的 6 个场景（有且仅有）</p><ol><li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，能够触发这四条指令的场景<ul><li>new关键字</li><li>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候</li><li>调动类的静态方法</li></ul></li><li>对类型使用反射调用。</li><li>子类初始化时会优先初始化父类。</li><li>虚拟启动时用户指定的那个类。（包含 <code>main()</code> 方法的类）会被初始化。</li><li>当使用JDK 7新加入的动态语言支持时，执行句柄为静态字段或方法，或构造函数时需要对目标进行初始化（此处需了解 JDK 7 新增的动态语言支持，后续有机会会对此出内容单独整理文章说明，欢迎关注）。</li><li><strong>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</strong></li></ol><p>上面说的是 6 种 <strong>主动</strong> 方式触发的初始化，还有 3 种 <strong>被动</strong> 引用不会引发类的初始化。</p><ol><li>通过子类访问父类静态变量，只会初始化父类，不会初始化子类。</li><li>使用new关键字来创建类型数组不会触发初始化。</li><li>访问常量字段，即 <code>static final</code> 共同修饰的字段。这个原因上面有说明过，在这里再墨迹一下，会在编译器 javac 阶段将其放入常量池。</li></ol><h3 id="6-使用"><a href="#6-使用" class="headerlink" title="6. 使用"></a>6. 使用</h3><p>就是使用咯。</p><h3 id="7-卸载"><a href="#7-卸载" class="headerlink" title="7. 卸载"></a>7. 卸载</h3><blockquote><p>还记得之前我们写的一篇文章 <a href="https://mp.weixin.qq.com/s?__biz=MzU2MjM2NDU1Mw==&amp;mid=2247485257&amp;idx=1&amp;sn=ca53d2e3a29f1a05bcd4b5fd7ec271fc&amp;chksm=fc6beeafcb1c67b9e0b33ea8d59e6d5e9d386f0ef38ef2a3329bb0f1dfabeb5103854a2f2160#rd">JVM 是怎么把“送”出去的内存又“要”回来的</a> 其中有写到 <strong>类卸载</strong> 的相关内容，没读过的朋友可以点击链接阅读全文，效果更好，也可以阅读下面截取的片段。</p></blockquote><p>类的卸载还是比较严格的，而且这个条件也比较苛刻，判断一个类型信息是否可以被回收（卸载）需要 <strong>同时</strong> 满足以下三个条件：</p><ol><li>该类信息对应的所有实例被回收</li><li>加载该类的加载器被回收（<em>关键</em>）</li><li>对应的 <em>java.lang.Class</em> 对象没有在任何地方被引用</li></ol><p>具体内容如下：</p><ol><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li><li>加载该类的类加载器已经被回收，<strong>这个条件除非是经过精心设计的可替换类加载器的场景，否则通常是很难达成的。</strong></li><li>该类对应的 <em>java.lang.Class</em> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ol><p><em>多了解一点：</em></p><p><em>其中第三点与我们经常见到的操作诸如 spring 这种大量使用反射的框架、JDK 的动态代理、以及 CG lib 这种操作字节码的框架基本上都需要 JVM 拥有类卸载的功能，否则会导致一些自定义加载器加载的临时类信息占据着方法区的内存，带来不必要的压力。</em></p><p>当类被卸载后，类的一个生命周期就结束了，还有，上面的顺序并非一成不变，不过 加载 - 使用 - 卸载，这个大的框架顺序还是必须这样的，简单说明下这是因为 Java 动态语言的支持导致的。以上，就是我这次要分享的主要内容 <strong>Java 类的一生</strong>，谢谢你的阅读。</p><hr><p>下面我们简单扩展一下类加载这哥儿们。</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>关于这哥们，它的工作很简单，只需要负责把二进制流加载到内存中，哦对了，加载完了会打个标。完事。</p><p>打标就是通过类的 <strong>完全限定名</strong> 来为每个 <code>Class文件的二进制流</code> 命名，这样做是可以方便应用程序加载自己需要的类，还有一个原因我们下面会看到。</p><h3 id="类与类加载器的区别"><a href="#类与类加载器的区别" class="headerlink" title="类与类加载器的区别"></a>类与类加载器的区别</h3><p>类加载器只实现类的加载动作。</p><p>类之间的比较，前提条件是同一个类加载器。如果由不同类加载器加载的相同完全限定名的类，那他们也是完全不同的（打标的原因其二）。也不能这样去做比较。</p><h3 id="两类类加载器"><a href="#两类类加载器" class="headerlink" title="两类类加载器"></a>两类类加载器</h3><ul><li><p>由 C++ 实现的启动类加载器（BootStrap ClassLoader）</p></li><li><p>由 Java 实现的 （java.lang.ClassLoader）的子类</p></li></ul><h4 id="启动类加载器-（C-实现）"><a href="#启动类加载器-（C-实现）" class="headerlink" title="启动类加载器 （C++ 实现）"></a>启动类加载器 （C++ 实现）</h4><p>负责加载 JAVA_HOME/lib 目录下的 jar，<strong>注意：识别方式为文件名识别，即使放入不符合规范的文件也不能被加载。</strong> 该加载器不能被 Java 程序引用，访问时会返回 <code>null</code></p><h4 id="扩展类加载器（Java-实现）"><a href="#扩展类加载器（Java-实现）" class="headerlink" title="扩展类加载器（Java 实现）"></a>扩展类加载器（Java 实现）</h4><p>负责加载 JAVA_HOME/lib/ext 目录下的类，可被程序调用。也可加载 <code>java.ext.dirs</code> 系统变量所指定的路径中所有的类库。</p><h4 id="应用-系统类加载器（Java-实现）"><a href="#应用-系统类加载器（Java-实现）" class="headerlink" title="应用/系统类加载器（Java 实现）"></a>应用/系统类加载器（Java 实现）</h4><blockquote><p>这个类加载器由sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSystem-ClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”</p></blockquote><p>它负责加载用户类路径（ClassPath）上所有的类库</p><p>可以直接在代码中使用这个类加载器。</p><p>如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/b164f8b96064da462108e84d724bdb2a.png" alt="双亲委派模型"></p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p><h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h4><p>不遵守这个模型规则就可以破坏双亲委派模型</p><ol><li>重写 loadClass 方法</li><li>JVM 自己被自己的 SPI 机制打破。<em>后 JDK6 通过 ServiceLoader + 责任链模式解决</em></li></ol><p><em>关于 SPI 的话，我们后面有机会在深入聊聊，因为其不属于虚拟机范畴，暂时先不深入讨论了。这部分内容和 JNDI 有关（Java Naming and Directory Interface,Java命名和目录接口）是 Java 的一个关键技术点。不知道可不太好，关注我，一起学习。</em></p><p>(正文完)</p><hr><p>如果觉得写的还不错，可以关注点赞在看支持我。(#^.^#)</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MjM2NDU1Mw==&amp;mid=2247485332&amp;idx=1&amp;sn=4c4d4afd9ed564798e460299847df27b&amp;chksm=fc6bee72cb1c67647e3034e314ec3ea1fccf1955e44ff1344e46ade31b7ffd7a01d85b7b1b7c&token=183649644&lang=zh_CN#rd">你说那 class 文件里边都是啥</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MjM2NDU1Mw==&amp;mid=2247485295&amp;idx=1&amp;sn=ebb76f06a0998e12a16d817392de0f7e&amp;chksm=fc6bee89cb1c679f6ef3e0a5327cf0e19d2f833bdec2eb4c3cb7edd233a6d5b66ff3ad39c5eb&token=1494472137&lang=zh_CN#rd">到底是谁在回收 JVM 的垃圾</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MjM2NDU1Mw==&amp;mid=2247485282&amp;idx=1&amp;sn=abde86f06e82c63858d60960b3122fa7&amp;chksm=fc6bee84cb1c67927e360626ac0c1822d8f5e77de14c097989dcbab052028f05ffc24ed93d63&token=1303129454&lang=zh_CN#rd">天天听人家说的 GC 到底是个啥？</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MjM2NDU1Mw==&amp;mid=2247485226&amp;idx=1&amp;sn=5b8ed2e5d06899ff2d7d931f9d964d70&amp;chksm=fc6beecccb1c67da4b405fa8c8c69878958b56d9291bdf8067b4bbf8c137b0194a0cae14e622&token=1941800665&lang=zh_CN#rd">你创建的 Java 对象搁哪了</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MjM2NDU1Mw==&amp;mid=2247485249&amp;idx=1&amp;sn=589495ebea994d2ac91110d9bdcf5326&amp;chksm=fc6beea7cb1c67b17258a7da71a36f00b0386b68f7d25d53949ac7de7be5f3f74d3a205e439b&token=1941800665&lang=zh_CN#rd">JVM 中对象咋创建啊，又怎么访问啊</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MjM2NDU1Mw==&amp;mid=2247485273&amp;idx=1&amp;sn=ca06732e3ce9853446993618ca06a154&amp;chksm=fc6beebfcb1c67a9bee28a755e15a31fb62b87d48e2a795a15765d82595525ce49fc3cb95fee&token=1941800665&lang=zh_CN#rd">JVM 把内存”收“回来用的是什么法器</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MjM2NDU1Mw==&amp;mid=2247485257&amp;idx=1&amp;sn=ca53d2e3a29f1a05bcd4b5fd7ec271fc&amp;chksm=fc6beeafcb1c67b9e0b33ea8d59e6d5e9d386f0ef38ef2a3329bb0f1dfabeb5103854a2f2160&token=1941800665&lang=zh_CN#rd">JVM 是怎么把“送”出去的内存又“要”回来的</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章说实话，难产了🤪（手动捂脸）&lt;/p&gt;</summary>
    
    
    
    <category term="虚拟机" scheme="http://lvgo.org/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="虚拟机" scheme="http://lvgo.org/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>你说那 class 文件里边都是啥</title>
    <link href="http://lvgo.org/post/lvgo-jvm-08.html"/>
    <id>http://lvgo.org/post/lvgo-jvm-08.html</id>
    <published>2021-01-10T15:12:55.000Z</published>
    <updated>2021-01-10T15:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/01/10/tbYrUAgcL3fhyVH.png"></p><h3 id="开往虚拟机的车已经出发，关注上车"><a href="#开往虚拟机的车已经出发，关注上车" class="headerlink" title="开往虚拟机的车已经出发，关注上车"></a>开往虚拟机的车已经出发，关注上车</h3><h2 id="CLASS文件的结构"><a href="#CLASS文件的结构" class="headerlink" title="CLASS文件的结构"></a>CLASS文件的结构</h2><blockquote><p>我相信你一定打开过 class 文件，你看到的也是下面这个样子，不过这里面都是啥？今天我们一起好好看看。</p></blockquote><h2 id="CLASS文件的结构-1"><a href="#CLASS文件的结构-1" class="headerlink" title="CLASS文件的结构"></a>CLASS文件的结构</h2><ol><li>魔数</li><li>版本号</li><li>常量池</li><li>字段表集合</li><li>方法表集合</li><li>属性表集合</li></ol><p>我相信你一定打开过 class 文件，你看到的也是下面这个样子，不过这里面都是啥？今天我们一起好好看看。（如果不方便看的话，可以在文章末尾关注我的公众号，在手机上阅读）</p><p><img src="https://i.loli.net/2021/01/10/3oGNDJpU91xnfLM.png"></p><blockquote><p>如果上图不方便看的话，可以在文章末尾关注我的公众号，在手机上阅读</p></blockquote><h2 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h2><p>首先属性表是用来补充信息用的，比如他可以继续补充类文件的信息、就是我们上面最后的那一段内容，还有他可以补充字段的信息，补充方法的信息。所以它出现的位置不同，补充的额外信息也会不一样。</p><p>下面我们 <strong>简单</strong> 的了解一下都有哪些 <strong>主要</strong> 的内容，之所以要简单、要了解主要的，就是因为它保存的额外信息实在太多了。</p><p>属性表的结构是由 2 个字节的属性名索引，4 个字节的属性内容长度，和 1 个字节的属性信息组成。</p><p>按照属性的类别可以分为：类文件属性、字段表属性、方法表属性</p><h3 id="类文件属性"><a href="#类文件属性" class="headerlink" title="类文件属性"></a>类文件属性</h3><h4 id="InnerClass"><a href="#InnerClass" class="headerlink" title="InnerClass"></a>InnerClass</h4><p>保存主类和内部类的关系</p><h4 id="SourceFile"><a href="#SourceFile" class="headerlink" title="SourceFile"></a>SourceFile</h4><p>记录生成这个Class文件的源码文件名称</p><h3 id="方法表属性"><a href="#方法表属性" class="headerlink" title="方法表属性"></a>方法表属性</h3><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><p>Java 程序方法体里面的代码经过 Javac 编译器处理之后， 最终变为字节码指令存储在Code属性内。并非所有的方法表都必须存在这个属性， 接口或者抽象类中的方法就不存在Code属性 。</p><p>code 属性里面还有属性表…. （套娃啊），其中包含</p><ul><li>LineNumberTable 源码和生成的字节码行号映射表</li><li>LocalVariableTable 栈帧中的变量与源码变量的映射关系</li><li>ExceptionTable 异常表</li><li>…..</li></ul><h4 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h4><p>Exceptions属性的作用是列举出在throws关键字后面抛出的异常</p><h4 id="MethodParameters"><a href="#MethodParameters" class="headerlink" title="MethodParameters"></a>MethodParameters</h4><p>定义方法的参数信息</p><h3 id="字段表属性"><a href="#字段表属性" class="headerlink" title="字段表属性"></a>字段表属性</h3><h4 id="ConstantValue"><a href="#ConstantValue" class="headerlink" title="ConstantValue"></a>ConstantValue</h4><p>这个属性用于为字段的静态变量赋值。只有字段声明为 static 时才有效。Javac 编译器在编译的时候，如果遇到 static 和 final 同时修饰的 基本类型或String 类型变量，会直接在 ConstantValue 属性进行字段初始化。也就是我们说的常量。如果没有 final 修饰，或者不是基本类型和 String 类型，则会在类初始化方法执行的时候初始化  <code>&lt;clinit&gt;</code></p><h3 id="通用属性"><a href="#通用属性" class="headerlink" title="通用属性"></a>通用属性</h3><h5 id="Deprecated"><a href="#Deprecated" class="headerlink" title="Deprecated"></a>Deprecated</h5><p>Deprecated属性用于表示某个类、 字段或者方法被弃用</p><p>关于属性表的内容还有很多，我只了解了一些基本常见的，这部分内容在周老师书里还是比较全的。想继续了解的可以在书中 6.3.7 章节找到更多内容。</p><p>（正文完）</p><hr><p>如果觉得写的还不错，可以关注点赞在看支持我，如果想一起学习的话，非常欢迎加群一起学习。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MjM2NDU1Mw==&amp;mid=2247485295&amp;idx=1&amp;sn=ebb76f06a0998e12a16d817392de0f7e&amp;chksm=fc6bee89cb1c679f6ef3e0a5327cf0e19d2f833bdec2eb4c3cb7edd233a6d5b66ff3ad39c5eb&token=1494472137&lang=zh_CN#rd">到底是谁在回收 JVM 的垃圾</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MjM2NDU1Mw==&amp;mid=2247485282&amp;idx=1&amp;sn=abde86f06e82c63858d60960b3122fa7&amp;chksm=fc6bee84cb1c67927e360626ac0c1822d8f5e77de14c097989dcbab052028f05ffc24ed93d63&token=1303129454&lang=zh_CN#rd">天天听人家说的 GC 到底是个啥？</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MjM2NDU1Mw==&amp;mid=2247485226&amp;idx=1&amp;sn=5b8ed2e5d06899ff2d7d931f9d964d70&amp;chksm=fc6beecccb1c67da4b405fa8c8c69878958b56d9291bdf8067b4bbf8c137b0194a0cae14e622&token=1941800665&lang=zh_CN#rd">你创建的 Java 对象搁哪了</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MjM2NDU1Mw==&amp;mid=2247485249&amp;idx=1&amp;sn=589495ebea994d2ac91110d9bdcf5326&amp;chksm=fc6beea7cb1c67b17258a7da71a36f00b0386b68f7d25d53949ac7de7be5f3f74d3a205e439b&token=1941800665&lang=zh_CN#rd">JVM 中对象咋创建啊，又怎么访问啊</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MjM2NDU1Mw==&amp;mid=2247485273&amp;idx=1&amp;sn=ca06732e3ce9853446993618ca06a154&amp;chksm=fc6beebfcb1c67a9bee28a755e15a31fb62b87d48e2a795a15765d82595525ce49fc3cb95fee&token=1941800665&lang=zh_CN#rd">JVM 把内存”收“回来用的是什么法器</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MjM2NDU1Mw==&amp;mid=2247485257&amp;idx=1&amp;sn=ca53d2e3a29f1a05bcd4b5fd7ec271fc&amp;chksm=fc6beeafcb1c67b9e0b33ea8d59e6d5e9d386f0ef38ef2a3329bb0f1dfabeb5103854a2f2160&token=1941800665&lang=zh_CN#rd">JVM 是怎么把“送”出去的内存又“要”回来的</a></li></ul>]]></content>
    
    
    <summary type="html">CAFEBABE</summary>
    
    
    
    <category term="虚拟机" scheme="http://lvgo.org/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="虚拟机" scheme="http://lvgo.org/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>到底是谁在回收 JVM 的垃圾</title>
    <link href="http://lvgo.org/post/lvgo-jvm-07.html"/>
    <id>http://lvgo.org/post/lvgo-jvm-07.html</id>
    <published>2021-01-01T11:01:38.000Z</published>
    <updated>2021-01-01T11:01:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/12/28/5SbBtcVkKdOIx2E.png" alt="到底是谁在回收 JVM 的垃圾"></p><blockquote><p>虚拟机的垃圾回收器，没有哪一个是绝对好的，只有比较好的。</p></blockquote><p>今天的这篇文章，我要与你分享虚拟机的那些垃圾回收器们。内容不多，可以耐心看完。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>之前我们已经了解过具体的 GC 涉及的细节知识点，现在我们站在更高的角度，来看看各种垃圾收集器，以及其中两个的工作过程（CMS 和 G1）。</p><p>我们知道，虚拟机将保存对象实例的区域分为了两个叫做 <strong>新生代</strong> 和 <strong>老年代</strong> 的地方，为此虚拟机针对不同的内存区域利用不同的算法设计了不同的垃圾收集器。</p><p>了解垃圾收集器之前，我觉得还是有必要在复习一下  <strong>Stop The World</strong> ，其用来形容在安全点用户线程暂停的这种状态的一个叫法。关于这个垃圾收集器工作的时候为什么要 Stop The World 还有一个比较有意思的事 ，“你妈妈在给你打扫房间的时候， 肯定也会让你老老实实地在椅子上或者房间外待着， 如果她一边打扫， 你一边乱扔纸屑， 这房间还能打扫完？  ”这是虚拟机团队对 Stop The World 的说明，嗯，很有道理，哈哈哈。</p><h3 id="那些回收-JVM-垃圾的家伙"><a href="#那些回收-JVM-垃圾的家伙" class="headerlink" title="那些回收 JVM 垃圾的家伙"></a>那些回收 JVM 垃圾的家伙</h3><h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h4><p>关键字：新生代、Stop The World 、标记 - 复制算法、单线程</p><p><strong>Serial</strong> 是作用在新生代的垃圾收集器，单线程工作，在工作的时候需要 Stop The World，（包括之前提到的 GC 工作，都是指可达性分析）。采用的是标记 - 复制算法，（关于标记 - 复制的内容之前有讲过就不再展开说了）。</p><p>看起来 Serial 收集器没什么特别的，但实际上 Serial 收集器在一些特殊的场景下有着不错的表现，这些要得益于他的额外内存消耗，因为其相比其他收集器要小一些，所以在服务器资源受限的情况下（单核或较少核心以及内存紧张），这个简单的单线程收集器效率还是很可观的。</p><h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><p>关键字：新生代、Stop The World 、标记 - 复制算法、多线程、<strong>绝配</strong></p><p><strong>ParNew</strong> 可以看成 new parallel gc ，一个新的并行垃圾收集器。是一个对标 Serial 的收集器，它与 Serial 的区别就是它在工作的时候是使用多线程进行工作的。还有，它是目前（JDK 9 以后）<strong>唯一一个</strong>能配合 CMS 在新生代工作的垃圾收集器。</p><h4 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h4><p>关键字：新生代、Stop The World、标记 - 复制算法、多线程、可控吞吐量【用户线程执行时间 /（用户线程执行时间+GC线程执行时间）】、<strong>自适应策略</strong></p><p>与 ParNew 相比，Parallel Scavenge 多了一些额外的功能，停顿时间和吞吐量可控（通过参数配置-XX： MaxGCPauseMillis  单位毫秒，控制每次垃圾回收的最大停顿时间。-XX： GCTimeRatio  控制吞吐量 0 - 100 整数，1/(1+设置的参数) = 垃圾收集时间占程序执行的总时间比率。</p><p>对于 Parallel Scavenge 还有一个特点，就是自适应策略，把内存管理工作完全交由虚拟机，通过参数 -XX： +UseAdaptiveSizePolicy  启用自适应内存策略，这样就不需要指定内存参数，比如新生代大小、eden survivor 比例 晋升年龄等参数。虚拟机会根据当前系统运行状态动态的调整，达到一个合适的停顿时间和吞吐量。</p><p>上面这三种 <strong>Serial</strong>  、 <strong>ParNew</strong>  、 <strong>Parallel Scavenge</strong> 都是新生代的垃圾收集器，下面我们来看看老年代的垃圾收集器。</p><h4 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h4><p>关键字：老年代、Stop The World、标记 - 整理算法、单线程、<strong>替补</strong></p><p>Serial Old 是和 Serial 一样的一款收集器，只不过，它是工作在老年代的。换句话说就是 Serial Old 就是 Serial 的老年代版本。Serial Old 有一个特殊的用途就是作为 CMS 并发清除失败的时候的替补，这里后面 CMS 收集器再看。</p><h4 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h4><p>关键字：老年代、Stop The World、标记 - 整理算法、多线程、CP（组合）</p><p>Parallel Old 是一个多线程并行的老年代垃圾收集器。它的出现也是为了解决吞吐量最大化的问题。因为他没出现之前，只有 Serial Old 一款老年代垃圾收集器来配合 Parallel Scavenge ，因为 Serial Old 的单线程性能原因，导致 Parallel Scavenge 吞吐量的优势体现不出来。直到它的出现，它与 Paralle Scavenge 就组成了一对完美的吞吐量 CP。</p><h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><p>关键字：老年代、Stop The World、标记 - 清除算法、多线程、短停顿</p><p>Concurrent Mark Sweep 的设计初衷就是要停顿的时间最短！JDK 5 开始使用，JDK 9 以前最优秀，为啥是 JDK 9 以前最优秀，因为 JDK 9 发布的时候，默认启用了 G1 收集器，同时你如果手动改成 CMS 的话，会受到一个 CMS 被声明为不推荐的警告，下面是它具体的工作过程，一共经历 4 个阶段</p><p>具体步骤如下：</p><ul><li>初始标记：需要 Stop The World<ul><li>标记 GC Roots 直接关联的对象（直达），速度较快，停顿时间短。</li></ul></li><li>并发标记：与用户线程并发<ul><li>进行标记追踪，完成全部对象的标记任务。可能出现漏标或错标情况。</li></ul></li><li>重新标记：需要 Stop The World<ul><li>修正并发标记阶段的对象标记，因为大部分对象不需要修正，所以执行时间相比并发标记时间短，但是停顿时间要比初始标记停顿时间长。</li></ul></li><li>并发清除：与用户线程并发<ul><li>耗时较长，可以与用户线程共同工作。</li></ul></li></ul><p>CMS 虽然有了一个较短的停顿时间，但是也有一些其他随之而来的问题。</p><p><strong>优点：</strong></p><ul><li>并发执行速度快、停顿时间短。这一点没得说，因为它其中有两个阶段是和用户线程并发。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>占用线程资源</strong>，因为 CMS 工作有两个阶段是和用户线程并发，所以这里便会抢占用户线程资源。</li><li><strong>浮动垃圾</strong>，清理一次之后还会有清理不掉的对象，需要在下次清理的时候才能够清理到。这里的原因是因为并发清除阶段是和用户线程并发，一边清除一边使用，可能会出现一些无法清理掉的新生垃圾，比如清理过程中，程序断开了某个引用，被断开的引用 GC Roots 不可达，所以这个被断开的引用指向的对象变成了浮动垃圾。</li><li><strong>空间利用率低</strong>，因为并发清理的原因，所以不能等到内存完全用完之后再做清理，所以需要当内存使用达到一定阈值（默认值68%，JDK6的时候提高到了 92%）时就开始进行垃圾回收动作，具体数值可以通过参数控制。这里 JVM 给了风险预案：冻结用户线程，启动 serial old 来进行一次老年代垃圾回收。这也是上面我们说 Serial Old 的时候，提到他的关键字里有 “替补” 的原因。</li><li><strong>空间碎片</strong>，因为使用标记-清除算法的原因，会导致碎片空间的产生。CMS 的做法是在其不能够满足对象分配任务的时候，FULL GC 的时候，会进行一次空间整理的动作。对这个整理的动作也是有参数可以进行控制，参数设置情况为，满足几次FullGC之后，进行一次空间整理，默认值为 0 ，即每次 full gc 都会进行一次空间整理。这一点虽然是缺点，不过 CMS 已经尽力去你补了，包括这里的 FULL GC 之后的内存空间整理，还有对象分配时 CMS 会在 Free List 申请一块较大的内存空间，然后通过指针碰撞的方式来进行对象分配，尽可能减小空间碎片的产生。空间碎片问题也是 CMS 不能直接使用指针碰撞的方式来为对象分配内存的原因。</li></ul><h4 id="Garbage-First-（G1）"><a href="#Garbage-First-（G1）" class="headerlink" title="Garbage First （G1）"></a>Garbage First （G1）</h4><p>关键字：里程碑、JDK 9、区域管理、按需回收、<strong>延迟可控的最高吞吐量</strong></p><p>要说 CMS 是一个划时代收集器，那 G1 可以称得上划时代的划时代收集器，其作为 JVM 的垃圾收集器的里程碑是有一定原因的，我们继续往下看。G1 出现的原因也很简单，那就是替换掉 CMS 。G1的设计是颠覆性的设计思路，它跳出了内存一定要划分新生代老年代的这个枷锁，它的工作模式为 Mixed Mode。并且 JDK 9 的时候开始启用，成为了服务端模式下的默认垃圾收集器，替换掉了原来的吞吐量组合（Parallel Scavenge + Parallel Old），同时 CMS 被声明为不推荐使用，CMS 也是从JDK 9 开始准备退役。按需回收说的是 G1 在做清理的时候，是依据一个<strong>可预测停顿时间模型</strong>来做的，这是个什么东西呢？简单来说就是，在清理之前，G1 对每个待回收的区域根据回收价值和时间进行排序，然后根据用户所期望的停顿时间来做一个最优回收，后面会继续说。</p><blockquote><p>多了解一点，关于 G1 的工作模式，Mixed Mode  的扩展：G1 有纯 GC 模式和分代回收模式，分代模式会分为 Minor GC 和 Mixed GC 两种，这里的模式选择会影响最后的筛选回收阶段的回收集合的内容。这块内容可参考后面留的 R大 的链接</p></blockquote><p>上面有一点展开说一下，就是 G1 不是没有这分代这种操作了吗？是通过内存区域来管理垃圾的，但是事实上 G1 将内存分成多个大小相等的 Region（区域） ，这些 Region 都可以作为Eden、Survivor、Humongous（Humongous 同老年代的作用）。</p><p>下面我们一起了解一下 G1 工作的具体步骤：</p><ul><li><p>初始标记：Stop The World</p><ul><li>标记 GC Roots 直接关联的对象，同时修改 <strong>TAMS</strong> 指针</li></ul></li><li><p>并发标记：与用户线程并发</p><ul><li>标记全部要回收的对象，与用户线程并发，标记完成之后，重新处理 <strong>SATB</strong> 记录下在并发时有引用变动的对象</li></ul></li><li><p>最终标记：Stop The World</p><ul><li>处理并发标记阶段 SATB 遗留的引用，同时这个阶段也进行弱引用处理。</li></ul></li><li><p>筛选回收：Stop The World</p><ul><li><p>这个阶段会更新 Region 的统计数据，对每个 Region 根据其回收价值和成本进行排序，然后根据用户所期望的停顿时间（参数设置）来制定一个回收计划。再根据这个计划，选择任意 Region 来组成一个回收集（collection set）。将回收集中的 Region（被选中的区域） 中的存活对象复制到空的 Region 中，然后将旧的（选中的） Region 清理掉。</p><p><em>以上过程由多线程并行完成，同时因为移动对象需要暂停用户线程（Stop The World）</em></p></li></ul></li></ul><blockquote><p>TAMS：Top at Mark Start   Region 中的两个指针名称，他们的作用是将 Region 的一部分空间划分出来给并发回收过程中程序运行产生的新对象使用</p><p>SATB：原始快照，还记得之前我们对漏标的解决方案吗？一种是增量更新（CMS 采用的这种方案），另外一个就是原始快照，这里可以翻翻之前的内容。</p></blockquote><p>G1除了并发标记阶段都需要暂停用户线程</p><p>G1的理想目标：在延迟可控的情况下达到最大的吞吐量</p><p>用户可以通过参数设置所期望的停顿时间，这个时间一般建议设置为 100 ~ 300 ms。</p><h4 id="垃圾收集器小结"><a href="#垃圾收集器小结" class="headerlink" title="垃圾收集器小结"></a>垃圾收集器小结</h4><p>上面一共说了 7 款垃圾收集器，不过他们的具体使用我觉得有必要了解一下。</p><p><strong>按照年代划分</strong></p><p>新生代：Serial 、ParNew、Parallel Scavenge</p><p>老年代：Serial Old、Parallel Old、CMS</p><p>内存区域：G1</p><p><strong>搭配组合</strong></p><p>因为不同的阶段，垃圾收集器之间的搭配不同，所以我们就按照 JDK 9 作为划分界线，来看下 JDK 9 前后的搭配情况</p><p><strong>JDK 9 以前</strong></p><p><img src="https://i.loli.net/2021/01/01/OdRybzt4MJefsoC.png" alt="JVM-JDK9之前"></p><p><strong>JDK 9 之后</strong></p><p><img src="https://i.loli.net/2021/01/01/QshYcn19xkyN4q3.png" alt="JVM-JDK9以后"></p><p>通过搭配关系我们可以看出，JDK 9 以前，Hotspot 提供了多种选择，而且场面看起来很和谐，解释一下 CMS 与 Serial Old 之间的虚线，这代表 CMS 并发清除失败的时候，以 Serial Old 作为备选方案的组合。</p><p>JDK 9 之后，因为 G1 的出现，hotspot 取消了两种方案的支持（Serial + CMS 和 ParNew + CMS），仅提供了 4 种虚拟机搭配方案，他们分别是</p><ul><li>Serial + Serial Old  的单线程组合，适用于资源受限的场景。</li><li>ParNew + CMS 这组曾经的王者组合，新生代的多线程并行高性能加上老年代的短暂停顿组合，可以应对大部分场景。</li><li>Parallel Scavenge + Serial Old 这是 Paralle Old 没出现的时候的应对组合（不明白为何 JDK 9 的时候没取消这对奇葩组合）</li><li>Parallel Scavenge + Parallel Old 这对高吞吐量 CP</li></ul><p>看起来这 4 组搭配很完美，不过因为 G1 的出现，<em>看起来的美好也没那么好了</em> G1在 server 模式下取代了高吞吐量的 CP （Parallel Scavenge + Parallel Old）成为了默认的垃圾收集器，同时在 JDK 9 使用 ParNew + CMS 这组搭配时，还会收到来自 hotspot 的警告，CMS 已经被声明为不推荐使用，因为 ParNew 此时只能与 CMS 搭配使用，所以可以说当时 CMS 拯救了 ParNew 的尴尬局面（当时新生代高性能的 ParNew 只能选择拖后腿的 Serial Old 一起工作），现在 ParNew 也要陪着 CMS 一起下岗了。综上所述，JDK 9 还剩下建议使用的组合</p><ul><li>G1</li><li>Serial + Serial Old</li><li>Parallel Scavenge + Serial Old （还是它，我一定要关注它俩啥时候下岗）</li></ul><p>所以通过上面的分析，也能看出来 HotSpot 的用意，在 JDK 9 以后就是要将 G1 作为一个全能型的垃圾收集器来发展。</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>上面总结了截止 JDK 9 的垃圾收集器内容，其实对于垃圾收集器还有很多内容，比如 Shenandoah ，一个由 Red Hat 开发的低延迟垃圾收集器，还有 Oracle 后面的 ZGC。这两个垃圾收集器都采用了更加优秀的思想和实现方案。不过因为我没有对其深入的了解，所以在这就不再多说了。如果你对垃圾收集器的具体算法仍感兴趣，推荐访问下面这个链接，R大 写的虚拟机相关内容</p><p><a href="https://www.iteye.com/blog/rednaxelafx-362738">https://www.iteye.com/blog/rednaxelafx-362738</a></p>]]></content>
    
    
    <summary type="html">难道是它们？</summary>
    
    
    
    <category term="虚拟机" scheme="http://lvgo.org/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="虚拟机" scheme="http://lvgo.org/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>天天听人家说的 GC 到底是个啥？</title>
    <link href="http://lvgo.org/post/lvgo-jvm-06.html"/>
    <id>http://lvgo.org/post/lvgo-jvm-06.html</id>
    <published>2020-12-27T12:45:47.000Z</published>
    <updated>2020-12-27T12:45:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/12/27/okDzWcqyAlr9mR6.png" alt="啥是 GC"></p><blockquote><p>其实首先我觉得怎么着自己肯定都扫过盲 “Garbage Collection” 垃圾收集。接着你就要去看我们前几天刚学完的几篇内容了。有了那些个基础再看 GC 才能更有价值，不然这篇对你来说，还只是个扫盲文章。</p></blockquote><p>目录：</p><ol><li>根结点枚举</li><li>安全点<ul><li>啥是安全点？</li><li>安全点在哪？</li><li>怎么到达安全点？</li><li>安全区域又是啥？</li></ul></li><li>啥是记忆集？</li><li>卡表是啥？</li><li>啥是写屏障？</li><li>虚共享又是啥？</li><li>三色标记你应该是知道了，来看看它的一个严重问题吧。</li></ol><h2 id="垃圾收集器的具体实现"><a href="#垃圾收集器的具体实现" class="headerlink" title="垃圾收集器的具体实现"></a>垃圾收集器的具体实现</h2><blockquote><p>这部分的内容，笔者点到为止，觉得看的不爽的欢迎进群一起讨论。因为不确定的东西我不能写出来误导别人，要做一个将笔德的作者。</p></blockquote><p>此时我正站在周老师的肩上高歌 ”HotSpot 是这么实现的垃圾收集器！“</p><h3 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h3><p>通过上一篇的内容我们知道了一些可以固定作为 GC Roots 的内容，他们包括静态变量、常量、方法运行时上下文。我们也知道了可达性分析算法 <em>（这里如果不清楚的请参考笔者前两篇文章内容）</em> 。不过运行时这么多引用，全部都扫描一遍这啥虚拟机也受不了啊，GC 2秒钟，扫描8小时啊。</p><p>所以就有了第一阶段的根结点枚举，这一步就是直接扫描与 GC Roots 直接相关的那部分内容。这一步的操作需要 “Stop The World”（Stop The World 就是用来形容在安全点用户线程暂停的这种状态的一个叫法，关于安全点接下来就会提到）。</p><p>可达性分析时，并不会全部的挨个扫描执行上下文和全局引用。在 HotSpot 中，有一个叫做 OopMap 的数据结构，专门存放着引用信息，这个普通对象指针是在类加载和即时编译时分别将全局引用和执行上下文<strong>特定</strong>的相关位置记录下来的。 （这地方与后面的内容有关，记一下）</p><blockquote><p>OopMap（ Ordinary Object Pointer）  点到为止，这部分内容可以根据代码的编译结果看到，感兴趣的可以研究研究。图片来自《深入理解 Java 虚拟机》3.4.1 代码清单 3-3</p><p><img src="https://i.loli.net/2020/12/27/AmY8cHEMjNKWJ5r.png" alt="OopMap"></p></blockquote><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>通过上面我们知道 GC 要做的事是通过 OopMap 找出来那些被引用的对象，而这个 OopMap 里面存了两种数据，一部分是全局引用，这好说，类加载的时候怼上，不会变了。那执行上下文怎么办？那一个个方法的调用，一个个栈帧，栈帧里又那么多变量 <em>（这部分内容在前面已经学过了，如果不清楚可以回到前面文章复习）</em> 。如果把全部的字节码指令全部都存下来那不疯了？所以 hotspot 没疯，它只存了一些特定的位置把这个信息记到 OopMap 中。在程序执行过程中会有多个这样的特定位置，这些特定的位置就被称为 <strong>安全点</strong> 。</p><h4 id="在安全点才能-GC"><a href="#在安全点才能-GC" class="headerlink" title="在安全点才能 GC"></a>在安全点才能 GC</h4><p>有了安全点我们就应该知道了，GC 不是任何时候都能做的。必须要等到程序到达安全点之后才能做。为啥应该不难理解吧，两个安全点之间如果你执行了 GC ，是不是会导致一部分执行上下文相关的引用你不知道，因为 OopMap 里面只存了最近一个安全点内的指令内容。</p><h4 id="安全点在哪"><a href="#安全点在哪" class="headerlink" title="安全点在哪"></a>安全点在哪</h4><p>明白了这个必须等到安全点才能 GC 之后，又有新的问题了，（ GC 做一次真是太难了）你说这个安全点，你放多少个合适，间隔又要多少才合理，放远了吧，半天半天不能做一次 GC ，放近了吧倒是随时想做就能做，但是你要知道这个安全点也是一条指令啊，那插入那么多额外的指令到程序中你觉得合适吗？而且这玩应也要存储啊不是 OopMap 了解一下。于是 hotspot 的开发者就研究。最后来有了一个比较银杏的解决办法。</p><p>因为一般指令执行的时间很短，所以这个解决办法就是，在一些长时间执行的部分给它怼一个安全点，防止程序长时间执行我没办法 GC ，根据长时间执行的特征，有些地方就显而易见的被选出来祭天了，它们是 <code>方法调用</code> 、<code>循环回边处</code> 、<code>异常跳转</code></p><h4 id="怎么到达安全点"><a href="#怎么到达安全点" class="headerlink" title="怎么到达安全点"></a>怎么到达安全点</h4><p>现在我们知道了 GC 需要通过 OopMap 找到 GC Roots 中的相关引用，又知道了要在安全点的时候暂停的时候开始找这些引用，但又有问题了，我知道 GC 要在线程执行到安全点的时候暂停，可怎么才能让每一个线程到达最近的安全点上，并且暂停呢？</p><p>两种办法，虚拟机强行等你到安全点，还有一种就全凭自觉。</p><p>什么叫虚拟机强行等你到安全点呢，他还有个名字叫 <strong>Preemptive Suspension</strong>，就是 <code>先发制人</code>（抢先式中断） 。虚拟机直接中断用户线程，然后看你到没到安全点，没到继续跑，然后在中断。再看再跑再看再跑，直到全部线程都到达安全点，over 任务完成。</p><p>相比虚拟机怼我到安全点，我还不如自觉点  **Voluntary Suspension  ** <code>主动式中断</code> 。虚拟机会发出一个安全点集合信号，所有线程轮询这个集合信号，一旦信号为真时，当前线程会在最近的一个安全点到达时挂起。</p><p>人生苦短，我选自觉。现在大部分虚拟机都是选的自觉方式来到达安全点。毕竟先发制人太不讲武德了。</p><blockquote><p>点到为止内容，就是线程的这个轮询操作的实现。因为需要频繁执行，且高效。HotSpot 只使用了一条汇编指令实现了这个操作。</p><p><code>test %eax,0x160100</code> 当需要暂停用户线程时， 虚拟机把0x160100的内存页设置为不可读， 那线程执行到test指令时就会产生一个自陷异常信号， 然后在预先注册的异常处理器中挂起线程实现等待。</p></blockquote><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>这部分可以算是安全点的扩展，因为程序执行过程中，不能保证线程全部都在运行状态，或等待或阻塞等等，所以就有了安全区域的概念，这部分区域内容标志着在这个区域中，对象的引用关系不会发生改变。不会影响 GC 正常进行，当用户线程执行到安全区域后会标志自己现在在安全区域， GC 不要管我，等到用户线程从安全区域出来的时候要和 GC 打招呼，“GC 你完事了吗？我要出来了” 如果这个时候没有 GC 动作，那你就可以出来了，如果这个时候在 根结点枚举 阶段，或在收集过程需要用户线程暂停的阶段，那么用户线程就需要等待，知道 GC 结束才能从安全区域出来。</p><h3 id="记忆集（Remembered-Set）"><a href="#记忆集（Remembered-Set）" class="headerlink" title="记忆集（Remembered Set）"></a>记忆集（Remembered Set）</h3><p>上面的 GC 过程，在只有新生代内存被使用，老年代没有使用的时候还是没问题的，但是一旦出现之前文章提到过的跨代引用问题，就需要考虑了，跨代引用是指老年代中存在引用新生代对象的指针。为了解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集（Remembered Set）的数据结构，一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。这个在后面不光用在了这种只有新生代和老年代的收集器中，后面的区域收集器也会用到。</p><blockquote><p>区域收集器指的是 G1 ，ZGC 还有 Shenandoah收集器这种。</p></blockquote><h3 id="卡表（Card-Table）"><a href="#卡表（Card-Table）" class="headerlink" title="卡表（Card Table）"></a>卡表（Card Table）</h3><p>有了记忆集的概念之后，就考虑怎么保存含有跨代引用的信息，可以将有跨代引用的对象全部保存下来，但是这样做太占内存，而且维护起来也不方便。于是有一种较好的记录方案，就是按区域划分内存，将有跨代引用的那部分内存区域记录下来，这种实现方式称为 “卡表”。</p><p>HotSpot 将整个堆划分为一个个大小为 512 字节的卡页，维护成一个卡表，每个卡表的大小默认为 1 个字节用来存储每张卡的一个标识位0或者1。这个标识位代表对应的卡<strong>是否可能存有指向新生代对象的引用</strong>。如果可能存在，那么这张卡就是 <strong>脏卡</strong>。在 GC 的时候，只需要筛选脏卡对应内存区域中的对象就好了，不需要扫描全部的对象。</p><blockquote><p>注意不要搞混记忆集与卡表的概念，一个是定义的数据结构，另一个是具体的实现方法。</p></blockquote><h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>知道了用卡表来解决跨代或跨内存区域的问题，当某个卡页可能存在跨代引用时就会变脏，那这个变脏的过程是怎么样的呢？又是怎么实现的呢？</p><p>正常情况下，卡表变脏的时机是当前区域中的对象中，引用了其他区域的对象，此时更新这张表为脏表。如果解释执行，一条条执行下去可以，虚拟机可以根据变量赋值的指令来判断，进行相应的操作，但是在即时编译过程中，这个就需要一些对应的机器指令操作了。在HotSpot虚拟机里是通过写屏障（Write Barrier）技术来维护卡表状态的。<strong>与 volatile 的重排序屏障指令不同！！！</strong></p><p>这个写屏障的具体实现分为两个，一个叫做写前屏障，一个叫做写后屏障。他们的操作类似 AOP ，他们可以在一个变量赋值操作前后做出一个通知。在 hotspot 中大多使用了写后屏障。这样就可以在变量赋值操作之后，将其对应的卡表更新为脏表。</p><h3 id="虚共享"><a href="#虚共享" class="headerlink" title="虚共享"></a>虚共享</h3><p>写屏障带来了一个问题，这个问题是由 CPU 引起的，现在的 CPU 缓存中都是有一个个缓冲行保存的数据，在多核处理器的情况下，可能存在多个线程共享一个缓冲行的情况，比如一个缓冲行的大小是 32 kb，那么一张存有 64 张卡页的卡表（64 * 512字节）就有可能在同一个缓冲行上面。为了解决多个线程同时更新同一个缓冲行浪费的性能开销。hotspot 在更新卡表状态时，加入了一个当前卡表是否为脏表的判断，如果是脏表就不再进行更新操作。</p><blockquote><p>在JDK 7之后，HotSpot虚拟机增加了一个新的参数-XX：+UseCondCardMark，用来决定是否开启卡表更新的条件判断。开启会增加一次额外判断的开销，但能够避免伪共享问题，两者各有性能损耗，是否打开要根据应用实际运行情况来进行测试权衡。</p></blockquote><h3 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h3><p>上面已经对整个垃圾回收过程涉及的细节过了一遍，接下来就要看看其中的重头戏，可达性分析算法了，也就是上面一直说的扫描扫描的内各。</p><p>我们知道可达性分析算法是需要暂停用户线程才能够使用，就是需要 Stop The World ，根结点枚举这一步的暂停时间虽然很短，但是还是要暂停的，同时这个暂停的时候会随着系统的对象的增长而增长，程正比关系。</p><h4 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h4><p>可达性分析算法的描述目前都是采用三色标记来辅助理解的。</p><blockquote><p>希望这块的内容能够和之前的 finalize 方法联系起来，还记得之前文章中我们提到的自己救自己一次的那个地方吗，待会可以倒过去看一看，这可以帮助你加深这块的理解，当然也只有我才会给你说这么细的提醒</p></blockquote><ul><li>白色：死亡的颜色，即没有引用的对象。只会发生在 GC 开始标记工作之前（还没开始标记，大家都是白色），和 GC 工作之后（标记完了，就你是白色）</li><li>黑色：GC 已经开始工作到过这里，而且确认这个节点存活，其存在有效的引用，即这个对象的引用也全都扫描过。被黑色节点引用的对象一定可以活下来。可达性分析算法对已经是黑色的节点，不会在进行扫描（重要，后面理解三色标记的问题会用到）</li><li>灰色：GC 已经开始工作到过这里，但这个对象上至少还有一个引用没有扫描。</li></ul><h4 id="并发标记的问题"><a href="#并发标记的问题" class="headerlink" title="并发标记的问题"></a>并发标记的问题</h4><blockquote><p>周老师《深入理解 Java 虚拟机》（第三版）3.4.6插图</p><p>此例子中的图片引用了Aleksey Shipilev在DEVOXX 2017上的主题演讲：《Shenandoah GC Part I：The Garbage Collector That Could》。</p></blockquote><p><img src="https://i.loli.net/2020/12/27/ra2CyMjoImEqRVx.jpg" alt="标记示意图"></p><p>上图最后两个情况说明了在并发阶段的标记问题。因为并发标记是指 GC 的工作线程与用户线程并发执行，所以就会出现一边标记一边改变对象引用的情况。</p><p>并发标记会出现两类问题，一类是漏标，一类是误标。漏标是指某个应该为白色的对象没有被标记成白色，这种问题一般不会有太大影响。最多浪费一部分内存在下一次 GC 时将其再次标记回收。而另一类问题就是误标。这两个问题在上图的最后两个里面可以体现出来。</p><p>误标的危害是很严重的，如果一个正在引用的对象，被误标记成了白色。那么 GC 结束之后这个对象被清除，可能直接导致系统崩溃。</p><p>这个问题的出现原因有被证实过，当且仅当满足以下两点时才会出现误标的情况</p><ol><li>赋值器插入一条以上由黑色节点指向白色节点的引用</li><li>赋值器删除了灰色节点直接或间接到达白色节点的全部引用</li></ol><p>通过这两个情况，我们也不难理解误标的产生，因为黑色节点的规则是不会在扫描，而灰色则是会再进行扫描。所以对应的解决办法也比较清晰，只需要不要让以上两个条件同时满足即可。HotSpot 针对以上两点分别使用了<strong>增量更新</strong>和<strong>原始快照</strong>两种解决方案。</p><p>增量更新的意思是指，如果一个引用关系是从黑色节点指向白色节点，那么就需要在并发标记结束对这些个黑色节点作为根节点，重新进行扫描，即黑色节点发生新的引用关系后，其会变成灰色节点。（CMS 收集器中的重新标记使用的这种方案）</p><p>原始快照指的是，如果一个灰色节点删除了指向白色节点的引用，那么需要将这个删除的引用记录下来，在并发标记结束对这个记录的引用关系中灰色节点作为根结点重新扫描。无论这个对象是否删除了，都会重新再扫描一次。（G1 的最终标记使用的这种方案）</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我相信，你现在对 GC 已经不再陌生了吧，至少我不陌生了，我们在一起回顾一下这篇文章的内容。</p><p>上来我们就先介绍了一下 <strong>GC 的概念</strong>，接着我们说到了 GC 开始阶段是需要通过 Stop The World 做一次根结点直达的扫描过程，这个扫描过程是有 <strong>OopMap</strong> 的加持，所以不会扫描全部的具体对象。</p><p>随之我们又通过 OopMap 引出了<strong>安全点</strong>和<strong>安全区域</strong>的概念，安全点是为了帮助 GC 完成停顿这个步骤，而且其是靠插入指令代码来完成的，为了权衡 GC 时间和指令的开销，一般是在 <code>方法调用、循环回边处、异常抛出</code> 的特殊位置来插入安全点指令。</p><p>接着线程在安全点是如何暂停的，我们了解到了先发制人（<strong>抢先式</strong>）和主动式中断两种方式，hotspot 选择的是主动式主动，由线程自己挂起来完成暂停操作。</p><p>之后我们由跨代引用问题知道了<strong>记忆集</strong>的概念以及 hotspot 中记忆集的实现，<strong>卡表</strong>，的一些内容。为了维护卡表的状态，何时变脏，我们又一次的学习了新的内容 <strong>写屏障</strong>，而写屏障在当代的CPU中又存在一个<strong>虚共享</strong>问题，接着我们知道了HotSpot 是使用条件判断来规避这个问题的。</p><p>最后我与你分享了GC在扫描过程中的并发问题，以及在不同收集器中的解决方案。如果你对这篇文章内容有什么问题，或者不清楚有异议的地方欢迎关注或者加我微信为我指出。（lvgocc）</p><p>（正文完）</p><hr><p>如果觉得写的还不错，欢迎关注催更收藏点赞转发推荐给更多的人，如果想一起系统学习的话，非常欢迎加群一起讨论学习。下一篇是 hotspot 中所使用的各种垃圾收集器的内容，其中会对 <strong>CMS</strong> 和 <strong>G1</strong>着重说明，记得关注可以第一时间收到推文。</p>]]></content>
    
    
    <summary type="html">首先我觉得应该先查查这个缩写什么意思</summary>
    
    
    
    <category term="虚拟机" scheme="http://lvgo.org/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="虚拟机" scheme="http://lvgo.org/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>JVM 把内存”收“回来用的是什么法器</title>
    <link href="http://lvgo.org/post/lvgo-jvm-05.html"/>
    <id>http://lvgo.org/post/lvgo-jvm-05.html</id>
    <published>2020-12-26T10:55:56.000Z</published>
    <updated>2020-12-26T10:55:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/12/26/3TyocWXgxpJv78L.png" alt="垃圾收集"></p><blockquote><p>上一篇我们知道了内存回收是指那些在堆或方法区中不在引用或使用的对象被回收掉，以保证后面的对象能够顺利的被分配。但是随之出现一个问题，就是虚拟机是怎么知道某个对象不使用了呢？今天就一起来看看虚拟机是怎么来判断一个对象是否存活的。</p></blockquote><h2 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h2><ol><li>垃圾收集算法分类</li><li>分代收集的概念</li><li>主流 JVM 中的回收算法</li></ol><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>垃圾收集算法可以从如何判断对象消亡分为两类</p><ol><li>引用计数式垃圾收集（Reference Counting GC）</li><li>追踪式垃圾收集（Tracing GC）</li></ol><p>在主流的 JVM 中，使用的是第二种 <code>追踪式垃圾收集</code> 算法。</p><blockquote><p>更多内容推荐阅读Richard Jones撰写的《垃圾回收算法手册》的第2～4章的相关内容。</p></blockquote><p><em>多学一点：大多 JVM 不使用第一种方式的原因是因为引用计数的办法会导致两个对象在互相引用时，计数器的值均不为零，从而导致内存回收出现问题，进而导致内存泄漏。</em></p><h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3><p>因为大部分对象都是短暂存活后就死亡了，所以根据每次 GC 对对象进行年龄的划分来区别对待。</p><p>根据理论和实践数据，“垃圾们” 被分为了两个年龄阶段</p><ul><li>新生代</li><li>老年代</li></ul><p>对于不同区域的内存回收（部分收集 <strong>Partial GC</strong>）， GC 也因此分为了</p><ul><li>MinorGC（Young GC）新生代的垃圾收集。</li><li>Major GC（Old GC CMS独有）老年代的垃圾收集。</li><li>Mixed GC（G1中独有）收集整个新生代以及部分老年代的垃圾收集。</li><li>Full GC（收集整个Java堆和方法区的垃圾收集。）</li></ul><p><strong>这里要知道，分代收集的思想不是凭空出现，而是根据理论是实践之后的数据得出</strong></p><blockquote><p>对于理论和实践的内容补充，理论这一块，最早的时候，人们认为，大部分对象存在很短的一段时间就会消失，这就是弱分代假说。而与之对应的强分代假说就是如果一个对象经过多次 GC 之后仍然存活，那就认为其很难消亡。事实上这一块不只一方拿出来实际的数据，这里包括个人或组织，其中业内具有影响力的 IBM 曾经公布一个数据，98% 的新对象会在第一次 GC 被回收掉。</p></blockquote><p><em>多学一点：在强弱分代假说的基础上，引申出一个新的假说，就是跨代引用假说。比如一个新生代对象被老年代所引用，那么你便不得不去在每次新生代 GC （minor gc）时去扫描全部的老年代对象。基于这个问题提出了记忆集与卡表的概念，这个数据结构专门用来表示老年代的数据区域，在（minor gc）时会只会扫描某个数据区域内的老年代对象即可。（关于这部分内容因为涉及垃圾回收器的实现细节，所以本篇暂不过多讨论，后续会专门整理一篇关于虚拟机垃圾回收实现细节的内容，欢迎关注催更）</em></p><h3 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h3><p>上面我们知道虚拟机对内存进行的不同的区域划分，于是针对不同的区域也拥有了不同的处理方法。</p><p><strong>“标记-清除算法”</strong>   <strong>“标记-复制算法”</strong> <strong>“标记-整理算法”</strong> 。</p><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>分为两步，首先通过可达性分析将需要清理的对象标记出来，之后将其清除。</p><p>不过这种方式的缺点很明显，有两个：</p><ol><li>当对象过多时需要遍历的量变多。</li><li>这种方式会产生大量碎片空间。</li></ol><blockquote><p>图片来自周志明《深入理解 Java 虚拟机（第三版）》3.3.2 标记-清除算法</p></blockquote><p><img src="https://i.loli.net/2020/12/26/ZdAqrjtYV6Fv5gi.jpg" alt="标记-清除"></p><h4 id="标记-复制算法-（新生代）"><a href="#标记-复制算法-（新生代）" class="headerlink" title="标记-复制算法 （新生代）"></a>标记-复制算法 （新生代）</h4><blockquote><p>图片来自周志明《深入理解 Java 虚拟机（第三版）》3.3.3 标记-复制算法</p></blockquote><p>这种算法将新生代直接一份为二，每次只使用一半，一面用完以后，将存活的对象复制到另外一半空间上去，将当前空间全部清除</p><p><img src="https://i.loli.net/2020/12/26/ceU9bP4BaXnAEpK.jpg" alt="标记-复制"></p><p>不过这种方式导致空间利用率低下，并且上面我们也提过有实践证明大部分对象在第一次 GC 会被回收掉，<em>数据验证大部分对象会在新生代被回收，这个数值由 IBM 量化，98%的对象会被回收</em>， 所以 hotspot 采用了使用一个 <code>Eden</code> 和两块 <code>Survivor</code> ，默认比 8:1，这样即只有 10% 的空间留着复制备用，大大提高了 <strong>标记-复制</strong> 算法的可用性。这种划分方式成为 Appel 式回收</p><blockquote><p>多学一点：Appel 式回收还有一个分配担保，即复制到备用的 <em>Survivor</em> 上时空间不够，此时内存将在 <strong>老年代</strong> 完成分配。</p></blockquote><h4 id="标记-整理算法（老年代）"><a href="#标记-整理算法（老年代）" class="headerlink" title="标记-整理算法（老年代）"></a>标记-整理算法（老年代）</h4><p><em>关于这个算法的名字有的叫标记-复制，有的叫标记-整理，这个不要纠结，只是个名字，明白其中的思想就可以了</em></p><blockquote><p>在新生代因为存活的对象很少，即需要复制的对象较小，使用  <strong>标记-复制</strong> 算法可以很高效的解决垃圾收集这件事，不过在老年代因为对象大多存活时间较长，同时这种降低空间利用率的方法在这里便没那么好用了。</p></blockquote><p><strong>标记-整理</strong> 算法在 <strong>标记-清除</strong> 算法的基础上加入了移动操作，标记步骤相同，之后 <strong>标记-整理</strong> 算法会将存活对象向一端移动，直到没有存活对象为止，之后在分界处将内存回收掉。</p><blockquote><p>图片来自周志明《深入理解 Java 虚拟机（第三版）》3.3.4 标记-整理算法</p></blockquote><p><img src="https://i.loli.net/2020/12/26/TKzXrLIC5EShmyi.jpg" alt="标记-整理"></p><p>对于 <strong>标记-整理</strong> 算法中的移动操作，有需要取舍的地方</p><p><strong>移动：</strong></p><p>程序停顿与更新对象引用影响程序的吞吐量</p><p>内存移动操作需要暂停用户线程，设计者称其为 “ Stop The World ” ，并且移动存活对象后，对于的对象引用地址需要进行更新（这里的关联知识点就是对象的访问方式，会影响到通过 <code>直接访问</code> 这种方式。使用 <code>句柄</code> 访问的方式不受对象内存位置移动影响）</p><blockquote><p>在 Java 虚拟机里，传统的垃圾回收算法采用的是一种简单粗暴的方式，那便是 Stop-the-world，停止其他非垃圾回收线程的工作，直到完成垃圾回收。这也就造成了垃圾回收所谓的暂停时间（GC pause）。—— 郑雨迪极客时间专栏《深入拆解Java虚拟机》11|垃圾回收（上）</p></blockquote><p>(如果你玩过守望先锋的话)</p><p><img src="https://i.loli.net/2020/12/26/iy1Ppe5jFlz6VfO.jpg" alt="在这停顿"></p><p><strong>不移动：</strong></p><p>链式内存存储影响程序的延迟</p><p>在大量的内存碎片产生后，导致内存通过链式存储的方式来保存对象。这将加大对象的存储和访问开销。</p><p><strong>抉择</strong></p><p>基于以上两种影响，不同的垃圾回收器选择了不同的实现方法。</p><p>在 <strong>hotspot</strong> 虚拟机中关注吞吐量的<strong>Parallel Scavenge收集器是基于标记-整理算法</strong>的，而关注延迟的<strong>CMS收集器则是基于标记-清除算法</strong>的</p><p><em>多学一点：CMS 虽然使用了 <strong>标记-清除算法</strong> 但在其碎片化程度较高时（影响对象分配内存）会进行一次 <strong>标记-整理</strong>。而且 CMS 还有一个特点，不知道你还记得不，在之前我们一起学的对象咋创建的那篇文章，提到了指针碰撞（加法）这种内存分配方式，而这种方式只能在堆空间规整的前提下才能使用，显然 CMS 的标记-清除策略不能够直接使用，所以 CMS 在实现细节上，他在空闲列表上申请内存时，会申请一块较大的空间，然后在这块‘属于自己’的内存空间上在进行造作（指针碰撞）。</em></p><blockquote><p>另外，还有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。前面提到的基于标记-清除算法的CMS收集器面临空间碎片过多时采用的就是这种处理办法。</p><p>—— 周志明《深入理解 Java 虚拟机（第三版）》3.3.4 标记-整理算法</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>简单总结一下前面几篇文章的主要内容：</p><p>开篇的《<a href="http://mp.weixin.qq.com/s?__biz=MzU2MjM2NDU1Mw==&mid=2247485217&idx=1&sn=81fa575d807fcae82bf3fc338a2a02c5&chksm=fc6beec7cb1c67d13af104121d1852929c3107b6f5704d9f101b2af41d4e2f97272f127630e6#rd">JVM 你知道不？一起来学啊</a> 》介绍了一下我们为什么要学习虚拟机，同时对虚拟机内容大纲有所了解</p><p>接着我们通过《<a href="http://mp.weixin.qq.com/s?__biz=MzU2MjM2NDU1Mw==&mid=2247485226&idx=1&sn=5b8ed2e5d06899ff2d7d931f9d964d70&chksm=fc6beecccb1c67da4b405fa8c8c69878958b56d9291bdf8067b4bbf8c137b0194a0cae14e622#rd">你创建的 Java 对象搁哪了</a> 》了解了 Java 程序的运行时数据区域内容。</p><p>知道了具体的内存划分之后，我们急不可耐的想知道《<a href="http://mp.weixin.qq.com/s?__biz=MzU2MjM2NDU1Mw==&mid=2247485249&idx=1&sn=589495ebea994d2ac91110d9bdcf5326&chksm=fc6beea7cb1c67b17258a7da71a36f00b0386b68f7d25d53949ac7de7be5f3f74d3a205e439b#rd">JVM 中对象咋创建啊，又怎么访问啊</a> 》，当我们知道对象怎么创建的之后，就想怎么把分给它的地方要回来，于是我们一起翻开了秘籍《<a href="http://mp.weixin.qq.com/s?__biz=MzU2MjM2NDU1Mw==&mid=2247485257&idx=1&sn=ca53d2e3a29f1a05bcd4b5fd7ec271fc&chksm=fc6beeafcb1c67b9e0b33ea8d59e6d5e9d386f0ef38ef2a3329bb0f1dfabeb5103854a2f2160#rd">JVM 是怎么把“送”出去的内存又“要”回来的</a> 》。</p><p>今天我们又细细的品了品《JVM 把内存”收“回来用的是什么法器》，至此我们已经知道了虚拟机内存管理的大部分内容了，包括内存区域、内存分配、内存回收以及具体的回收法器。接下来的内容就是关于具体的垃圾收集器了。</p><p>（正文完）</p><p>如果觉得写的还不错，欢迎关注催更<strong>收藏、点赞、转发</strong>推荐给更多的人，如果想一起系统学习的话，非常欢迎<strong>加群</strong>一起讨论学习，“我们都是菜鸡，等你来互啄”，让虚拟机知识从此和枯燥乏味说拜拜。</p>]]></content>
    
    
    <summary type="html">在这儿停顿！</summary>
    
    
    
    <category term="虚拟机" scheme="http://lvgo.org/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="虚拟机" scheme="http://lvgo.org/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>JVM 是怎么把“送”出去的内存又“要”回来的</title>
    <link href="http://lvgo.org/post/lvgo-jvm-04.html"/>
    <id>http://lvgo.org/post/lvgo-jvm-04.html</id>
    <published>2020-12-25T15:37:46.000Z</published>
    <updated>2020-12-25T15:37:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/12/25/N5GMHKYy6aFOshl.png" alt="内存回收"></p><blockquote><p>之前我们知道了对象是怎么诞生，然后在内存中安家的，不过对象终归有一天也会“死亡”，那它“死亡”的时候，虚拟机都干了什么呢？又怎么判断一个对象”死“没”死“呢？今天一起学习一下虚拟机是怎么把分配出去的内存，“拿”回来的。</p></blockquote><p>想搞懂内存回收，顺着三个问题往下捋就可以很清楚的梳理好这块内容。</p><h1 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h1><ol><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>怎么回收？</li></ol><h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><blockquote><p>自动收集程序运行产生的“垃圾”，回收这部分内存这种思想并不是起源于 Java ，而是早 Java 30 年的 Lisp 语言<em>（作者：John McCarthy）</em>。</p></blockquote><p>我们也先思考 Lisp 作者对垃圾收集，内存回收提出的三个问题</p><ol><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>怎么回收？</li></ol><h3 id="哪些内存需要回收？"><a href="#哪些内存需要回收？" class="headerlink" title="哪些内存需要回收？"></a>哪些内存需要回收？</h3><p>这里在回顾一下 Java 程序在运行时都有哪些数据区域，如果没跟 lvgo 一起学的同学，可以看看之前的文章 《 你创建的 Java 对象都搁哪了》</p><p>PC寄存器（程序计数器）、本地方法/虚拟机栈、方法区、堆这<strong>五</strong>大区域</p><p>程序计数器、虚拟机栈、本地方法栈3个区域都是线程私有的，他们的产生和消失都随着线程的创建和销毁而变化。</p><p>所以 <strong>堆</strong>、<strong>方法区</strong> 这两块内存区域就是需要进行回收的内存。同时这部分内容和程序运行密切相关，具有不确定性，比如你写了1w个类，但实际只使用1个，那在堆和方法区中也只有1个对象的内存大小的区域被使用。所以需要动态的管理这部分内存。</p><h3 id="什么时候回收？"><a href="#什么时候回收？" class="headerlink" title="什么时候回收？"></a>什么时候回收？</h3><p>在堆中的实例对象，如果想要把这部分内存回收，一定要确定这里所保存的实例对象哪些还在被使用，哪些已经没有用了，即允许回收。</p><p>所以回收的条件就是对象已经没有再被引用了。</p><p><strong>对象引用知识补充</strong></p><p>JDK2的时候，对象的引用只有两种情况</p><ol><li>被引用</li><li>没被引用</li></ol><p>后来有了更多场景的需要，</p><ul><li>如果内存还够用，即使我没被引用，也不要回收我。</li><li>如果已经做了一次回收，还是不够用，那就把没被引用的我回收吧。</li><li>…..</li></ul><p>在这种需求提出后 JDK2之后，Java 补充了对象引用的概念，将引用分为强、软、弱、虚四种。</p><p>了解对象引用概念之前先喝杯咖啡提提神。</p><p><strong>4个不同性格的人喝咖啡</strong></p><p>从前有甲乙丙丁四个人去咖啡厅喝咖啡，这四兄弟吧，不知道咖啡厅的规矩，跟我似的，也没去过啊，不知道。进去了之后这 <strong>甲乙丙丁</strong> 四兄弟就找个位置拿着咖啡在那喝。</p><p>结果不巧今天咖啡厅爆满！服务员就想着找一些喝完不走的人聊聊，把它们聊走，</p><p>也不知怎么的，就盯上这四兄弟了，就过来问 <strong>甲</strong> ：“甲先生，你喝完了吗？今天人有点多，你看看..”，“管谁叫先生呢，我是你大姐！没喝完呢，你看不见呐，不走”。<strong>甲</strong> 很 <strong>强</strong> 势，服务员不敢惹。</p><p>接着他就朝着 <strong>乙</strong> 走过来，他还没说话，<strong>乙</strong> 先开口：“刚你跟我大姐说的我听见了，你看这么的行不行，<strong>你先去找别人，如果你找完别人之后位置还不够，来找老妹儿，老妹儿给你让这个位置</strong> ” ，服务员一看 <strong>乙</strong> 是个 <strong>软</strong> 妹子，就答应她走开了。</p><p>这会儿服务员大哥已经有点累了，想赶快找到新位置出来，不然一会内存溢出了擦，来到 <strong>丁</strong> 面前，“兄弟，今天餐厅位置不够了，你看你让一下子行不行”，说着用手拍着 <strong>丁</strong> 的肩膀，<strong>丁</strong> 一看这架势，有点害怕，赶紧说：“行行行”，服务员一看，这 <strong>丁</strong> 也太 <strong>弱</strong> 了。</p><p>服务员大哥准备乘胜追击来到 <strong>丙</strong> 面前，发现这个 <strong>丙</strong> 有点问题，怎么说呢，就像 <strong>幽灵</strong> 一样若隐若现，完事服务员过去拍了一下他，这不拍不知道，一拍差点裤衩子都吓掉了，这压根就没人，甚至那杯咖啡他都拿不起来，服务员只好瑟瑟发抖的说“这地方我先收拾了啊” 然后就灰溜溜的跑开了，不一会这个位置就给其他客人坐上了。</p><p>大哥找了一会安排了一些人坐下，发现位置还是不够，于是他想起 <strong>乙</strong> 说的话，就过去给 <strong>乙</strong> 说了现在的情况，然后 <strong>乙</strong> 也是个守信用的 <strong>软</strong> 妹子，就收拾东西走开了。</p><p>不过当  <strong>乙</strong> 走开之后，服务员发现还有 1 个顾客没有位置坐！实在没办法了，谁也别喝了，关门吧，人都从咖啡厅里溢出去了。</p><p>所以这个故事告诉了我们什么？</p><p><em>咖啡厅里有鬼</em></p><p>总结一下，甲乙丙丁分别对应的 <strong>强软弱虚</strong> 四种引用类型</p><ul><li><p>甲：强引用（Strongly Re-ference）</p><p>只要我的咖啡（引用）还在，就没人敢动他，很强势。</p></li><li><p>乙：软引用（SoftReference）</p><p>一个讲道理的引用，你先去收拾别的地方，如果你收拾完了地方还不够，我再让我的位置，不然你就让我多待一会</p></li><li><p>丁：弱引用（Weak Reference）</p><p>这个引用的生命只能坚持到诞生之后的第一个 GC 就嗝屁了，来收拾你就得让，管你喝完没喝完。</p></li><li><p>丙：虚引用（Phantom Reference）</p><p>幽灵一般的存在，最弱的一种引用关系，随时可能被回收，你不能用它来获取一个实例，这个引用的作用是为了对象被回收是接到通知。</p></li></ul><p>这4种引用强度依次逐渐减弱。强 &gt; 软 &gt; 弱 &gt; 虚</p><h3 id="怎么回收？"><a href="#怎么回收？" class="headerlink" title="怎么回收？"></a>怎么回收？</h3><h4 id="回收堆内存"><a href="#回收堆内存" class="headerlink" title="回收堆内存"></a>回收堆内存</h4><p>关于判断堆中对象是否存活（被引用）的方法，有两种</p><h5 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h5><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p><p><em>JVM没有采用过这种方式，原因之一就是循环引用问题</em></p><h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><p><em>注：摘自周志明《深入理解 Java 虚拟机（第三版）》3.2.2 可达性分析算法部分</em></p><p>通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p><p><img src="https://i.loli.net/2020/12/25/BpRlN6fIvbqQXH2.jpg" alt="图片来自周志明《深入理解 Java 虚拟机（第三版）》"></p><p>在Java技术体系里面，<strong>固定可作为GC Roots的对象</strong>包括以下几种：</p><ul><li><p>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</p><p>方法执行时相关的数据</p></li><li><p>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</p><p>静态变量</p></li><li><p>在方法区中常量引用的对象，譬如字符串常量池（StringTable）里的引用。</p><p>常量</p></li><li><p>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</p><p>虚拟机本地方法持有的对象</p></li><li><p>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</p></li><li><p>所有被同步锁（synchronized关键字）持有的对象。</p></li><li><p>反映Java虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。</p></li></ul><p><em>除了固定的 GC Roots 以外，这部分集合还会根据选用的垃圾回收器和当前区域的不同，临时增加一些 GC Roots 对象。具体的体现为分代收集和局部回收。</em></p><h5 id="对象真正死亡（即可被回收）"><a href="#对象真正死亡（即可被回收）" class="headerlink" title="对象真正死亡（即可被回收）"></a>对象真正死亡（即可被回收）</h5><p>标记：在可达性分析之后，即使对象被标记为不可达，也不会立即回收掉该对象，而是标记为可回收（笔者自释）。</p><p>标记确认：在已经标记的对象集合中，会进行一次筛选，筛选条件是当前对象是否有必要执行 <code>finalize()</code> 方法。<strong>如果有必要执行则继续 <code>存活</code>，如果没有必要则 <code>死亡</code>。</strong></p><p>判断当前对象是否有必要执行 <code>finalize()</code> 方法的条件（<strong>二次确认对象已死亡</strong>）是</p><ol><li>对象没有重写 <code>finalize()</code> 方法</li><li><code>finalize()</code> 方法已经被执行过一次</li></ol><p>满足以上两个条件的话虚拟机则会认为没有必要执行 <code>finalize()</code> 方法，即对象已死亡。</p><p>如有逃过这次的 <code>死亡</code> 时机，只要当前对象在重写的 <code>finalize()</code> 方法中（一定要在 <code>finalize()</code>方法中，这是唯一一个能<em>拯救</em>自己的机会）与 GC Roots 集合中对象的引用链发生关联，即当前对象再次产生引用关系，即可逃离这次垃圾回收。</p><p>所以实际上，我们可以通过重写 <code>finalize()</code> 来“拯救”一次对象的死亡，也只能拯救一次，因为宣布其真正死亡还有第二个条件，就是 <code>finalize()</code> 方法已经执行过一次。</p><h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p><em>注：以下摘自周志明《深入理解 Java 虚拟机（第三版）》3.2.5 回收方法区</em></p><p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的。</p><p>《Java虚拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载）。</p><p>方法区垃圾收集的“性价比”通常也是比较低的：在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常可以回收70%至99%的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回收成果往往远低于此。</p><p><strong>方法区数据</strong></p><p>方法区中保存的是类信息和运行时常量池两部分内存。</p><p><strong>回收运行时常量池</strong></p><p>运行时常量池的回收比较简单，只需判断当前常量池中的字面量是否有被引用即可。常量池中其他类（接口）、方法、字段的符号引用也与此类似。</p><p><strong>回收类信息</strong>（类卸载）</p><p>判断一个类型信息是否可以被回收需要同时满足以下三个条件，</p><ol><li>该类信息对应的所有实例被回收</li><li>加载该类的加载器被回收</li><li>对应的 <em>java.lang.Class</em> 对象没有在任何地方被引用</li></ol><p>具体内容如下：</p><ol><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li><li>加载该类的类加载器已经被回收，<strong>这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</strong></li><li>该类对应的 <em>java.lang.Class</em> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ol><p><em>多了解一点：</em></p><p><em>其中第三点与我们经常见到的操作诸如 spring 这种大量使用反射的框架、JDK 的动态代理、以及 CG lib 这种操作字节码的框架基本上都需要 JVM 拥有类卸载的功能，否则会导致一些自定义加载器加载的临时类信息占据着方法区的内存，带来不必要的压力。</em></p>]]></content>
    
    
    <summary type="html">哪些内存需要回收？什么时候回收？怎么回收？</summary>
    
    
    
    <category term="虚拟机" scheme="http://lvgo.org/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="虚拟机" scheme="http://lvgo.org/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>JVM 中对象咋创建啊，又怎么访问啊</title>
    <link href="http://lvgo.org/post/lvgo-jvm-03.html"/>
    <id>http://lvgo.org/post/lvgo-jvm-03.html</id>
    <published>2020-12-24T13:51:15.000Z</published>
    <updated>2020-12-24T13:51:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/12/24/NxJUsyce3If1wdh.png" alt="对象的创建与访问"></p><h2 id="JVM-中对象咋创建啊，又怎么访问啊"><a href="#JVM-中对象咋创建啊，又怎么访问啊" class="headerlink" title="JVM 中对象咋创建啊，又怎么访问啊"></a>JVM 中对象咋创建啊，又怎么访问啊</h2><blockquote><p>虚拟机遇到 new 指令，会根据指令参数去常量池找对应类的符号引用，如果没找到会进行类加载，此时会执行类构造器指令<clinit>。类加载完成之后，初始化之前，开始进行对象内存分配，分配好之后将内存区域的值全部置为0（成员变量初始化），之后执行实例构造器指令 <init>，完成后返回对象引用。</p></blockquote><h3 id="对象是怎么完成创建的？"><a href="#对象是怎么完成创建的？" class="headerlink" title="对象是怎么完成创建的？"></a>对象是怎么完成创建的？</h3><p>对象的创建一共有四种方式</p><ul><li>new 关键字</li><li>复制（clone操作）</li><li>序列化（另类操作）</li><li>反射（另类）</li></ul><h4 id="※new-关键字创建普通-java-对象的过程"><a href="#※new-关键字创建普通-java-对象的过程" class="headerlink" title="※new 关键字创建普通 java 对象的过程"></a>※new 关键字创建普通 java 对象的过程</h4><ol><li>在常量池中查找类信息（根据全部限定名），如果没有先进行类加载（后面在虚拟机执行章节中有具体的加载过程笔记），然后检验其是否被初始化（这个初始化是指的类初始化，也就是执行<clinit>）过</li><li>类加载完成确定类的内存大小</li><li>在新生代分配内存</li><li>执行构造函数，返回引用地址</li></ol><p>简单总结：类初始化 - 分配内存 - 实例初始化 - 返回引用地址</p><p><em>多学一点，这里的几个步骤涉及多个指令操作，所以就有了 DCL 单例使用 volatile 来禁止指令重排来保证单例模式的实例同步</em></p><blockquote><p>class 文件中的 static 关键字修饰的方法或变量成为类变量，没有被 static 修饰的部分称为实例变量</p></blockquote><p><strong>下面是对象创建细节的拆分</strong></p><h4 id="怎么分配内存"><a href="#怎么分配内存" class="headerlink" title="怎么分配内存"></a>怎么分配内存</h4><ul><li><p>指针碰撞</p><p>如果内存中现有的分配情况为整齐分布，则会有一个 <em>分界点指示器</em> 在 <em>已用内存</em> 和 <em>未用内存</em> 之间。对于这种情况，只需要将该指示器的位置向后移动当前对象的内存大小位置即可。</p></li><li><p>空闲列表</p><p>更多情况下，内存的使用是不连续的，所以在 JVM 中有一个对于当前内存情况管理的一个列表，称为 <em>空闲列表</em> ，可以通过查询该表来完成对象的内存的分配。</p></li></ul><p>使用 <strong>指针碰撞</strong> 的前提是堆内存空间完整，而内存空间完整的前提是垃圾收集器是否有空间压缩整理能力。</p><p><em>Serial</em> 和 <em>ParNew</em> 垃圾回收器是带有压缩整理能力的，其可以使用指针碰撞的分配方式</p><p><em>CMS</em> 是不具有压缩整理能力的，所以其使用的是空闲列表方式，但在 <em>CMS</em> 垃圾回收器中，它仍然可以使用类似 <code>指针碰撞</code> 的功能，其在空闲列表中申请内存时会申请较大的一块区域，然后对这块区域是 <code>指针碰撞</code> 来分配。</p><p><em>注：指针碰撞在极客时间郑雨迪的《深入拆解Java虚拟机》中翻译成指针加法</em></p><blockquote><p>我猜测会有留言问为什么不把 bump the pointer 翻译成指针碰撞。这里先解释一下，在英语中我们通常省略了 bump up the pointer 中的 up。在这个上下文中 bump 的含义应为“提高”。另外一个例子是当我们发布软件的新版本时，也会说 bump the version number。</p></blockquote><h4 id="内存分配的并发问题"><a href="#内存分配的并发问题" class="headerlink" title="内存分配的并发问题"></a>内存分配的并发问题</h4><p>由于多线程情况，有可能刚申请的内存被其他线程提前写入，导致内存分配出现问题。所以 JVM 提出了两种解决方案。</p><ol><li>使用 CAS + 失败重试；</li><li>为本地线程分配缓冲区 <em>TLAB</em> （通过参数可选 -Xx : - UseTLAB）缓冲区用完之后在使用 CAS + 失败重试分配内存；</li></ol><blockquote><p>TLAB : 线程需要维护两个指针（实际上可能更多，但重要也就两个），一个指向 TLAB 中空余内存的起始位置，一个则指向 TLAB 末尾。接下来的 new 指令，便可以直接通过指针加法（bump the pointer）来实现，即把指向空余内存位置的指针加上所请求的字节数。如果加法后空余内存指针的值仍小于或等于指向末尾的指针，则代表分配成功。否则，TLAB 已经没有足够的空间来满足本次新建操作。这个时候，便需要当前线程重新申请新的 TLAB。</p></blockquote><h4 id="使用内存"><a href="#使用内存" class="headerlink" title="使用内存"></a>使用内存</h4><p>内存分配完之后， JVM 会将这部分区域的值置为0（这就是基本数据类型的默认值的实现），如果使用的是本地线程缓冲区的方案，在分配缓冲区时即已经置为了0，然后开始设置对象头的信息，包括类信息、元数据地址、GC分代年龄、偏向锁等信息，其中哈希值延迟到调用时才会计算并设置。</p><p>至此对象在内存中”完成创建”，但此时的对象并不能使用，接着会继续执行构造函数中的内容，来完成对象程序中的初始化步骤，构造函数执行结束后，对象完成创建。</p><p><em>注：以上对象创建过程代码在 hotspot 虚拟机 bytecodeInterpreter.cpp  line:2179</em></p><h3 id="对象在内存中都存了什么？"><a href="#对象在内存中都存了什么？" class="headerlink" title="对象在内存中都存了什么？"></a>对象在内存中都存了什么？</h3><ul><li>对象头</li><li>实例数据</li><li>对齐填充</li></ul><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><ol><li>MarkWord —— 对象自身运行时数据</li><li>类型指针 —— 对象的类型元数据指针</li><li>数组长度 —— 如果是数组对象的话</li></ol><p><strong>MarkWord</strong></p><ul><li>哈希码</li><li>GC分代年龄</li><li>锁标志</li><li>线程持有的锁</li><li>偏向锁持有线程ID</li><li>偏向时间戳</li></ul><table><thead><tr><th>存储内容</th><th>锁标志</th><th>状态</th></tr></thead><tbody><tr><td>哈希码、分代年龄</td><td>01</td><td>未锁定</td></tr><tr><td>指向锁记录的指针</td><td>00</td><td>轻量级锁</td></tr><tr><td>指向重量级锁的指针</td><td>10</td><td>重量级锁</td></tr><tr><td>空</td><td>11</td><td>GC标记</td></tr><tr><td>持有偏向锁的线程ID、时间戳</td><td>01</td><td>偏向锁</td></tr></tbody></table><p><strong>类型指针</strong></p><p>JVM 通过类型指针来确定当前对象的类型。这个类型指针指向方法区中该对象的元空间数据。</p><p><strong>数组长度</strong></p><p>之所以会单独区分出数组的长度信息，是因为 JVM 无法通过类的元空间数据得出对象的大小，所以单独记录数组对象的长度信息在对象头中。</p><p><em>HotSpot虚拟机代表Mark Word中的代码（markOop.cpp）注释片段，它描述了32位虚拟机MarkWord的存储布局</em></p><h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>无论是从父类继承下来的，还是在子类中定义的字段存储顺序会受到虚拟机分配策略参数</p><p><strong>（-XX：FieldsAllocationStyle参数）</strong> 和字段在Java源码中定义顺序的影响。</p><p>HotSpot虚拟机默认的分配顺序为</p><ol><li>longs/doubles</li><li>ints</li><li>shorts/chars</li><li>bytes/booleans</li><li>oops（Ordinary Object Pointers，OOPs）</li></ol><p>从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。</p><p>如果HotSpot虚拟机的 <strong>+XX：CompactFields</strong> 参数值为true（默认就为true），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。</p><h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><p>hotspot 实现的虚拟机，对对象的起始地址有要求，需要是8字节的整数倍，所以对象的大小就必须是8字节的整数倍，如果不足便需要通过占位符来补充至8字节的倍数。</p><h3 id="怎么在内存中定位访问一个对象？"><a href="#怎么在内存中定位访问一个对象？" class="headerlink" title="怎么在内存中定位访问一个对象？"></a>怎么在内存中定位访问一个对象？</h3><p>Java 程序通过栈上的 reference 数据来操作堆上的对象。</p><p>《Java虚拟机规范》没有说明和约束 reference 的实现方式，所以具体的实现由虚拟机决定。</p><p>通常由下面两种方式实现</p><h4 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h4><p>句柄保存在句柄池中</p><p>句柄保存对象数据的地址和对象类型信息的地址，多进行一次操作。但在 GC 做标记-整理操作时，无需关心对象内存地址的信息变化。</p><h4 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h4><p>保存对象的数据信息和对象类型信息的地址，可以直接访问到对象数据。当需要使用类信息的时候，需要在进行一次查找。</p><p><img src="https://i.loli.net/2020/12/24/KsRq1Lk9e4pmxYC.jpg" alt="句柄"></p><p><img src="https://i.loli.net/2020/12/24/CtlidYOgJ4VweTn.jpg" alt="直接指针"></p><blockquote><p>图片来自《深入理解 Java 虚拟机》（第三版）周志明</p></blockquote><p>（正文完）</p><p>下一篇学习对象是怎么回收的，非常欢迎关注加群一起学习，一起学劲儿大！</p>]]></content>
    
    
    <summary type="html">new....</summary>
    
    
    
    <category term="虚拟机" scheme="http://lvgo.org/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="虚拟机" scheme="http://lvgo.org/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>你创建的Java对象搁哪了？</title>
    <link href="http://lvgo.org/post/lvgo-jvm-02.html"/>
    <id>http://lvgo.org/post/lvgo-jvm-02.html</id>
    <published>2020-12-23T13:44:21.000Z</published>
    <updated>2020-12-23T13:44:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关注我一起学习，悄悄超过他"><a href="#关注我一起学习，悄悄超过他" class="headerlink" title="关注我一起学习，悄悄超过他"></a>关注我一起学习，悄悄超过他</h3><h1 id="拒绝做知识“收藏家”"><a href="#拒绝做知识“收藏家”" class="headerlink" title="拒绝做知识“收藏家”"></a>拒绝做知识“收藏家”</h1><p>答应我，跟我一起学习吧，别再做知识收藏家了，把《深入理解 Java 虚拟机》书拿出来，翻它，盘它，磋磨它。</p><h1 id="你创建的-Java-对象搁哪了"><a href="#你创建的-Java-对象搁哪了" class="headerlink" title="你创建的 Java 对象搁哪了"></a>你创建的 Java 对象搁哪了</h1><p><img src="https://i.loli.net/2020/12/23/hzSZBMDYPG9pO5r.png" alt="运行时数据区域"></p><p>今天学习的内容是 JVM 自动内存管理中的 <code>运行时数据区域</code> 内容。</p><h1 id="自动内存管理"><a href="#自动内存管理" class="headerlink" title="自动内存管理"></a>自动内存管理</h1><blockquote><p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。<br>—— 出自周志明《深入理解 Java 虚拟机》</p></blockquote><p>Java 的内存区域与内存溢出。</p><p>对于 Java 程序来讲，内存是由虚拟机的内存自动管理机制<em>垃圾回收</em>来进行管理的。这样便使得程序不容易出现内存溢出和内存泄漏问题。但是一旦出现内存问题，排查和解决起来便不是一件容易的事。</p><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li><li>堆</li><li>方法区 - 运行时常量池</li><li>直接内存</li></ul><h3 id="PC寄存器（程序计数器）"><a href="#PC寄存器（程序计数器）" class="headerlink" title="PC寄存器（程序计数器）"></a>PC寄存器（程序计数器）</h3><ul><li><strong>线程私有</strong></li><li>存储<strong>当前方法的字节码位置</strong>，如果是<strong>本地方法则存储 undefined</strong></li><li>唯一一个不会出现 <strong>OOM</strong> 的位置</li><li>方法执行时使用；</li></ul><h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><ul><li><strong>线程私有</strong></li><li>存储程序方法执行时的 <strong>栈帧</strong></li><li>达到栈允许最大容量抛出 <strong>StackOverflow Error</strong> 栈溢出</li><li>允许动态扩展，申请不到内存时抛出 <strong>OOM</strong>。（允许动态扩展由虚拟机实现方自行选择，hotspot选择的则是不允许动态扩展）</li><li>不需要保证连续的内存</li><li>方法执行时使用；</li></ul><p><em>注：在 hotspot 中不允许扩展栈内存，但同样会发生 OOM ，这是发生在创建线程内存申请时内存不足抛出的OOM，这里也属于栈原因引起的。</em></p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>同上</p><p><em>注：说明两者服务对象，虚拟机栈服务于 Java 程序，本地方法栈服务于 JVM 程序（native 方法）。</em></p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul><li>线程共享</li><li>存储类实例、数组对象</li><li>容量超过允许最大值时抛出 <strong>OOM</strong> 异常（允许动态扩展）</li><li>不需要保证连续的内存</li><li>创建对象时使用</li></ul><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul><li>线程共享</li><li>存储类的结构信息（方法、字段、构造函数）、运行时常量池</li><li>容量超过允许最大值时抛出 <strong>OOM</strong> 异常（允许动态扩展）</li><li>不需要保证连续的内存</li><li>虚拟机启动时创建</li><li>后被替换为元空间（这里的内容要和 hotspot 的“永久代“一起理解）</li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>（这部分内存区域同在方法区中体现）</p><ul><li>线程共享</li><li>存储接口或类的常量池（字面量 与 <strong>符号</strong>引用<code>类的全部限定名等信息</code>）</li><li>类加载时创建</li><li>创建过程使用的方法区内存大小，可能出现 <strong>OOM</strong> 异常</li></ul><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>（这部分为延展内容）</p><ul><li>不受虚拟机参数控制，直接使用主机内存，受主机内存大小限制；</li><li>JDK4中的 NIO 首次使用；</li><li>在设置JVM参数时，需考虑直接内存的使用大小，防止其过渡使用出现 <strong>OOM</strong>；</li><li>JDK7开始将方法区移到这部分区域（永久代内容），直到 JDK8 全部移入元空间（这里指 hotspot 虚拟机）</li></ul><table><thead><tr><th>作用\名称</th><th>PC寄存器（程序计数器）</th><th>Java虚拟机、本地方法栈</th><th>Java 堆</th><th>方法区</th></tr></thead><tbody><tr><td>异常情况</td><td>无</td><td>栈溢出、堆溢出</td><td>堆溢出</td><td>堆溢出</td></tr><tr><td>需要连续内存</td><td>否</td><td>否</td><td>否</td><td>否</td></tr><tr><td>存储内容</td><td>在执行 Java 代码时，存储字节码地址。<br>在执行本地方法时，存储 undefined</td><td>栈帧（每个栈帧以方法为单位）</td><td>类实例、数组对象</td><td>类的结构信息、字段、方法等</td></tr><tr><td>使用时机</td><td>方法执行时</td><td>方法执行时</td><td>创建对象时</td><td>类被加载时</td></tr><tr><td>线程私有</td><td>是</td><td>是</td><td>否</td><td>否</td></tr></tbody></table><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>Java 的对象搁哪现在你清楚了吗？每天一点点，啃完虚拟机。欢迎加群一起讨论学习，大家一起学习效率很高哦</p><hr>]]></content>
    
    
    <summary type="html">你定义的类又搁哪了</summary>
    
    
    
    <category term="虚拟机" scheme="http://lvgo.org/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="虚拟机" scheme="http://lvgo.org/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>JVM 你知道不？一起来学啊</title>
    <link href="http://lvgo.org/post/lvgo-jvm-01.html"/>
    <id>http://lvgo.org/post/lvgo-jvm-01.html</id>
    <published>2020-12-22T15:10:49.000Z</published>
    <updated>2020-12-22T15:10:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lvgo-的-JVM-学习笔记"><a href="#lvgo-的-JVM-学习笔记" class="headerlink" title="lvgo 的 JVM 学习笔记"></a>lvgo 的 JVM 学习笔记</h1><p>实不相瞒，这份 JVM 学习笔记，可以说很香。</p><blockquote><p>大家好，我是 lvgo，如果你之前看过我写的《和 lvgo 一起学习设计模式》.PDF，应该知道了 lvgo 的意思了，相信你知道它是什么意思后，会加深你对 lvgo 的印象。</p></blockquote><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>关于 Java 虚拟机的学习，无论从业务开发上来说，还是从解决问题的角度上来看。我认为都是一个 Java 程序员必会的一个知识体系，为什么这么说呢？还是那句耳朵已经听起茧的话 ”知其然，而知其所以然“。</p><h1 id="知其然，而知其所以然"><a href="#知其然，而知其所以然" class="headerlink" title="知其然，而知其所以然"></a>知其然，而知其所以然</h1><p>我见过因为不清楚技术底层原理乱用的开发人员，也见过不懂技术原理所以害怕其出现问题的领导拒绝开发人员应有新技术。</p><p>举个例子：如果有 10 个人，给他们每个人一把刀，叫他们去山上砍柴，那这 10 个人假如都是第一次接触”刀“这个物品的话。那么就一定有人用刀背砍东西，有人用刀刃砍石头，而真正能正确使用的人它一定清楚这个物品哪里手可以握，哪里锋利，哪里可以砍树不能砍石头。（例子可能不恰当，说明意思即可）</p><p>Java 虚拟机的这个知识点，我觉得最重要的不是调优部分，而是编译优化的那部分。之前听郑雨迪（Oracle 高级研究员，hotspot 开发者）说他现在在做 graal 编译器的工作内容就是想办法优化业务代码，让他们跑的更快。那我们能不能直接写出来无需优化，或减少编译优化阶段的工作呢？答案是可以的，但也只能做到编码部分的优化，关于虚拟机的优化内容慢慢会在我的笔记中了解到。</p><h1 id="学习过程"><a href="#学习过程" class="headerlink" title="学习过程"></a>学习过程</h1><p>在学习 Java 虚拟机的这个过程是及其枯燥的，18 年我看完了周老师的《深入理解 Java 虚拟机》（第二版），大概只用了 10 几个小时。不过这 10 几个小时却花了我 1 年多的时间才消化掉。去年年底，也就是 19 年 11 月，周老师出了《深入理解 Java 虚拟机》（第三版），我是到今年 9 月份才开始读这本书的。大概还是只用了 10 几个小时就读完了，这次很明显感觉不一样了。而且这次一起看了很多关于虚拟机的内容，包括 JSR 和 虚拟机规范，还有 R 大的一些博客。</p><p><img src="https://i.loli.net/2020/12/22/zWFAnxNPhs7t1iq.png" alt="微信读书"></p><h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><p>系统的学习使我对 Java 虚拟机有了一定的理解，但究其深处还有很多可以探索的内容，其中执行引擎就是一个 “巨坑” ，不过这里并不是我们学习的目的，我们要学习的是<strong>我们写的代码在虚拟机里都干了什么</strong>，而不是执行引擎到底是怎么执行的指令，明确的了我们学习目标，那就好办了。</p><h1 id="接下来的事"><a href="#接下来的事" class="headerlink" title="接下来的事"></a>接下来的事</h1><p>明确了学习的目标，再去学习就会相对清晰了很多，可以避开不是当前学习计划的内容，因为虚拟机的东西还是比较多。我根据周老师的书中内容，将虚拟机整理成如下几个知识点</p><ol><li>自动内存管理</li><li>虚拟机的执行</li><li>程序编译和代码优化</li><li>“高”并发</li></ol><p><img src="https://i.loli.net/2020/12/22/dKlebYpL5VxM3jW.png" alt="JVM"></p><p>这里面的第 3 点尤为重要，我觉得其他的都不懂这个都要懂。</p><p>很多面试或者文章中说虚拟机调优多么多么重要，之前看过廖神（廖雪峰）写的一个 JVM 调优的内容，我觉得很有道理。JVM 每天跑着几百万、几千万的程序，经历了无数次的考验。有问题的可能性不大，换句话说，如果想要调优虚拟机，先调优你的代码。</p><h1 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h1><p>接下来我会以日更或半周更的形式，以周老师的书籍为主线，其他资料的辅助将这本国内口碑极佳的《深入理解 Java 虚拟机》以极简的形式输出出来，让更多想要学习虚拟机，但碍于枯燥晦涩（周老师书其实说的一点都不晦涩难懂）而放弃学习 Java 虚拟机的开发者们能够一起来学习虚拟机的相关知识。</p><hr><p><img src="https://i.loli.net/2020/12/22/2CzWEr1ueBoQ8gl.jpg" alt="jvm笔记"></p><p>也欢迎大家一起加群交流学习，关注回复<strong>加群</strong>一起在这个寒冷的冬天啃完这块重要的内容。</p>]]></content>
    
    
    <summary type="html">后面的跟上，赶紧的！</summary>
    
    
    
    <category term="虚拟机" scheme="http://lvgo.org/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="虚拟机" scheme="http://lvgo.org/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>《和 lvgo 一起学设计模式》.PDF</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-pdf.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-pdf.html</id>
    <published>2020-12-20T15:28:54.000Z</published>
    <updated>2020-12-20T15:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="和-lvgo-一起学习设计模式-PDF"><a href="#和-lvgo-一起学习设计模式-PDF" class="headerlink" title="和 lvgo 一起学习设计模式.PDF"></a>和 lvgo 一起学习设计模式.PDF</h1><p>大家好，我是 lvgo（小米），刚刚用了60天时间学完了 <code>设计模式</code>，输出了 23 份关于设计模式的学习文章，我为了自己复习方便，把它整理成了一本 PDF 。现在我想把它分享出去，<strong>这份文档内容很纯粹</strong><br>，因为它是由“草根”程序员整理出来的，所以我觉得它更适合更多的开发者！</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>国庆的时候，开始了对设计模式这个知识点的学习。</p><p>因为是系统的学习，所以我同时阅读了<strong>大量</strong>关于设计模式的资料，</p><p>其中包括</p><ul><li>GOF 的原著《设计模式.可复用面向对象软件的基础》</li><li>国内口碑较高的《大话设计模式》程杰著，</li><li>秦小波《设计模式之禅（第2版）》</li><li>很多博客网站等等（详情见文末）</li><li>…….</li></ul><p><img src="https://i.loli.net/2020/12/20/9uokIFMYTgbKJle.png" alt="books"></p><p>看这么多资料的原因嘛，有两点</p><ol><li>目前市面知识要么多是凑数，要么多是营销，在这个人们称为的“知识付费”的时代，已经很难找到从“根本传授知识的“（这也是自己沉淀输出知识的一个原因，希望自己能做到一个朴实无华，作为一个技术人员的角度来真真正正的把自己对这个领域的所见所得输出出去。）</li><li>另外一方面就是方便自己学习理解、提高对知识的接受程度，讲真你很难从一个地方学到更多东西，所以我无论学哪个知识点都是会搜罗很多资料去学习，其实在资料选择这一块就是一个非常耗时的过程，因为有很多东西别人说好，但是他不一定适合你。技术这东西更是如此，因为每个人的技术起点不同，只有选取合适自己的“高度”才能学到东西，这也算是“仁者见仁智者见智”的一种体现吧。</li></ol><h2 id="部分截图"><a href="#部分截图" class="headerlink" title="部分截图"></a>部分截图</h2><p><img src="https://i.loli.net/2020/12/20/jZ8ArtpGDR2cXQN.png" alt="部分截图"></p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="设计模式的学习问题⁉❔"><a href="#设计模式的学习问题⁉❔" class="headerlink" title="设计模式的学习问题⁉❔"></a>设计模式的学习问题⁉❔</h3><p>我一直都在想如何学会一个新东西，和掌握一个旧东西🤔，有很多前辈给过一些建议和意见📑，（当然不是直接给我，都是看大佬的文章或者书籍当中。）先去用，再去学。嗯，我想是的，这样肯定是个很正常的学习过程。但是对于一些你暂时无法使用的东西，你如何去掌握它呢？我认为应该抛开表象去了解本质，通过本质的类比去掌握那些暂时无法使用的东西。设计模式就是这种情况，在平常的开发中，常用的设计模式就那么几种，其它的那些没有机会去接触，干学，如何才能掌握呢？🗃</p><p>我从小就是一个好为人师的家伙🤓，然而自己学习却一直都不怎么样😢。人太实在，也不懂的包装，我只知道我学习这么差的能学会的东西，讲给别人应该差不哪去。😊</p><p>在学习算法的时候，学到一个特别巧妙而且很好用的解题思路或者说逻辑思维<code>”分而治之“</code>，还有之前和网友讨论的一个叫做<code>”复杂度守恒定律“</code>的东西。这两个东西放在一起，可以说是很”矛盾“⚔🛡了。</p><p>说了这么多我想说的就是，设计模式这个知识点，真的很简单又很难。简单是因为每种设计模式的定义拿出来都能看的懂，难是难在如何，何时的应用。而我希望我写的这个设计模式系列是去应用化的，就是单纯的把设计模式的思想记录下来。我所理解的设计模式就该如此。</p><p>GOF的 <strong>《设计模式.可复用面向对象软件的基础》</strong> 通过一个应用案例的实现，串起了23种设计模式，我想在系列更新完之后也更新一个应用，将 23<br>种设计模式尽可能的应用到一个应用案例中去，而不是每个设计模式都涉及具体的应用，因为我觉得这可能会带的人们更关注应用的实现，而不是设计模式的应用，这是我的一些想法。</p><p><strong>不要纠结每种模式的具体实现，把它们抽象出来，你能够清楚的描述每种模式是为了解决什么问题而存在的时候，就已经掌握它了，就可以把它用在任何当你需要的时候。而不是问什么时候需要它，这可能有点绕，不过它是真的。不要问我设计模式可以解决哪些问题，把问题给我，我告诉你用什么设计模式可以解决它！</strong></p><h3 id="返璞归真"><a href="#返璞归真" class="headerlink" title="返璞归真"></a>返璞归真</h3><p>我认为学习设计模式的过程就像拿到一台游戏机，玩到最后，我都会拆开看看里面是什么，而早已不关心游戏好不好玩了。</p><p>知识也是一样，知其然而知其所以然。</p><p><strong>我们为了学会使用某种东西看他的操作手册就可以了；</strong></p><p><strong>我们如果想要学会修某种东西就需要看他的设计手册；</strong></p><p><strong>当我们想要创造某种东西，你就需要掌握很多很多设计手册，将他们的经验进行吸收、消化、提炼。才能有更好的结果。</strong></p><p><em>当然，如果你只想会用，有一份差不多的操作指南也就够了。</em></p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>60 天说长不长，说短不短，我完成了这一部分知识点的学习，并将其整理成为对应的 23 篇 <strong>原创</strong> 文章提交到了 git 仓库<em>（这个参考包括了涉及的源码、文章原文、素材、UML类图这些内容）</em>。</p><p>同时也将他们发表在了 <code>星尘的一个朋友</code> 这个公众号上。公众号我也只认为是一个分享知识的地方，我没有营销他的想法，所以就像平常发表文章一样在上面写写记记，能帮到一个人也是极好的。</p><p>越来越多的时候想将自己在技术上的所见所得与人分享或交流，当然能有机会和大佬交谈学到东西就更好了，这样我就可以将知识传承下去了。写《和 lvgo 一起学设计模式》这个系列文章让我学到了很多，感谢所有！</p><p><img src="https://i.loli.net/2020/12/20/WrRjE9wYtc7bhKp.png" alt="源码"></p><h2 id="如何获取"><a href="#如何获取" class="headerlink" title="如何获取"></a>如何获取</h2><p>大家可以关注公众号回复：<code>设计模式</code> 获得这本《和 lvgo 一起学习设计模式》 PDF 以及这个设计模式的 <code>github 仓库</code> ，<em>如果可以，希望你给个 <strong>star</strong> 支持一下我！</em></p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>保持热爱，奔赴山海。</p>]]></content>
    
    
    <summary type="html">　　&quot;保持热爱，奔赴山海&quot;</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>解释器模式：你能看懂TA的“眼色”吗？</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-interpreter.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-interpreter.html</id>
    <published>2020-12-07T13:20:32.000Z</published>
    <updated>2020-12-07T13:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>这篇是<strong>《和 lvgo 一起学设计模式》</strong>系列的最后一个设计模式了，这篇就轻松一些吧。</p><h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h1><blockquote><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p></blockquote><p>因为时代的发展、技术的更替等等原因（你想做的解释器都有人做好了，且开源）吧，可能这个是我们很长一段时间都用不到的一种设计模式了。</p><h2 id="你能看懂TA的“眼色”吗？"><a href="#你能看懂TA的“眼色”吗？" class="headerlink" title="你能看懂TA的“眼色”吗？"></a>你能看懂TA的“眼色”吗？</h2><p>还记得那些年看过的影视剧吗？或是表情包吗？</p><p><img src="https://i.loli.net/2020/12/03/dFSRYxU9AEDji4v.jpg" alt="interpreter-1.jpg"></p><p><img src="https://i.loli.net/2020/12/03/pazvAJuBRKZhkco.jpg" alt="interpreter-2.jpg"></p><p>你能看懂柯镇恶和“老婆”的眼色吗？</p><p>反正我是看不懂，单是看这情况，完全看不懂是什么意思。</p><p>但如果我提前给你说下规则呢？</p><p><strong>柯镇恶图</strong></p><ol><li>柯镇恶往左摆头，冲！</li><li>柯镇恶往右摆头，撤！</li></ol><p><strong>“老婆”图</strong></p><ol><li>“老婆”坐在坐垫上，生气！</li><li>“老婆”坐在摩的后面架子上，开心！</li></ol><p>那这个时候再看他们的“眼色”，你能看懂了吗？如果有了上面的定义，我便知道了：</p><ul><li>柯镇恶的意思是冲！（假设是往左摆头了）</li><li>“老婆”很开心！</li></ul><h2 id="再谈解释器模式"><a href="#再谈解释器模式" class="headerlink" title="再谈解释器模式"></a>再谈解释器模式</h2><p><u>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</u></p><p>定义一个语言：“眼色”</p><p>定义他的文法表示：“摆头”、“坐的位置”</p><p>定义解释器：“规则”</p><p>这样我们就可以通过这个解释器来了解TA了。</p><p><strong>给定一个”眼色“，定义”摆头“或”坐的位置“，并定义一个规则，这样就可以解释图中的柯镇恶和”老婆“了。</strong></p><h2 id="解释器模式类图-📌"><a href="#解释器模式类图-📌" class="headerlink" title="解释器模式类图 📌"></a>解释器模式类图 📌</h2><p><img src="https://i.loli.net/2020/12/03/IrtOF8hdjB3PDnG.png" alt="interpreter-UML.png"></p><p>这个结构比较简单，定义一个解释接口，然后就是两个具体的解释器</p><ol><li>最终解释器</li><li>非最终解释器</li><li>环境</li></ol><p>这两个有点像组合模式中的子节点和叶节点的意思。这里的 <code>NonTerminalExpression </code> 是可以有多个的；</p><p>这里最麻烦的其实是 <code>Context</code> 环境。</p><h2 id="代码-📃"><a href="#代码-📃" class="headerlink" title="代码 📃"></a>代码 📃</h2><p>我们来看看代码来实现上面的”眼色“</p><blockquote><p>完整代码关注回复“源码”获取。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;<br>    EyeColor eyeColor = <span class="hljs-keyword">null</span>;<br>    Context context = <span class="hljs-keyword">new</span> Context(<span class="hljs-string">&quot;柯镇恶往左摆头 | 老婆坐在了架子上&quot;</span>);<br>    String content = context.getContent();<br>    String[] strings = content.split(<span class="hljs-string">&quot;\\|&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strings.length; i++) &#123;<br>        String string = strings[i];<br>        context.setContent(string);<br>        <span class="hljs-keyword">if</span> (string.contains(<span class="hljs-string">&quot;柯镇恶&quot;</span>)) &#123;<br>            eyeColor = <span class="hljs-keyword">new</span> KeZhenE();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (string.contains(<span class="hljs-string">&quot;老婆&quot;</span>)) &#123;<br>            eyeColor = <span class="hljs-keyword">new</span> Wife();<br>        &#125;<br>        <span class="hljs-keyword">assert</span> eyeColor != <span class="hljs-keyword">null</span>;<br>        eyeColor.interpreter(context);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KeZhenE</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EyeColor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (context.getContent().contains(<span class="hljs-string">&quot;左摆头&quot;</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;冲！&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (context.getContent().contains(<span class="hljs-string">&quot;右摆头&quot;</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;撤！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wife</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EyeColor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (context.getContent().contains(<span class="hljs-string">&quot;座椅&quot;</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;生气！&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (context.getContent().contains(<span class="hljs-string">&quot;架子&quot;</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;开心！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">冲！<br>开心！<br></code></pre></td></tr></table></figure><h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>通过上面的内容我们了解到，<strong>解释器可以自己定义一些规则和对应的解释规则</strong>，<strong>来完成一些复杂的事情</strong>，这样就使得可以用一个简单的“动作”来达成一件复杂的事情。你看柯镇恶一个眼色，我就知道他想冲，他省去了复杂的“张嘴”过程。</p><p>其实解释器模式就像是我们现在用高级语言来开发软件程序一样，是怎么才能让计算机知道我们在说什么呢？其实这就是解释器的作用，我们按照一定规则（语法）来编写代码，然后解释器按照定义好的规则来将我们的代码翻译成机器认识的 01 代码。</p><p>对于解释器，它将复杂的事自己“包揽”了，但是一旦<strong>发生新的规则</strong>，你就<strong>不得不去修改“包揽”的复杂解析过程</strong>。</p><p>在今天，解释器模式应该很少会在我们的应用自己去设计了，毕竟这如同设计一门语言一样，过程很复杂，还记得我们正在用的正则表达式吗？他就是一个轻量级的语言，如果有能力有机会的时候，也可以挑战一下，开发一个自己的语言。</p>]]></content>
    
    
    <summary type="html">　　“你能看懂TA的“眼色”吗？”</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>访问者模式：是“凡尔赛”让我“认清”了解释器模式：你能看懂TA的“眼色”吗？访问者模式！</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-visitor.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-visitor.html</id>
    <published>2020-12-06T13:20:32.000Z</published>
    <updated>2020-12-06T13:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><blockquote><p>将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。</p></blockquote><p>刚看到这个模式的时候，我人都傻了，完全不知道说的是啥，直到看了近5份资料！才搞清楚这个设计模式，不愧是最复杂的一种，我也这样觉得。不过千万别被复杂吓到，捋清了之后，还是比较简单的。</p><h2 id="开门见山"><a href="#开门见山" class="headerlink" title="开门见山"></a>开门见山</h2><p>访问者模式“人如其名”，就是说不同的访问者对同一个对象的访问结果不同。为什么会不同呢？因为这个访问者是我们自己定义的，我们就想让他不同😂。</p><p>而实际情况更是如此。我通过几份资料总结下来，这个访问者模式所谓的访问者其实就是我们想要控制的访问权限一样。因为任何一个“访问者”都可以看到具体数据的全部内容，他只是选择性的”不看“，这样便区分开了”访问者“<strong>关注的内容</strong>，或者<strong>”限制“了”访问者“的权限</strong>。</p><p>可能我说的有点绕，有点抱歉，我再简化一下这个内容。</p><h2 id="网络用语"><a href="#网络用语" class="headerlink" title="网络用语"></a>网络用语</h2><p><strong>抛开表象看本质</strong></p><p>如果我们抛开访问者模式这些专业的定义，单纯的去理解这个访问者模式要表达的意思，我觉得用一个东西最合适不过。那就是“网络用语”；</p><p>不知道大家听没听过前阵子火了的百度广告《你说啥》单曲。歌曲中的朝阳大妈就是一个不知道关注点或者是被限制了访问权限的访问者，当然他歌曲中说的网络语有好多我也不知道是啥🙃。没听过的快去听吧。</p><p>还有最近的 <code>凡尔赛文学</code> 我不百度的时候以为是个地名，所以我的 <code>权限</code> 也被限制了。</p><p>正好提到这个了，那我们就拿 <code>凡尔赛文学</code> 这个网络语来学习一下访问者模式吧~🤩</p><h2 id="凡尔赛文学"><a href="#凡尔赛文学" class="headerlink" title="凡尔赛文学"></a>凡尔赛文学</h2><p><strong>首先我们就要再一次抛开表象看本质😂</strong></p><p>下面是我搜集到有关凡尔赛的释义：</p><ol><li>凡尔赛是法国巴黎的卫星城以及伊夫林省省会，曾是法兰西王朝的行政中心。</li><li>《凡尔赛》是皮埃尔·苏勒执导的剧情片。</li><li>以法国路易十四为时代背景的电视剧。</li><li>凡尔赛文学，网络热词，指通过先抑后扬、自问自答或第三人称视角，不经意间露出”贵族生活的线索”。</li><li>啥？？？</li></ol><p>对于凡尔赛一共有 5 种释义，他的结构应该是这样的</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Versailles</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation1 = <span class="hljs-string">&quot;凡尔赛是法国巴黎的卫星城以及伊夫林省省会，曾是法兰西王朝的行政中心。&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation2 = <span class="hljs-string">&quot;《凡尔赛》是皮埃尔·苏勒执导的剧情片。&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation3 = <span class="hljs-string">&quot;以法国路易十四为时代背景的电视剧。&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation4 = <span class="hljs-string">&quot;凡尔赛文学，网络热词，指通过先抑后扬、自问自答或第三人称视角，不经意间露出\&quot;贵族生活的线索\&quot;。&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation5 = <span class="hljs-string">&quot;啥？？？&quot;</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>因为我们还要对这个数据进行访问，所以还要给他加个访问的方法 #visit</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Versailles</span> </span>&#123;<br><br>   .....<br>       ....<br>       ...<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 访问</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然要访问，肯定要有访问者啊，因为访问者挺多的，比如我、我的小伙伴、还有你，所以我们就使用依赖倒置原则来定义一个访问者接口 <code>Visitor</code> 然后有个访问方法，再把凡尔赛给访问者去让其自己访问，那代码实现起来应该是这样的。</p><p> <code>Visitor</code>接口</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Visitor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Versailles versailles)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>凡尔赛的访问方法调整一下，最终完整类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Versailles</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation1 = <span class="hljs-string">&quot;凡尔赛是法国巴黎的卫星城以及伊夫林省省会，曾是法兰西王朝的行政中心。&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation2 = <span class="hljs-string">&quot;《凡尔赛》是皮埃尔·苏勒执导的剧情片。&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation3 = <span class="hljs-string">&quot;以法国路易十四为时代背景的电视剧。&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation4 = <span class="hljs-string">&quot;凡尔赛文学，网络热词，指通过先抑后扬、自问自答或第三人称视角，不经意间露出\&quot;贵族生活的线索\&quot;。&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation5 = <span class="hljs-string">&quot;啥？？？&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将该对象提供给访问者访问</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> visitor 访问者</span><br><span class="hljs-comment">     * 方法名改成 accept 更好，表示这个类接受一个访问者来访问自己🙅</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span></span>&#123;<br>        visitor.visit(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就是具体的访问者了，那我根据实际情况来定义一些访问者</p><ol><li>I</li><li>MyFriend</li><li>You</li></ol><p>一共三个访问者</p><p><strong>I</strong>（我自己）</p><p>我比较博学多识，我知道凡尔赛是地名、电影、电视剧三个</p><p><strong>MyFriend</strong>（狗哥）</p><p>看他的样子应该是不知道</p><p><img src="https://i.loli.net/2020/12/03/fBnOdChGT9mZ2Yj.png" alt="visitor-unkown.png"></p><p><strong>You</strong>（你呢？）</p><p>我就当你知道凡尔赛文学，已经领悟到了无形装逼的境界好了🌚</p><p>看下这三个类的情况</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 我比较博学多识</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 欢迎跟我一起学习，微信（lvgocc）公众号搜索：星尘的一个朋友</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@blog</span> <span class="hljs-doctag">@see</span> http://lvgo.org</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CSDN</span> <span class="hljs-doctag">@see</span> https://blog.csdn.net/sinat_34344123</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">I</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Visitor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Versailles versailles)</span> </span>&#123;<br>        System.out.println(versailles.getInterpretation1());<br>        System.out.println(versailles.getInterpretation2());<br>        System.out.println(versailles.getInterpretation3());<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 弱智狗哥</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFriend</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Visitor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Versailles versailles)</span> </span>&#123;<br>        System.out.println(versailles.getInterpretation5());<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 网络达人</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">You</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Visitor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Versailles versailles)</span> </span>&#123;<br>        System.out.println(versailles.getInterpretation4());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们在模拟一下运行起来的情况</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VisitorTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span> </span>&#123;<br>        Versailles versailles = <span class="hljs-keyword">new</span> Versailles();<br><br>        System.out.println(<span class="hljs-string">&quot;lvgo 你知道凡尔赛吗？&quot;</span>);<br>        versailles.accept(<span class="hljs-keyword">new</span> I());<br><br>        System.out.println(<span class="hljs-string">&quot;\n狗哥 你知道凡尔赛吗？&quot;</span>);<br>        versailles.accept(<span class="hljs-keyword">new</span> MyFriend());<br>        <br>        System.out.println(<span class="hljs-string">&quot;\n你知道凡尔赛吗？&quot;</span>);<br>        versailles.accept(<span class="hljs-keyword">new</span> You());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果，狗哥拉胯</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">lvgo 你知道凡尔赛吗？<br>凡尔赛是法国巴黎的卫星城以及伊夫林省省会，曾是法兰西王朝的行政中心。<br>《凡尔赛》是皮埃尔·苏勒执导的剧情片。<br>以法国路易十四为时代背景的电视剧。<br><br>狗哥 你知道凡尔赛吗？<br>啥？？？<br><br>你知道凡尔赛吗？<br>凡尔赛文学，网络热词，指通过先抑后扬、自问自答或第三人称视角，不经意间露出<span class="hljs-string">&quot;贵族生活的线索&quot;</span>。<br></code></pre></td></tr></table></figure><p>不同的访问者，看到数据结构中的结果不同。再来看下访问者的定义</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。<br></code></pre></td></tr></table></figure><p>虽然我们这里用的是一个对象，试着将它变成集合（多个网络语而已）吧。使用循环把每个元素都“送”给访问者，这个就留着给你动手试试吧，也留给自己以后回来看的时候能被逼动动脑😂。实在不想动，关注回复 “源码” 吧！😀</p><h2 id="访问者模式类图-📌"><a href="#访问者模式类图-📌" class="headerlink" title="访问者模式类图 📌"></a>访问者模式类图 📌</h2><p>最后，我们来看下标准的访问者模式结构图</p><p><img src="https://i.loli.net/2020/12/03/mKRj7h6eZVp2gt8.png" alt="visitor-UML.png"></p><p>这个结构比较复杂</p><ol><li>客户端高层模块 <code>Client</code>；</li><li>访问者接口，依赖倒置接口 <code>Visitor</code>；</li><li>被访问的元素，<code>Element</code>；</li><li>最后一个，<code>ObjectStructure</code> 对象结构；</li></ol><p>这里唯一可能需要解释的就是这个 <code>ObjectStructure</code> 了，他即用于来定义管理 <code>Element</code> 的对象载体。它可以是我们业务场景中任何需要被访问元素的载体对象，比如上述例子中，我们想把这个结构放进去那我就可以定义一个词语类 <code>Word</code> ，里面可以有 <code>NetWordLanguage</code>，<code>Professional vocabulary</code> 等等对象。如下所示</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Word</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 网络语</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;NetWordLanguage&gt; netWordLanguages = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addWord</span><span class="hljs-params">(NetWordLanguage netWordLanguage)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!netWordLanguages.contains(netWordLanguage))&#123;<br>            netWordLanguages.add(netWordLanguage);   <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>访问者全部源代码关注回复 “源码” 获取</p></blockquote><h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>访问者模式适合在<strong>数据结构稳定</strong>的系统中，即很少或不变的数据结构场景；</p><p>当你想要对一个数据集合增加一些不同的使用规则，或者是“权限”控制时，可以考虑使用访问者模式，并要一同考虑数据结构是否稳定（是否会在增加类），因为这会导致访问者需要“重构”。</p><p><strong>解决的问题：</strong></p><ol><li>访问者模式使数据结构与数据访问分离</li><li>可以很灵活的增加不同的访问规则</li></ol><p><strong>自身的问题：</strong></p><ol><li>一旦出现数据结构变更（新增类型），将会使访问者发生较大的修改，因为需要调整访问者接口！严重违反了开闭原则</li></ol>]]></content>
    
    
    <summary type="html">　　“是“凡尔赛”让我“认清”了访问者模式！”</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>中介者模式：还记得你到单位入职的第一天吗？你有没有遇到文中‘王二’的事呢？</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-mediator.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-mediator.html</id>
    <published>2020-12-05T13:20:32.000Z</published>
    <updated>2020-12-05T13:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><blockquote><p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p></blockquote><p>与其说中介者模式还不如说是软件设计原则的具体体现。这个原则就是——迪米特法则。</p><p><em>这里可以参考之前的系列文章<strong>《和 lvgo 一起学习设计模式 - 序》</strong>中的软件设计基本原则 6 迪米特法则</em></p><ul><li>6️⃣ 迪米特法则又叫作最少知识原则 LOD/LKP ，1987 年美国东北大学👨‍🎓（Northeastern University）的一个名为迪米特（Demeter）的研究项目，由伊恩·荷兰（Ian Holland）提出，被 UML 创始人之一布奇（Booch）🧙‍♂️普及，后来又在经典著作《程序员修炼之道》📕中提及，从而传播开来。原则定义：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：<u>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用</u>。其目的是降低类之间的耦合度，提高模块的相对独立性。</li></ul><p>通过这个原则的核心内容我们知道，迪米特法则（中介者模式）要解决的问题就是提高软件程序的聚合度、降低对象之间的耦合。</p><h2 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h2><h3 id="王二入职"><a href="#王二入职" class="headerlink" title="王二入职"></a>王二入职</h3><p>前阵子王二刚刚毕业，入职了一家公司，报道的第一天，人事将王二带到部门后介绍了接头人就走了，王二坐在座位上等待人“接待”他，等了20分钟，没人管他，于是他起身去找了当时的部门接头人旺仔。</p><p>“仔哥，我~“，”啊，我知道，你新来的“。”我还没电脑“</p><p>“没电脑？你去找那个角落里，那是网管，问他们要一台”，”好的“</p><p>王二初来乍到，总觉得哪里不对，又不好意思说，就去角落里问：”您好，我是xxx部新来的，需要领台电脑“，”啊，去找你组长申请“。</p><p>“仔哥，那面叫我来和组长申请。我组长是谁啊？”，“我啊，我就是你组长，跟我申请”。王二没说话。“把这个表格打出来，填一下，给我和部门经理签字”，“仔哥，去哪里打印？”，“茶水间边上的房间，找打印机管理员”。</p><p>王二蹑手捏脚的过去了，到了那里“您好，我想打份申请单。” “什么申请？”，“离职申请。“王二淡定的说。</p><p><img src="https://i.loli.net/2020/12/03/6v5UQJkTwA8YqBZ.png" alt="mediator-wanger-ruzhi.png"></p><h3 id="王二找房"><a href="#王二找房" class="headerlink" title="王二找房"></a>王二找房</h3><p>王二最终找到了一个让他满意的地方，然后开始找地方住，所以他开始了繁忙的 “找房之旅” ，一开始，王二一口气就找到了三个房东</p><p><img src="https://i.loli.net/2020/12/03/SBtYkczJxvgPwIm.png" alt="mediator-wanger-zufang.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">房东一 = <span class="hljs-number">10</span>平米，无窗<br>房东二 = <span class="hljs-number">20</span>平米，半个窗<br>房东三 = <span class="hljs-number">1000</span>平米，<span class="hljs-number">108</span>个窗<br></code></pre></td></tr></table></figure><p>找了很多，王二也没找到自己心仪的，而此时的王二已经累了。</p><p><img src="https://i.loli.net/2020/12/03/RdHNVnpkZlYjXtf.png" alt="mediator-wanger-zufang2.png"></p><p>最后经历了第 10 个房东的时候，王二终于找到自己满意的房子了。</p><p><del><strong>通过这件事我们知道了买房的重要性</strong></del></p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><h3 id="王二入职-1"><a href="#王二入职-1" class="headerlink" title="王二入职"></a>王二入职</h3><p>如果你是这家公司的人事，你会怎么来安排一个新同事的到来的各种事情呢，或者说怎么管理公司间同事的交叉问题呢？</p><p>如果是我的话，我会制定一个专员负责管理同事间的诉求，比如人事专员、行政专员等等，当然还可以设立其他专员来解决这种类似的问题。</p><p>有了专员之后，专员就负责在各种业务流程上起引导督促等作用。比如刚刚王二入职，人事专员需负责跟踪引导其完成入职知道可以开展工作之前的相关事项。于此同时，王二只需要和人事专员进行通信，其中间的流程步骤变得清晰了很多。</p><p>王二：“你好，我这里没有电脑”</p><p>人事专员：“已经再给你申请了，稍等”</p><p>王二：“好的”</p><p>过了，20分钟</p><p>设备管理员：“电脑登记好了，给你吧”</p><p>人事专员：“好的，我给王二送过去，<strong>你也不认识他</strong>”；</p><p>人事专员：“王二，这是你的电脑，编号在背面，有什么问题再联系我”</p><p>通过专员的加入，解耦了各个同事之间的耦合，同时降低了各个同事间复杂的交互，<del>也避免了不必要的“人才流失”</del></p><p><img src="https://i.loli.net/2020/12/03/XYe7vWomLqV3FKs.png" alt="mediator-wanger-ruzhi2.png"></p><h3 id="王二找房-1"><a href="#王二找房-1" class="headerlink" title="王二找房"></a>王二找房</h3><p>因为有了输入就会有输出，王二给市场上输入了一种“找房”的需求，市场自然而然的反馈回来一个输出，那就是“房屋中介”</p><p>当有了“房屋中介”的加入，王二就没那么辛苦了，并且各个房东的资源因为在“房屋中介”这也会让“租房”变得高效起来。</p><p><img src="https://i.loli.net/2020/12/03/NUi32SgBvtb6X4E.png" alt="mediator-wanger-zufang3.png"></p><h2 id="中介者模式类图-📌"><a href="#中介者模式类图-📌" class="headerlink" title="中介者模式类图 📌"></a>中介者模式类图 📌</h2><p><img src="https://i.loli.net/2020/12/03/hHZYAVLNRWvd2za.png" alt="mediator-UML.png"></p><p>模式结构：</p><ol><li>中介者接口 Mediator</li><li>具体中介者 ConcreteMediator</li><li>同事抽象类 Colleague</li><li>具体同事 ConcreteColleague</li></ol><p><em>多学一点：在设计模式中发现几乎所有的模式结构图中，都会有接口或者抽象类，这其实是依赖倒置的默认思路，任何的程序设计这一点原则都要优先考虑。</em></p><h2 id="代码-📃"><a href="#代码-📃" class="headerlink" title="代码 📃"></a>代码 📃</h2><blockquote><p>篇幅和过长代码展示原因：完整代码关注回复 “ <strong>源码</strong> “ 获取。</p></blockquote><p>这里通过王二入职案例的解决方案为背景，用程序来表示一下如何解决多个对象间复杂交错导致程序难以维护最终崩溃（离职）的问题。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HRTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;<br>        HR hr = <span class="hljs-keyword">new</span> HR();<br>        DeviceManager deviceManager = <span class="hljs-keyword">new</span> DeviceManager(hr);<br>        hr.addColleague(deviceManager);<br>        WangEr wangEr = <span class="hljs-keyword">new</span> WangEr(hr);<br>        hr.addColleague(wangEr);<br>        WangZai wangZai = <span class="hljs-keyword">new</span> WangZai(hr);<br>        hr.addColleague(wangZai);<br><br>        wangEr.send(<span class="hljs-string">&quot;我没有电脑&quot;</span>);<br>        deviceManager.send(<span class="hljs-string">&quot;设备管理员下发一台电脑&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">设备管理员收到消息：我没有电脑<br>王二收到消息：设备管理员下发一台电脑<br></code></pre></td></tr></table></figure><h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p><strong>解决的问题</strong></p><ol><li>在 1 对多对象关系中，可以通过 <code>中介者模式</code> 来解耦，达成 1 对 1 的松耦合关系。</li></ol><p><strong>存在的问题</strong></p><ol><li><code>中介者模式</code> 自身有个隐患问题，就是中介者自己本身知道了太多的内容。稍有不慎，就会导致 <code>同事</code> 的信息出现问题。</li><li>由于 <code>中介者模式</code>  本身的原因，这个 <code>中介者</code> 会变得特别复杂。（对象间的复杂转换成成了类复杂，两权相害取其轻的道理。）</li><li>在 多对多 的问题上，最好仔细的考虑一下，甚至考虑要不要用这种模式。</li></ol>]]></content>
    
    
    <summary type="html">　　“还记得你到单位入职的第一天吗？你有没有遇到文中‘王二’的事呢？”</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>状态模式：从工作状态，再到订单状态一点点深入学习状态模式</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-state.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-state.html</id>
    <published>2020-12-04T13:20:32.000Z</published>
    <updated>2020-12-04T13:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><blockquote><p>允许一个对象在其内部状态发生改变时改变其行为能力。</p></blockquote><p>我刚开始看到这个模式的时候，没啥感觉，不知道这东西要说的是个啥，后来看了个案例，渐渐清楚了，这个模式本身还是比较简单的。</p><h2 id="小菜的工作状态"><a href="#小菜的工作状态" class="headerlink" title="小菜的工作状态"></a>小菜的工作状态</h2><blockquote><p>这个案例出自程杰的《大话设计模式》，抽取案例模型，完整案例还请大家自行阅读</p></blockquote><p>案例说的是主人公“小菜”上班写代码时的各种状态，上午的时候精神饱满，中午时有点萎靡，下午状态一般，晚上状态疲惫。然后这一天各个时段的写代码状态用程序表达出来是这个样子的；</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Work</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> clock;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 上午 9 点</span><br>        clock = <span class="hljs-number">9</span>;<br>        writeCode();<br>        <span class="hljs-comment">// 中午 12 点</span><br>        clock = <span class="hljs-number">12</span>;<br>        writeCode();<br>        <span class="hljs-comment">// 下午 15 点</span><br>        clock = <span class="hljs-number">15</span>;<br>        writeCode();<br>        <span class="hljs-comment">// 晚上 21 点</span><br>        clock = <span class="hljs-number">21</span>;<br>        writeCode();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (clock &lt; <span class="hljs-number">12</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;精神抖擞写代码&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clock &lt; <span class="hljs-number">13</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;饿了困了写代码&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clock &lt; <span class="hljs-number">17</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;状态一般写代码&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clock &lt; <span class="hljs-number">23</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;加班疲惫写代码&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一段典型的面向过程编程代码，之后根据面向对象的思想来改了一版变成了这样。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OOPWork</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Working working = <span class="hljs-keyword">new</span> Working();<br>        <span class="hljs-comment">// 上午 9 点</span><br>        working.clock = <span class="hljs-number">9</span>;<br>        working.writeCode();<br>        <span class="hljs-comment">// 中午 12 点</span><br>        working.clock = <span class="hljs-number">12</span>;<br>        working.writeCode();<br>        <span class="hljs-comment">// 下午 15 点</span><br>        working.clock = <span class="hljs-number">15</span>;<br>        working.writeCode();<br>        <span class="hljs-comment">// 晚上 21 点</span><br>        working.clock = <span class="hljs-number">21</span>;<br>        working.writeCode();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Working</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> clock;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (clock &lt; <span class="hljs-number">12</span>) &#123;<br>            <span class="hljs-keyword">new</span> MorningState();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clock &lt; <span class="hljs-number">13</span>) &#123;<br>            <span class="hljs-keyword">new</span> NoonState();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clock &lt; <span class="hljs-number">17</span>) &#123;<br>            <span class="hljs-keyword">new</span> AfterNoonState();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clock &lt; <span class="hljs-number">23</span>) &#123;<br>            <span class="hljs-keyword">new</span> EveningState();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MorningState</span> </span>&#123;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;精神抖擞写代码&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoonState</span> </span>&#123;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;饿了困了写代码&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AfterNoonState</span> </span>&#123;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;状态一般写代码&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EveningState</span> </span>&#123;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;加班疲惫写代码&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实写到这里我相信大家就算没看过这本书也能多少发现一点端倪，就是这个 Working 类是不是有点奇怪。每新增一个状态就要去改这个类，而且这里负责了全部的工作状态，还有最关键的就是这个 <code>if else</code> 是不是有点太长了？？？没错，其实这些都可以用 <code>状态模式</code> 来规避掉，并且这些在软件设计中也都违反了一些原则或建议。</p><ol><li>每新增一个状态就要去改这个类（违反了 <code>开闭原则</code>）</li><li>而且这里负责了全部的工作状态（违反了 <code>单一职责原则</code>）</li><li>还有最关键的就是这个 <code>if else</code> 是不是有点太长了？？？（这是 <code>重构</code> 书中提到的 <code>long method</code> 的坏味道）</li></ol><h2 id="利用状态模式解决这-3-个问题"><a href="#利用状态模式解决这-3-个问题" class="headerlink" title="利用状态模式解决这 3 个问题"></a>利用状态模式解决这 3 个问题</h2><p>首先来看下状态模式的结构类图</p><h3 id="状态模式类图-📌"><a href="#状态模式类图-📌" class="headerlink" title="状态模式类图 📌"></a>状态模式类图 📌</h3><p><img src="https://i.loli.net/2020/11/29/YWsdEVzrgFheG3A.png" alt="state-UML"></p><p>这里有几个关键的角色</p><ol><li>运行的上下文环境 <code>Context</code> 对应到程序中就是 <code>Working</code> 类</li><li>状态接口 <code>State</code> 这是为了解决单一职责和开闭原则；</li><li>具体的状态，也就是 <code>State</code> 接口的实现</li></ol><h3 id="状态模式代码-📃"><a href="#状态模式代码-📃" class="headerlink" title="状态模式代码 📃"></a>状态模式代码 📃</h3><p>将上面的写法改成用状态模式的话就长这个样子</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writeCode</span><span class="hljs-params">()</span> </span>&#123;<br>    Working working = <span class="hljs-keyword">new</span> Working(<span class="hljs-keyword">new</span> MorningState());<br>    <span class="hljs-comment">// 手动模拟不同时刻</span><br>    working.setClock(<span class="hljs-number">9</span>);<br>    working.writeCode();<br><br>    working.setClock(<span class="hljs-number">12</span>);<br>    working.writeCode();<br><br>    working.setClock(<span class="hljs-number">15</span>);<br>    working.writeCode();<br><br>    working.setClock(<span class="hljs-number">21</span>);<br>    working.writeCode();<br><br><br>    working.setClock(<span class="hljs-number">24</span>);<br>    working.writeCode();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Working</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前工作状态</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WorkState concurrentState;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前时刻</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> clock;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Working</span><span class="hljs-params">(WorkState concurrentState)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.concurrentState = concurrentState;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeCode</span><span class="hljs-params">()</span> </span>&#123;<br>        concurrentState.handle(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    ....<br>    ....<br>    <span class="hljs-comment">// 篇幅原因，完整代码关注回复“源码”获取。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">精神抖擞写代码<br>饿了困了写代码<br>状态一般写代码<br>加班疲惫写代码<br>别再写了，程序员回家了，明早再试吧😢，现在都已经<span class="hljs-number">24</span>点了。放过他吧<br></code></pre></td></tr></table></figure><blockquote><p>篇幅原因，完整代码关注回复“源码”获取。</p></blockquote><p>这样不仅消除了 <code>if else</code> 的臃肿 <code>long method</code> 坏味道代码，同时 Working 类更专注 “写代码”，同时有 <code>State</code> 接口的出现，实现了开闭原则，让程序的扩展的到了保障，并且一个关键的内容就是“在不同时刻，调用 writeCode 方法的结果是不同的。这也是状态模式的定义中提到的 <code>一个对象在其内部状态发生改变时改变其行为能力。</code> 改变对象的一个状态，使他的行为也发生了变化，这看起来就像我们对这个类的代码进行了修改一样。</p><h2 id="状态模式延伸"><a href="#状态模式延伸" class="headerlink" title="状态模式延伸"></a>状态模式延伸</h2><p>如果大家有做过交易系统的订单的话，有一个东西应该不会陌生，叫做 <code>有限状态机</code> 也叫做 <code>状态机</code>。</p><p><img src="https://i.loli.net/2020/11/29/ODt68sjlZchYk3M.png" alt="state-order"></p><p>这是正常情况，也就是如果一个订单按照正常步骤来流转是会按照上图所示来进行。但是，真实的订单场景远比这个要复杂的多。</p><p>这里我们只看一些简单的几个场景：</p><ol><li>提交订单之后突然心思转变，不买了，那这个时候给客户就是<code>取消订单</code>和<code>付款</code>两种选择，这一步发生的时候，订单状态为 <code>待付款</code>；</li><li>付款之后又看了看发现有更好的店铺选择，此时钱已经付了，所以此时的操作提供给客户的就是 <code>申请退款</code>，此时订单状态为 <code>待发货</code>；</li><li>等等订单场景较为复杂，不过万变不离其宗，即 <code>不同的状态，用户的操作行为和这笔订单之后的行为是有限的</code>；</li></ol><p>用一个图来看下上述几个问题场景</p><p><img src="https://i.loli.net/2020/11/29/gbnuih81x7ZYMBr.png" alt="state-exception-order"></p><p>我们可以通过图可以看到，即使只有这简单的两种情况，整个订单的处理逻辑就已经开始变得复杂了起来，如果利用传统的面向过程编程或简单的面向对象编程思路来设计这个订单流程逻辑，我想，第一版，也就是正常的订单流程开发实现起来问题应该“不大”，无非代码啰嗦一点、判断逻辑多一点。</p><p>不过一旦产品经理提出在付款时可以进行撤单操作、在发货时可以进行退款、发货前可以修改接收地址又或者收货时可以拒收等等这些需求时，我觉得这个业务应该不会有人愿意去开发了。</p><p>不是开发人员不愿意做这个业务，而是不愿意在糟糕的代码上进行再次迭代（当然在现实情况，一个糟糕的团队确有可能继续在糟糕的代码上继续迭代，原因很简单，因为他们从一开始便能设计出来，领导能通过就说明这是一个没有技术沉淀的团队，他们很愿意将一坨坨代码“至死不渝”的一直维护下去）。</p><p>如果订单状态利用 <code>状态模式</code> 来设计，无论状态如何变化，高层模块也永远不需要关心，这也是开闭与单一职责这两个原则的很好体现。在哪个状态能做哪些事情，完全有对应的状态说了算，即使在复杂的业务，也会因为状态的区分而是业务颗粒变得很小（如果传统的 <code>if else</code> 到底，整个业务流程必须全部重新测试一遍，这不是谁说的，这是由高耦合紧密设计决定的，逃不开），这一点在开发和测试上，都会大幅提高开发和测试效率和节省成本。</p><p>好了，关于这一块内容确实大家可以看看 <code>有限状态机</code> ，订单业务在实际情况是交由 <code>状态机</code> 来管理的。</p><h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>当你的应用程序可能会存在多种状态，而且每种状态的行为会随着状态的改变而改变，这时你可以考虑使用状态模式。通过状态模式不光可以使应用程序可以和应用状态可以很好的解耦，同时在状态的管理和扩展上都是非常的有帮助。</p><p>状态模式关键的几个点：</p><ol><li>应用环境的上下文，这个是用来作为状态模式的入口，他负责来调用当前状态的执行方法。</li><li>状态接口，这个接口负责管理全部的状态，这里在使用的时候需要好好设计，可以将整个业务所有的状态方法全部维护好，在具体接口类中间放一个抽象状态类，如果当前状态不能操作这个方法可以放在一个抽象类中来实现一个空方法，而不是子类去实现全部的接口方法。</li></ol><p>设计模式是一把双刃剑，在合理的时机使用可以达到很好的应用效果，反之亦然。大家要谨慎对待。不要变成手里只有一把锤子的人。</p>]]></content>
    
    
    <summary type="html">　　“从工作状态，再到订单状态一点点深入学习状态模式”</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>命令模式：如果把请求变成一个对象，在一些场景更好用！</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-command.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-command.html</id>
    <published>2020-12-03T13:20:32.000Z</published>
    <updated>2020-12-03T13:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/img_convert/4b0c6fc7d3e8ee4f4a942c404366a274.png#pic_center" alt="土方令"></p><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><blockquote><p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天一大早就来了图书馆🏫，刚坐下来就迫不及待的开始看命令模式的相关资料📚。不过这个模式跟我之前的理解出入特别大。</p><p>最开始的时候，我以为的命令模式就是<code>函数回调</code>。但后来发现并不是，但他们两个确实是有关系，这一切的答案都藏在 GOF 的设计模式一书中。</p><h2 id="开始学习"><a href="#开始学习" class="headerlink" title="开始学习"></a>开始学习</h2><p>在软件设计模式之始 GOF 的原著中，命令模式的讲解还是在他们开发的那个编辑工具中，其用来讲解的案例就是我们日常编辑使用的编辑工具中，在工具栏有很多个功能按钮，或者菜单按钮。 就比如编辑工具中的一个 <code>新增文件</code> 的按钮🆕吧。GOF 要表达的意思就是，这个 <code>新增文件</code> 对系统本身来讲就是给使用者提供的一个命令，我们在用的过程中可以给编辑器发送不同的命令，但是这个 <code>新增文件</code> 的操作并不是在这个按钮上实现的，同时对于我们发送命令的人来说，也不知道具体这个 <code>新增文件</code> 这个动作是由谁来执行、怎么执行，这对我们来讲完全是透明的。</p><p>我们先不讨论这样做的好处，先看下这里面要说的几个角色</p><ol><li>客户端应用</li><li><code>新增文件</code>按钮（调用新增文件操作命令）</li><li>操作命令</li><li>操作接收（负责具体的操作执行）</li></ol><p>我试着按照这个结构写了一下这个代码</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        FileReceiver fileReceiver = <span class="hljs-keyword">new</span> FileReceiver();<br>        AddFileCommand addFileCommand = <span class="hljs-keyword">new</span> AddFileCommand(fileReceiver);<br>        Invoker invoker = <span class="hljs-keyword">new</span> Invoker();<br>        invoker.setCommand(addFileCommand);<br>        invoker.executeCommand();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>客户端应用 <code>Client</code></li><li><code>新增文件</code>按钮（调用新增文件操作）<code>Invoker</code></li><li>操作命令 <code>AddFileCommand</code></li><li>操作接收者 <code>FileReceiver</code></li></ol><figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">新增文件<br></code></pre></td></tr></table></figure><h2 id="关于-‘命令’-的疑惑-🤔"><a href="#关于-‘命令’-的疑惑-🤔" class="headerlink" title="关于 ‘命令’ 的疑惑 🤔"></a>关于 ‘命令’ 的疑惑 🤔</h2><p>按照上面的方式实现下来，我有一种感觉，有种脱裤子放屁的感觉，我直接调用 FileReceiver 不香吗</p><p>非要这样</p><p><img src="https://i.loli.net/2020/11/28/oqEZfATCtK2UuQk.png" alt="command.png"></p><p>我以为，使用者利用按钮直接调用对应的操作不就行了吗？就像我下面这样中间非要放一个命令对象（将具体的请求包装成了这个对象）？</p><p><img src="https://i.loli.net/2020/11/28/SiylpQUYxGRAb91.png" alt="command-no-command"></p><h2 id="解惑-‘命令’-🤪"><a href="#解惑-‘命令’-🤪" class="headerlink" title="解惑 ‘命令’ 🤪"></a>解惑 ‘命令’ 🤪</h2><p>不过不久我就找到了答案💡</p><p>首先看下命令模式要解决的问题❔：<u>对请求排队、下载或记录请求日志，以及支持可撤消的操作。</u></p><p>然后我们开始思考🤔如果没有中间这个 “命令” 角色，那这些功能做在哪里？只能做在接收者，也就是逻辑具体的实现里面，那这是不是违背了一个设计原则，叫做 <code>单一职责原则</code> ？而且对这种 ”辅助型“ 的功能变多会导致逻辑实现类<strong>变得越来越”肿胀“</strong>，没错，就是”肿胀“！</p><p>并且这也使得调用者和实现者之间通过这个“命令”进行解耦，然后我们使用依赖倒置原则，将“命令”提取出来一个抽象类，这使得扩展请求也变得容易了。而且对于高层模块来说，自己完全不需要关心调用的时候具体的请求内容和实现内容，通过“命令”来完成自己的操作，比如点一个按钮、遥控器下的按键（从这里还可以看出，多个命令可以对应一个接受者，比如数字键的换台）、去餐厅点菜。这样一看，命令模式还真是符合这种设计思路的命名啊。</p><h2 id="命令模式类图-📌"><a href="#命令模式类图-📌" class="headerlink" title="命令模式类图 📌"></a>命令模式类图 📌</h2><p><img src="https://i.loli.net/2020/11/28/8HJOtxMFsq6PjoE.png" alt="command-UML"></p><p>主要结构</p><ol><li>调用者，也是暴露给客户端的对象 <code>Invoker</code></li><li>命令接口，<code>Command</code>（满足依赖倒置原则，便于扩展）</li><li>具体的命令，这里要包含谁来接受这个命令的接受者对象 <code>ConcreteCommand</code></li><li>命令的接收者，这里没有列实现类是因为任何类都可以是接收者 <code>Receiver</code></li></ol><h2 id="代码-📃"><a href="#代码-📃" class="headerlink" title="代码 📃"></a>代码 📃</h2><p>命令模式这篇使用的是通用框架写了一个实现，在这基础上事实上我们可以做很多扩展，比如再 <code>Invoker</code> 类中将 command 换成 <code>List&lt;Command&gt;</code> 来实现请求的排队、撤销等操作。</p><p><img src="https://i.loli.net/2020/12/03/ZE2fTd4FHQYhxeo.png" alt="image-20201128142121299"></p><h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p><strong>适用场景：</strong></p><ol><li>需要记录请求记录；</li><li>请求可以进行排队处理；</li><li>请求可以进行撤销、重做；</li><li>具体接收者来决定请求是否执行（关于这一点，如果请求不是封装成一个对象的话，判断起来是比较困难的）</li></ol><p>不过这种模式并不是一个常用的思想，一定是当你想要对请求做一些事情的时候才考虑，具体的事情就上面提到的 4 点，不然的话使用这种模式真的就是我上面说的，“脱裤子放屁了”。</p><p>最后再来一句话来总结一下命令模式，“张三，把门关一下”。这里我就是 Invoker，“把门关一下“ 就是 command （命令），“张三” 是 receiver （接收者）。更多时候，我们实际开发中，”把门关一下“ 都是定义好的，”我“直接选就行了，就像遥控器上的按键一样。但切记这个模式的使用时机，别做”恶心“人的事！</p><p>如果哪里有问题或者有疑问，欢迎加我微信（lvgocc）讨论，或者直接进群交流！天凉了🥶🥶，进群一起取暖也好啊😁，等你~</p>]]></content>
    
    
    <summary type="html">　　“如果把请求变成一个对象，在一些场景更好用！”</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>迭代器模式：你真的“会”遍历list吗？</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-iterator.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-iterator.html</id>
    <published>2020-12-02T13:20:32.000Z</published>
    <updated>2020-12-02T13:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/img_convert/ef7aed4c24f3d2f219e4ea4451a2e3c9.png#pic_center" alt="海尔"></p><h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><blockquote><p>提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p></blockquote><p>在看迭代器模式之前，我觉得应该来研究一段代码开开胃先。</p><h2 id="Java-中的-List-集合遍历"><a href="#Java-中的-List-集合遍历" class="headerlink" title="Java 中的 List 集合遍历"></a>Java 中的 List 集合遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Appetizer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;String&gt; strings = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>            strings.add(<span class="hljs-string">&quot;第&quot;</span> + i + <span class="hljs-string">&quot;个元素&quot;</span>);<br>        &#125;<br>        Iterator&lt;String&gt; iterator = strings.iterator();<br>        <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>         iterator.next();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码很简单，我们在日常开发中可能也是经常使用到。有的人可能会说了，啊不对，我用的都是</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strings.size(); i++)<br></code></pre></td></tr></table></figure><p>还有的朋友说了，我直接用增强<code>for</code>循环啊</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(String s : Strings)<br></code></pre></td></tr></table></figure><p>是的，没错。在日常开发中，或多或少的人会用以上两种方式来进行一个列表的遍历。那这两者有什么区别呢？让我们通过编译出来的 <code>class</code>  文件来一探究竟吧。</p><p>这里使用三种不同的写法来遍历一个 list</p><p><strong>java 源码文件</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 使用迭代器遍历</span><br>Iterator&lt;String&gt; iterator = strings.iterator();<br><span class="hljs-keyword">while</span>(iterator.hasNext())<br>iterator.next()<br><br><span class="hljs-comment">// 2. jdk 8 提供的 lambda 写法</span><br>strings.forEach(System.out::println);<br><br><span class="hljs-comment">// 3. 增强 for 循环写法</span><br><span class="hljs-keyword">for</span> (String string : strings) &#123;<br>    System.out.println(string);<br>&#125;<br><br><span class="hljs-comment">// 4. 下标遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strings.size(); i++) &#123;<br>    System.out.println(strings.get(i));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>class 反编译的 java 文件内容</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 使用迭代器遍历</span><br>Iterator&lt;String&gt; iterator = strings.iterator();<br><span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>    iterator.next();<br>&#125;<br><br><span class="hljs-comment">// 2. jdk 8 提供的 lambda 写法</span><br>var10001 = System.out;<br>strings.forEach(var10001::println);<br>Iterator var3 = strings.iterator();<br><br><span class="hljs-comment">// 3. 增强 for 循环写法</span><br><span class="hljs-keyword">while</span>(var3.hasNext()) &#123;<br>    String string = (String)var3.next();<br>    System.out.println(string);<br>&#125;<br><br><span class="hljs-comment">// 4. 下标遍历</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strings.size(); ++i) &#123;<br>    System.out.println((String)strings.get(i));<br>&#125;<br></code></pre></td></tr></table></figure><p>第一种和第三种可以算为同一种，所以就只剩下三种迭代方式</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 增强 for 循环（迭代器）</span><br><span class="hljs-keyword">for</span>(String s : Strings)<br><span class="hljs-comment">// 2. JDK8 的 forEach 方法</span><br>Strings.forEach()<br><span class="hljs-comment">// 3. 下标遍历</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strings.size(); i++)<br></code></pre></td></tr></table></figure><p>接下来我们用数据来看一下这几种方式的表现情况</p><p><strong>第一次</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">测试方法：iterator<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">21</span><br>-----------------------------<br>测试方法：forEach<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">132</span><br>-----------------------------<br>测试方法：增强 <span class="hljs-keyword">for</span> 循环<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">18</span><br>-----------------------------<br>测试方法：下标遍历<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">1</span><br>-----------------------------<br></code></pre></td></tr></table></figure><p><strong>第二次</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">测试方法：iterator<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">17</span><br>-----------------------------<br>测试方法：forEach<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">123</span><br>-----------------------------<br>测试方法：增强 <span class="hljs-keyword">for</span> 循环<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">12</span><br>-----------------------------<br>测试方法：下标遍历<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">3</span><br>-----------------------------<br></code></pre></td></tr></table></figure><p><strong>第三次</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">测试方法：iterator<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">18</span><br>-----------------------------<br>测试方法：forEach<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">119</span><br>-----------------------------<br>测试方法：增强 <span class="hljs-keyword">for</span> 循环<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">14</span><br>-----------------------------<br>测试方法：下标遍历<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">2</span><br>-----------------------------<br></code></pre></td></tr></table></figure><p>为了更直观的展示，我整理了一张统计图</p><p><img src="https://i.loli.net/2020/11/28/VR5IWpXJtTPgKAB.png" alt="10万-1250万数据量4种方式遍历list统计图"></p><p>通过数据也证实了 迭代器 和 增强 for 循环的写法效果相同。</p><h2 id="List-集合到底该如何遍历"><a href="#List-集合到底该如何遍历" class="headerlink" title="List 集合到底该如何遍历"></a>List 集合到底该如何遍历</h2><p>其实乍一看数据，应该用下标遍历这种方式啊，当然，正常是这样的，这是因数组的下标索引决定的它的访问时间复杂度O(1)，同时 JDK 也为 <code>ArrayList</code> 增加了</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RandomAccess</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>标记。标记其为随机访问集合。</p><p><img src="https://i.loli.net/2020/11/28/XqV1x3iUp5YCQjk.png" alt="run-faster-than"></p><p>Java 官方给出的遍历说明：根据经验，下标要比迭代器更快。</p><p>当然，根据我们对数据的测试表现情况来看，当你的数据量低于30w时，这个时间差基本是没有任何影响的，我想，这一切应该得益于当下处理器的计算能力以及内存更高的数据交互速度吧。所以你用以上的 4 种方式都是没有问题的。但是如果你遍历的数据量大于100w时，一定要使用下标遍历了。</p><p>关于 List 集合的遍历，我们就讨论这么多，更主要的是我们要讨论一下上面提到的一个东西，“迭代器”</p><blockquote><p>文末关注回复“源码”获取本文测试使用代码及图表数据</p></blockquote><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>我通过上面的开胃菜知道，迭代器是用来遍历集合的，或者说它是用来遍历的。</p><p>这个时候我们就想了，那刚刚的列表不用这个迭代器速度反而更快，用它还慢还麻烦，为什么要用它呢？</p><p>我们可以想象一下，如果此时的数据结构不是数组，而是链表、是树、是图呢？</p><p>集合本身的目的是存取，目的明确，但如果我们在集合本身增加了遍历操作的话，我们可以看看下图。</p><p><img src="iterator-collection.png" alt="iterator-collection.png"></p><blockquote><p>图片来源：<a href="https://refactoringguru.cn/design-patterns/iterator">https://refactoringguru.cn/design-patterns/iterator</a></p></blockquote><p>假如对于一个链表，我们开始想要以 DFS 方式遍历，写好了一个算法在集合类中，后面发现有需要 BFS 方式遍历这个集合，以目前这种方式，就只能去修改集合类，再加一个方法。如果哪天发现这两个都不合适，又要加一个呢，慢慢的，集合本身的存取目的开始变得不明确，这其实是因为违反了<code>单一职责</code>原则。</p><p>致使遍历访问的问题需要被单独解决。于是迭代器就出现了，它要解决的问题就是用来遍历集合，同时它并不需要去关注具体要遍历的集合是什么样的数据结构。这里我们可以回想一下刚刚测试遍历列表的操作，迭代器在迭代的时候，它知道遍历的具体的数据结构是什么吗？不知道，对于一个迭代器来讲，它只需要关注如何将集合的数据完整无缺的取出来就好了。</p><p>这样，迭代器的概念就捋清了，再看看迭代器模式的定义</p><blockquote><p>提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p></blockquote><p>接下来我们就看看 JDK 中是怎么样用这个迭代器模式来设计集合遍历程序的。go！</p><h2 id="迭代器模式类图-📌"><a href="#迭代器模式类图-📌" class="headerlink" title="迭代器模式类图 📌"></a>迭代器模式类图 📌</h2><p><img src="https://i.loli.net/2020/11/28/4doaxqQrbWgUhvM.png" alt="iterator-JDK-UML"></p><p>下面是根据 JDK 的类直接生成的 UML 类图</p><blockquote><p>注意：并非全部类生成的 UML 类图，这里去掉了一些无关类。</p></blockquote><p><img src="https://i.loli.net/2020/11/28/LSbEmXAoFpGnN8U.png" alt="iterator-idea-UML.png"></p><h2 id="代码-📃"><a href="#代码-📃" class="headerlink" title="代码 📃"></a>代码 📃</h2><p>因为迭代器模式是围绕 JDK 的 iterator 来学习的，所以这里具体的迭代器模式的实现代码就没有自己实现，不过这里学习了 JDK 的代码。我就简单记录一下 JDK 的实现思路。</p><ol><li>定义一个可被迭代的约束类，表示其子类可以被迭代器迭代，这里用的是 <code>Iterable</code>接口。</li><li>定义迭代器接口，其子类为具体的迭代器实现。这里说的是<code>Iterator</code> 接口。</li><li>可被遍历的集合实现<code>Iterable</code> 接口，比如 <code>ArrayList</code>。</li><li>具体迭代器的实现<code>Iterator</code>接口，JDK 使用的 ArrayList 的内部类 Itr 来实现的这个接口。</li><li>迭代器中的提供一个顺序访问的规则，然后通过顺位标识调用集合的“get”方法。</li></ol><p>为了直观表示这个”get”方法，我贴几个迭代器的 next() 实现关键部分代码。</p><p><strong>ArrayList</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-comment">// 这里的 elementData[i] 就是我上面说的 “get” 方法</span><br>    <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>LinkedList</strong>(使用的是 AbstractList 的迭代器)</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 这里的 get 就是我上面说的 “get” 方法</span><br>    E next = get(i);<br>    <span class="hljs-keyword">return</span> next;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>HashSet/HashMap</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 这里的 nextNode() 就是我上面说的 “get” 方法</span><br>    <span class="hljs-keyword">return</span> nextNode().key;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">nextNode</span><span class="hljs-params">()</span> </span>&#123;<br>    Node&lt;K,V&gt;[] t;<br>    Node&lt;K,V&gt; e = next;<br>    <span class="hljs-keyword">if</span> ((next = (current = e).next) == <span class="hljs-keyword">null</span> &amp;&amp; (t = table) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-keyword">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> e;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上内容可以配合 JDK 源码了解，下面列一些涉及类或方法位置</p><ol><li><code>Iterable.java</code></li><li><code>Iterator.java</code></li><li><code>ArrayList.java</code></li><li><code>java/util/ArrayList.java:846</code> （jdk8）</li></ol><h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><ol><li>迭代器模式主要解决的问题就是集合的遍历与集合访问要进行合理的划分职责，这满足了<strong>单一职责</strong>原则。集合类本身专注集合的存取，迭代器专注集合的遍历。</li><li>同时迭代器在实现的过程中不需要关注待遍历集合的数据结构，因为它会使用目标集合的“get”方法来按序读取集合元素。所以这使得了同一个迭代器可以遍历不同的集合，同样的同一个集合也可以用不同的迭代器来进行遍历。</li><li>因为有了迭代器接口和可被迭代的集合接口两个接口的设计方式可以在集合或迭代器的扩展上提供很好的支持，这也满足了<strong>开闭原则。</strong></li><li><strong>这个模式基本不会使用。除非你有自己的数据结构和对他们的遍历规则时。</strong></li></ol>]]></content>
    
    
    <summary type="html">　　你真的“会”遍历list吗？</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>备忘录模式：这款游戏你玩过吗？是不是经常”重来“？</title>
    <link href="http://lvgo.org/post/lvgo-design-patterns-memento.html"/>
    <id>http://lvgo.org/post/lvgo-design-patterns-memento.html</id>
    <published>2020-12-01T13:20:32.000Z</published>
    <updated>2020-12-01T13:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="备忘录（Memento）模式"><a href="#备忘录（Memento）模式" class="headerlink" title="备忘录（Memento）模式"></a>备忘录（Memento）模式</h1><blockquote><p>在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</p></blockquote><p>还记得那些年你的游戏存档吗？</p><p><strong>Don’t Starve</strong></p><p><img src="https://i.loli.net/2020/11/28/uWjlqrXoOhPLIxY.jpg" alt="Don&#39;t Starve.jpg"></p><p><strong>unascribed-game1</strong></p><p><img src="https://i.loli.net/2020/11/28/18vxNgFbsJpASw6.jpg" alt="unascribed-game.jpg"></p><p><strong>unascribed-game2</strong></p><p><img src="https://i.loli.net/2020/11/28/Dl5H9G82FkpO4P1.jpg" alt="unascribed-game2.jpg"></p><h2 id="自己实现一个简易版的游戏存档功能"><a href="#自己实现一个简易版的游戏存档功能" class="headerlink" title="自己实现一个简易版的游戏存档功能"></a>自己实现一个简易版的游戏存档功能</h2><p>今天写一个游戏存档功能练习一下编码基本功。</p><p><strong>需求分析</strong></p><ol><li>需要有个管理存档的角色，那么多个存档总要有人来管啊，想存档或者读档需要它说了算。</li><li>还需要有个具体的存档对象，方便我们管理呀。</li></ol><p><strong>需求设计</strong></p><ol><li>存档对象的管理角色 Caretaker 管理存档对象</li><li>存档对象 Memento 具体的存档对象</li><li>存档的创建者 Originator 管理“存档”这件事，创建恢复存档。</li></ol><h2 id="代码-📃"><a href="#代码-📃" class="headerlink" title="代码 📃"></a>代码 📃</h2><blockquote><p>完整源码关注回复“源码获取”</p></blockquote><p><img src="https://i.loli.net/2020/11/28/ODChyStnGzM47Lo.png" alt="memento-source"></p><p>测试结果</p><p><img src="https://i.loli.net/2020/11/28/57jB1tPbwWDsdJR.png" alt="memento-test"></p><p><strong>展示存档列表</strong></p><p><img src="https://i.loli.net/2020/11/28/9SrAQZD465qW1zl.png" alt="memento-list-test"></p><h2 id="备忘录模式类图-📌"><a href="#备忘录模式类图-📌" class="headerlink" title="备忘录模式类图 📌"></a>备忘录模式类图 📌</h2><p><img src="https://i.loli.net/2020/11/28/hHtJlIPN9OTw4KL.png" alt="memento-UML1"></p><p>上面的代码是以这种类图方式实现的，不过这在 Java 中显然有可以优化的地方。即将 Caretaker 角色优化掉。优化后的类图</p><p><img src="https://i.loli.net/2020/11/28/GNXw8MnRPskxbSh.png" alt="memento-UML2"></p><blockquote><p>两个写法的完整源码关注回复“源码获取”，优化版代码在 optimization 目录中</p></blockquote><h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>由于备忘录模式使用这种代码构建的方式在 Java 中并不多，这要得益于 Java 的 <code>Serializable</code> 接口，可以使用序列化来完成备份的操作。所以只是简单的使用一个游戏存档案例记录一下这个知识点，配合学习理解的最好的再就应该是文档编辑功能中的 <code>ctrl+z</code>了。</p><p>备忘录模式可以使我们对一个对象的状态进行保存，在需要的时候快速恢复。不得不说的就是备忘录模式如果保存的大量的对象时，内存的占用还是需要关注一下的。在备忘录模式中保存对象的时候，可以配合原型模式来一起使用。</p><p>最后，这个模式在 Java 中应该不太香，原因上面也说了。所以<strong>我对这个设计模式仅作为了解</strong>，真正要使用它的话我还是会尽可能的考虑使用 <code>Serializable</code>。</p><p><strong>优点：</strong>无侵入备份/恢复对象状态（<strong>在 Java 里不是很香</strong>）。</p><p><strong>缺点：</strong>GOF 中的写法在 Java 中<strong>不香</strong>，同时使用这种模式需考虑内存占用问题。</p>]]></content>
    
    
    <summary type="html">　　这款游戏你玩过吗？是不是经常”重来“？</summary>
    
    
    
    <category term="设计模式" scheme="http://lvgo.org/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lvgo.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
