<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>7个阻塞队列</title>
    <url>//post/java-juc-blockingqueue.html</url>
    <content><![CDATA[<blockquote>
<p>眼睛看到的不是你的，但你看到之后将其思想复刻后的产物便是你的。（什么是借鉴？）</p>
</blockquote>
<a id="more"></a>

<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>本文抱着互相学习分享、技术积累使其慢慢沉淀的态度写作，如有错误望各位大佬同仁指正。</p>
<p><em>文中出现代码来自 jdk 1.8</em></p>
<p><strong>队列</strong></p>
<blockquote>
<p>FIFO(先进先出)的数据结构即为队列</p>
</blockquote>
<p>阻塞队列</p>
<blockquote>
<p>操作会被阻塞的队列即为阻塞队列, 在java中 BlockingQueue 接口在 Queue 接口的基础上增加了两组阻塞方法, offer(e,time) put , poll(time) take()</p>
</blockquote>
<h2 id="我也来说一说Java的7个阻塞队列"><a href="#我也来说一说Java的7个阻塞队列" class="headerlink" title="我也来说一说Java的7个阻塞队列"></a>我也来说一说Java的7个阻塞队列</h2><ul>
<li>有界: 在创建队列时必须或允许指定队列大小, 允许调用抛出异常的 add 方法</li>
<li>无界: 在创建队列时无需或不可以指定队列大小, 无限制的插入 add = offer 操作</li>
</ul>
<p>阻塞队列的几个操作方法</p>
<table>
<thead>
<tr>
<th></th>
<th>抛出异常</th>
<th>特殊值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<h3 id="1-ArrayBlockingQueue-有界"><a href="#1-ArrayBlockingQueue-有界" class="headerlink" title="1. ArrayBlockingQueue[有界]"></a>1. ArrayBlockingQueue[有界]</h3><p>一个使用数组实现的有界阻塞队列. 创建队列时必须给定队列大小, 同时可以通过创建队列的时候设置公平访问(通过重入锁的公平访问实现)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity, <span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>        <span class="hljs-keyword">this</span>.items = <span class="hljs-keyword">new</span> Object[capacity];<br>        lock = <span class="hljs-keyword">new</span> ReentrantLock(fair);<br>        notEmpty = lock.newCondition();<br>        notFull =  lock.newCondition();<br>    &#125;<br></code></pre></td></tr></table></figure>



<h4 id="元素达到队列容量上限时再入队"><a href="#元素达到队列容量上限时再入队" class="headerlink" title="元素达到队列容量上限时再入队"></a>元素达到队列容量上限时再入队</h4><p> 根据调用不同的方法, 返回不同的状态</p>
<p><strong>add 方法将抛出异常</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (offer(e))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Queue full&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><strong>offer 方法将返回 false</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        checkNotNull(e);<br>        <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (count == items.length)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                enqueue(e);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><strong>put 方法将无限时阻塞</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        checkNotNull(e);<br>        <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>        lock.lockInterruptibly();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (count == items.length)<br>                notFull.await();<br>            enqueue(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><strong>offer(E e, long timeout, TimeUnit unit) 将超时阻塞</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e, <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><br>        checkNotNull(e);<br>        <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);<br>        <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>        lock.lockInterruptibly();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (count == items.length) &#123;<br>                <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                nanos = notFull.awaitNanos(nanos);<br>            &#125;<br>            enqueue(e);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h4 id="队列为空时获取元素时"><a href="#队列为空时获取元素时" class="headerlink" title="队列为空时获取元素时"></a>队列为空时获取元素时</h4><p><strong>poll 方法返回空</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> (count == <span class="hljs-number">0</span>) ? <span class="hljs-keyword">null</span> : dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>take 将无限时阻塞</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">take</span>(<span class="hljs-params"></span>) throws InterruptedException</span> &#123;<br>    final ReentrantLock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">this</span>.<span class="hljs-keyword">lock</span>;<br>    <span class="hljs-keyword">lock</span>.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>            notEmpty.<span class="hljs-keyword">await</span>();<br>        <span class="hljs-keyword">return</span> dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">lock</span>.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>poll(long timeout, TimeUnit unit) 超时阻塞</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            nanos = notEmpty.awaitNanos(nanos);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结 :</strong></p>
<ol>
<li>数组有界队列</li>
<li>可加入公平策略</li>
<li>插入时提供了可抛出异常操作</li>
<li>插入元素不能为空</li>
</ol>
<blockquote>
<p>该队列模式适合在需要公平访问的场景下使用, 若无公平性要求该队列个人拙见不建议使用, 因操作数组和公平性原因,其吞吐量较低</p>
</blockquote>
<hr>
<h3 id="2-LinkedBlockingQueue-有界"><a href="#2-LinkedBlockingQueue-有界" class="headerlink" title="2. LinkedBlockingQueue[有界]"></a>2. LinkedBlockingQueue[有界]</h3><p>一个使用链表实现的有界队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedBlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>    <span class="hljs-keyword">this</span>.capacity = capacity;<br>    last = head = <span class="hljs-keyword">new</span> Node&lt;E&gt;(<span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果不指定大小, 默认值为 int 的最大值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedBlockingQueue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(Integer.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="元素达到队列容量上限时再入队-1"><a href="#元素达到队列容量上限时再入队-1" class="headerlink" title="元素达到队列容量上限时再入队"></a>元素达到队列容量上限时再入队</h4><h4 id="队列为空时获取元素时-1"><a href="#队列为空时获取元素时-1" class="headerlink" title="队列为空时获取元素时"></a>队列为空时获取元素时</h4><p>与 [ArrayBlockingQueue](#1. ArrayBlockingQueue[有界]) 相同</p>
<p><strong>总结:</strong></p>
<ol>
<li>结论不指定队列大小, 默认值为 int 最大值</li>
<li>吞吐量要比ArrayBlockingQueue高</li>
<li>链表有界队列</li>
<li>不可加入公平策略</li>
<li>插入时提供了可抛出异常操作</li>
<li>插入元素不能为空</li>
</ol>
<hr>
<h3 id="3-LinkedBlockingDeque-有界"><a href="#3-LinkedBlockingDeque-有界" class="headerlink" title="3. LinkedBlockingDeque[有界]"></a>3. LinkedBlockingDeque[有界]</h3><p>通过链表实现的一个双端阻塞队列(LikedBlockingQueue增加了队尾的操作)</p>
<p>该队列增加了一组队首队尾的操作方法</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">add</span> -&gt;</span> addFirst(push)/addLast<br><br><span class="hljs-function"><span class="hljs-title">offer</span> -&gt;</span> offerFirst/offerLast<br><br><span class="hljs-function"><span class="hljs-title">offer</span>(<span class="hljs-built_in">time</span>) -&gt;</span>offerFirst(<span class="hljs-built_in">time</span>)/offerLast(<span class="hljs-built_in">time</span>)<br><br><span class="hljs-function"><span class="hljs-title">peek</span> -&gt;</span> peekFirst/peekLast<br><br><span class="hljs-function"><span class="hljs-title">poll</span> -&gt;</span> pollFirst/pollLast<br><br><span class="hljs-function"><span class="hljs-title">poll</span>(<span class="hljs-built_in">time</span>) -&gt;</span> pollFirst(<span class="hljs-built_in">time</span>)/pollLast(<span class="hljs-built_in">time</span>)<br><br><span class="hljs-function"><span class="hljs-title">put</span> -&gt;</span> putFrist/putLast<br></code></pre></td></tr></table></figure>

<p>增加类(add/put/offer) 原方法调用与其调用相同前缀last方法操作相同</p>
<p><code>例: add = addLast ; put = putLast</code></p>
<p>获取类(peek/poll/element) 原方法调用与其调用相同前缀first方法操作相同</p>
<p><code>例: peek = peekFirst; poll = peekFirst</code></p>
<h4 id="元素达到队列容量上限时再入队-2"><a href="#元素达到队列容量上限时再入队-2" class="headerlink" title="元素达到队列容量上限时再入队"></a>元素达到队列容量上限时再入队</h4><p>add 方法在队列容量达到最大值时抛出异常  <code> throw new IllegalStateException(&quot;Deque full&quot;);</code></p>
<h4 id="队列为空时获取元素时-2"><a href="#队列为空时获取元素时-2" class="headerlink" title="队列为空时获取元素时"></a>队列为空时获取元素时</h4><p>element/getFirst/getLast 方法在队列为空时抛出异常 <code>if (x == null) throw new NoSuchElementException();</code></p>
<p><strong>总结 :</strong></p>
<ol>
<li>如果创建队列时不指定队列大小, 默认值为 int 最大值</li>
<li>吞吐量要比LinkedBlockingQueue高</li>
<li>链表有界双端队列</li>
<li>不可加入公平策略</li>
<li>插入时提供了可抛出异常操作</li>
<li>插入元素不能为空</li>
<li>可以通过队首队尾插入或取出元素</li>
</ol>
<hr>
<h3 id="4-LinkedTransferQueue-无界"><a href="#4-LinkedTransferQueue-无界" class="headerlink" title="4. LinkedTransferQueue[无界]"></a>4. LinkedTransferQueue[无界]</h3><p>一个由链表实现的无界转换队列, 相对 [LinkedBlockingQueue](#2. LinkedBlockingQueue[有界]) 增加了几个方法</p>
<h4 id="1-transfer-E-e"><a href="#1-transfer-E-e" class="headerlink" title="1.transfer(E e)"></a>1.transfer(E e)</h4><blockquote>
<p>等待消费者调用返回</p>
</blockquote>
<p>向队列的调用阻塞者直接提供元素, 如果没有人来获取, 则将这个元素放入队尾, 当这个元素出队的时候返回, 否则一直阻塞</p>
<h4 id="2-tryTransfer-E-e"><a href="#2-tryTransfer-E-e" class="headerlink" title="2.tryTransfer(E e)"></a>2.tryTransfer(E e)</h4><blockquote>
<p>调用一次即返回</p>
</blockquote>
<p>尝试向队列的调用阻塞者直接提供元素, 立即返回false or true, 提供的元素不入队.</p>
<h4 id="3-tryTransfer-E-e-long-timeout-TimeUnit-unit"><a href="#3-tryTransfer-E-e-long-timeout-TimeUnit-unit" class="headerlink" title="3.tryTransfer(E e, long timeout, TimeUnit unit)"></a>3.tryTransfer(E e, long timeout, TimeUnit unit)</h4><blockquote>
<p>等待消费者调用返回, 一定时间内等不到亦返回</p>
</blockquote>
<p>在 tryTransfer 的基础上加入了时间, 在给定时间内尝试</p>
<p>如果有阻塞调用者直接调用该队列的take 或者 poll(time) 方法, 阻塞状态下返回该值</p>
<p>如果未有阻塞调用者调用, 将元素放入队尾, 当在给定时间内被调用 返回 true, 如果在给定时间内未被调用, 返回false 且元素从队列中移除.</p>
<p><strong>总结 :</strong></p>
<ol>
<li>创建时无需指定队列大小, 且无最大值即无阻塞插入知道内存溢出</li>
<li>吞吐量要比LinkedBlockingQueue高</li>
<li>链表无界队列</li>
<li>在调用队列元素被阻塞时, 提供了可以将入队元素直接返回的 transfer方法</li>
<li>插入元素不能为空</li>
</ol>
<hr>
<h3 id="5-PriorityBlockingQueue-无界"><a href="#5-PriorityBlockingQueue-无界" class="headerlink" title="5. PriorityBlockingQueue[无界]"></a>5. PriorityBlockingQueue[无界]</h3><p>一个使用数组 + 比较器实现的优先级队列</p>
<p>这个队列使用了二叉堆排序的方式来实现优先级</p>
<p>关于这个队列的重点内容也是在二叉堆排序上, 这里延伸的内容还是比较多的, 堆结构, 二叉堆, 堆排序, 选择排序….</p>
<p><strong>总结 :</strong></p>
<ol>
<li>如果创建队列时不指定队列大小, 默认值为 11, 超出时不会阻塞而是扩容(当扩容超过 int 最大值 - 8 时将抛出堆内存溢出异常) 每次扩容为当前队列大小的 50%</li>
<li>数组无界队列(最大长度 int最大值 - 8)</li>
<li>如果指定了比较器, 则必须指定大小</li>
<li>插入元素不能为空</li>
</ol>
<hr>
<h3 id="6-DelayQueue-无界"><a href="#6-DelayQueue-无界" class="headerlink" title="6. DelayQueue[无界]"></a>6. DelayQueue[无界]</h3><p>使用 PriorityQueue 实现的一个无界延迟队列, 使用这个队列需要自己实现一些内容, 包括延迟配置、比较器的实现。该队列可以用于定时任务调度，周期任务调度</p>
<p>当你需要指定元素的优先级，执行的时机，那这个队列即是不二之选。</p>
<p><strong>总结 :</strong></p>
<ol>
<li>元素存储使用的 priorityqueue</li>
<li>可以指定元素的访问延迟时间及优先级</li>
<li>插入元素不能为空</li>
</ol>
<hr>
<h3 id="7-SynchronousQueue-无容量"><a href="#7-SynchronousQueue-无容量" class="headerlink" title="7. SynchronousQueue[无容量]"></a>7. SynchronousQueue[无容量]</h3><p>dual queue + dual stack   双队列 + 双栈实现</p>
<p>这个队列也是一个比较特殊的队列, 在 JDK 1.6的时候改写了底层实现, 就是用了上面提到的方法.</p>
<p>这个队列是一个没有容量的队列，所以在调用方法上有一些不同。</p>
<p>add 方法将会抛出一个 <code>java.lang.IllegalStateException: Queue full</code>异常</p>
<p>offer 方法会返回false</p>
<p>put 方法将会被阻塞</p>
<p>调用出队方法也会有一些问题</p>
<p>poll 方法返回null</p>
<p>take 方法将被阻塞</p>
<p>同步执行入队和出队即可, 这也是为什么该队列是吞吐量最高的队列原因</p>
<p><strong>总结 :</strong></p>
<ol>
<li>没有容量</li>
<li>吞吐量要比ArrayBlockingQueue与LinkedBlockingQueue高</li>
<li>可加入公平策略</li>
<li>插入时提供了可抛出异常操作</li>
<li>插入元素不能为空</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 显示图片的指定位置图像 ImageView ImageButton</title>
    <url>//post/problem-android-imageView.html</url>
    <content><![CDATA[<h3 id="问题出现"><a href="#问题出现" class="headerlink" title="问题出现"></a>问题出现</h3><p>UI提供了一些图标素材，但是是在一张图片上 如图：</p>
<a id="more"></a>

<p><img src="/images/posts/problem-android-imageView/20180812183216164.png" alt="UI提供的图"></p>
<p><code>产品需要在页面下方横排显示三个按钮</code></p>
<p><img src="/images/posts/problem-android-imageView/2018-08-12_183322.png" alt="产品需要的图"></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>废话不多说，网上搜了一下，大多都是通过代码重新绘制。因为我比较粗俗，所以自己找到了一种解决办法。</p>
<h4 id="心历路程"><a href="#心历路程" class="headerlink" title="心历路程"></a>心历路程</h4><blockquote>
<p>设置scaleType的值来实现</p>
</blockquote>
<p>根据查阅资料了解Image相关view的属性值了解到</p>
<p>对于android:scaleType属性，因为关于图像在ImageView中的显示效果，所以有如下属性值可以选择：</p>
<ul>
<li>matrix：使用matrix方式进行缩放。</li>
<li>fitXY：横向、纵向独立缩放，以适应该ImageView。</li>
<li>fitStart:保持纵横比缩放图片，并且将图片放在ImageView的左上角。</li>
<li>fitCenter：保持纵横比缩放图片，缩放完成后将图片放在ImageView的中央。</li>
<li>fitEnd：保持纵横比缩放图片，缩放完成后将图片放在ImageView的右下角。</li>
<li>center：把图片放在ImageView的中央，但是不进行任何缩放。</li>
<li>centerCrop：保持纵横比缩放图片，以使图片能完全覆盖ImageView。</li>
<li>centerInside：保持纵横比缩放图片，以使得ImageView能完全显示该图片。</li>
</ul>
<p>由于我这里UI提供的图片比较特殊，所以第一张和第二张的图片分别可以通过设置 <code>matrix</code>和<code>center</code>获取到</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">&lt;ImageButton<br>      android:<span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;@+id/qq_login&quot;</span><br>      android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span><br>      android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;47dp&quot;</span><br>      android:<span class="hljs-attribute">layout_marginBottom</span>=<span class="hljs-string">&quot;100dp&quot;</span><br>      android:<span class="hljs-attribute">layout_marginLeft</span>=<span class="hljs-string">&quot;100dp&quot;</span><br>      android:<span class="hljs-attribute">layout_marginStart</span>=<span class="hljs-string">&quot;100dp&quot;</span><br>      android:<span class="hljs-attribute">background</span>=<span class="hljs-string">&quot;&quot;</span><br>      android:<span class="hljs-attribute">contentDescription</span>=<span class="hljs-string">&quot;@string/qq_login_content_description&quot;</span><br>      android:<span class="hljs-attribute">scaleType</span>=<span class="hljs-string">&quot;matrix&quot;</span><br>      app:<span class="hljs-attribute">layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span><br>      app:<span class="hljs-attribute">layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span><br>      app:<span class="hljs-attribute">srcCompat</span>=<span class="hljs-string">&quot;@drawable/login&quot;</span> /&gt;<br></code></pre></td></tr></table></figure>
<p><img src="/images/posts/problem-android-imageView/2018-08-12_184259.png"></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">&lt;ImageButton<br>    android:<span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;@+id/wx_login&quot;</span><br>    android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span><br>    android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;47dp&quot;</span><br>    android:<span class="hljs-attribute">layout_marginBottom</span>=<span class="hljs-string">&quot;100dp&quot;</span><br>    android:<span class="hljs-attribute">layout_marginEnd</span>=<span class="hljs-string">&quot;8dp&quot;</span><br>    android:<span class="hljs-attribute">layout_marginLeft</span>=<span class="hljs-string">&quot;8dp&quot;</span><br>    android:<span class="hljs-attribute">layout_marginRight</span>=<span class="hljs-string">&quot;8dp&quot;</span><br>    android:<span class="hljs-attribute">layout_marginStart</span>=<span class="hljs-string">&quot;8dp&quot;</span><br>    android:<span class="hljs-attribute">background</span>=<span class="hljs-string">&quot;&quot;</span><br>    android:<span class="hljs-attribute">contentDescription</span>=<span class="hljs-string">&quot;@string/wb_login_content_description&quot;</span><br>    android:<span class="hljs-attribute">scaleType</span>=<span class="hljs-string">&quot;centerCrop&quot;</span><br>    app:<span class="hljs-attribute">layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span><br>    app:<span class="hljs-attribute">layout_constraintEnd_toStartOf</span>=<span class="hljs-string">&quot;@+id/wb_login&quot;</span><br>    app:<span class="hljs-attribute">layout_constraintStart_toEndOf</span>=<span class="hljs-string">&quot;@+id/qq_login&quot;</span><br>    app:<span class="hljs-attribute">srcCompat</span>=<span class="hljs-string">&quot;@drawable/login&quot;</span> /&gt;<br><br></code></pre></td></tr></table></figure>

<p><img src="/images/posts/problem-android-imageView/2018-08-12_184312.png"></p>
<p>到上面的时候,心里还是美滋滋,只要这样下去,不超过5分钟,我的图就画好了.<strong>可是接着尴尬的问题出现了</strong></p>
<p>第三张的图片怎么取?? WTF??? <s>此处省略18分钟</s></p>
<hr>
<h4 id="终极方案-完美解决"><a href="#终极方案-完美解决" class="headerlink" title="终极方案,完美解决"></a>终极方案,完美解决</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">&lt;ImageButton<br>    android:<span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;@+id/qq_login&quot;</span><br>    android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;47dp&quot;</span><br>    android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;47dp&quot;</span><br>    android:<span class="hljs-attribute">paddingTop</span>=<span class="hljs-string">&quot;94dp&quot;</span><br>    android:<span class="hljs-attribute">layout_marginBottom</span>=<span class="hljs-string">&quot;100dp&quot;</span><br>    android:<span class="hljs-attribute">layout_marginLeft</span>=<span class="hljs-string">&quot;100dp&quot;</span><br>    android:<span class="hljs-attribute">layout_marginStart</span>=<span class="hljs-string">&quot;100dp&quot;</span><br>    android:<span class="hljs-attribute">background</span>=<span class="hljs-string">&quot;@null&quot;</span><br>    android:<span class="hljs-attribute">contentDescription</span>=<span class="hljs-string">&quot;@string/qq_login_content_description&quot;</span><br>    app:<span class="hljs-attribute">layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span><br>    app:<span class="hljs-attribute">layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span><br>    app:<span class="hljs-attribute">srcCompat</span>=<span class="hljs-string">&quot;@drawable/login&quot;</span> /&gt;<br><br>&lt;ImageButton<br>    android:<span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;@+id/wx_login&quot;</span><br>    android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;47dp&quot;</span><br>    android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;47dp&quot;</span><br>    android:<span class="hljs-attribute">layout_marginBottom</span>=<span class="hljs-string">&quot;100dp&quot;</span><br>    android:<span class="hljs-attribute">layout_marginEnd</span>=<span class="hljs-string">&quot;8dp&quot;</span><br>    android:<span class="hljs-attribute">layout_marginLeft</span>=<span class="hljs-string">&quot;8dp&quot;</span><br>    android:<span class="hljs-attribute">layout_marginRight</span>=<span class="hljs-string">&quot;8dp&quot;</span><br>    android:<span class="hljs-attribute">layout_marginStart</span>=<span class="hljs-string">&quot;8dp&quot;</span><br>    android:<span class="hljs-attribute">background</span>=<span class="hljs-string">&quot;@null&quot;</span><br>    android:<span class="hljs-attribute">contentDescription</span>=<span class="hljs-string">&quot;@string/wx_login_content_description&quot;</span><br>    app:<span class="hljs-attribute">layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span><br>    app:<span class="hljs-attribute">layout_constraintEnd_toStartOf</span>=<span class="hljs-string">&quot;@+id/wb_login&quot;</span><br>    app:<span class="hljs-attribute">layout_constraintStart_toEndOf</span>=<span class="hljs-string">&quot;@+id/qq_login&quot;</span><br>    app:<span class="hljs-attribute">srcCompat</span>=<span class="hljs-string">&quot;@drawable/login&quot;</span> /&gt;<br><br>&lt;ImageButton<br>    android:<span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;@+id/wb_login&quot;</span><br>    android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;47dp&quot;</span><br>    android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;47dp&quot;</span><br>    android:<span class="hljs-attribute">layout_marginBottom</span>=<span class="hljs-string">&quot;100dp&quot;</span><br>    android:<span class="hljs-attribute">layout_marginEnd</span>=<span class="hljs-string">&quot;100dp&quot;</span><br>    android:<span class="hljs-attribute">layout_marginRight</span>=<span class="hljs-string">&quot;100dp&quot;</span><br>    android:<span class="hljs-attribute">paddingBottom</span>=<span class="hljs-string">&quot;94dp&quot;</span><br>    android:<span class="hljs-attribute">background</span>=<span class="hljs-string">&quot;@null&quot;</span><br>    android:<span class="hljs-attribute">contentDescription</span>=<span class="hljs-string">&quot;@string/wb_login_content_description&quot;</span><br>    app:<span class="hljs-attribute">layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span><br>    app:<span class="hljs-attribute">layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span><br>    app:<span class="hljs-attribute">srcCompat</span>=<span class="hljs-string">&quot;@drawable/login&quot;</span> /&gt;<br></code></pre></td></tr></table></figure>
<p><img src="/images/posts/problem-android-imageView/2018-08-12_191847.png" alt="最终效果"></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS及相关内容</title>
    <url>//post/java-juc-aqs.html</url>
    <content><![CDATA[<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>源码位置 : java.util.concurrent.locks.AbstractQueuedSynchronizer</p>
<p>AQS 意为队列同步器, 实际它就是 locks 包下的一个工具组件, 它出现的目的即为所有出现的自定义锁服务的.</p>
<a id="more"></a>

<p><img src="/images/posts/java-juc-aqs/20200918221401665.png" alt="AQS所涉及的一些类"></p>
<h2 id="AQS所涉及的一些类"><a href="#AQS所涉及的一些类" class="headerlink" title="AQS所涉及的一些类"></a>AQS所涉及的一些类</h2><ul>
<li>AQS本身, AbstractQueuedSynchronizer.class</li>
<li>AQS的队列元素 Node.class</li>
<li>java的锁接口, Lock.class</li>
<li>自定义锁的监视器 Condition.class</li>
<li>自定义锁的实现基于 LockSupport</li>
</ul>
<h2 id="AbstractQueuedSynchronizer-class"><a href="#AbstractQueuedSynchronizer-class" class="headerlink" title="AbstractQueuedSynchronizer.class"></a>AbstractQueuedSynchronizer.class</h2><p>AQS中主要维护了一个由内部类Node组成的一个队列</p>
<p>同时有3个重要的变量 volatile Node head; volatile Node tail; volatile int state; 都是用 volatile 修饰保证其可见</p>
<p><img src="/images/posts/java-juc-aqs/20200918221415153.png"></p>
<h2 id="Node-class"><a href="#Node-class" class="headerlink" title="Node.class"></a>Node.class</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br><br>		<span class="hljs-comment">// 如果是共享节点, 等待队列后继节点为此常量</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AbstractQueuedSynchronizer.Node SHARED = <span class="hljs-keyword">new</span> AbstractQueuedSynchronizer.Node();<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AbstractQueuedSynchronizer.Node EXCLUSIVE = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 标识为已取消</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 后继节点为等待状态, 可被唤醒, 同时也标识该状态下节点的后继节点应该被阻塞, 处于同步队列中</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL = -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 调用了 condition 的 awaite 方法, 使当前线程处在等待队列中</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 共享锁</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;<br>        <span class="hljs-comment">// 前驱</span><br>        <span class="hljs-keyword">volatile</span> AbstractQueuedSynchronizer.Node prev;<br>        <span class="hljs-comment">// 同步队列后继</span><br>        <span class="hljs-keyword">volatile</span> AbstractQueuedSynchronizer.Node next;<br>        <span class="hljs-comment">// 同步状态线程</span><br>        <span class="hljs-keyword">volatile</span> Thread thread;<br>        <span class="hljs-comment">// 等待队列后继</span><br>        AbstractQueuedSynchronizer.Node nextWaiter;<br><br>        <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isShared</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nextWaiter == SHARED;<br>        &#125;<br><br>        <span class="hljs-keyword">final</span> AbstractQueuedSynchronizer.<span class="hljs-function">Node <span class="hljs-title">predecessor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NullPointerException </span>&#123;<br>            AbstractQueuedSynchronizer.Node var1 = <span class="hljs-keyword">this</span>.prev;<br>            <span class="hljs-keyword">if</span> (var1 == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> var1;<br>            &#125;<br>        &#125;<br><br>        Node() &#123;<br>        &#125;<br><br>        Node(Thread var1, AbstractQueuedSynchronizer.Node var2) &#123;<br>            <span class="hljs-keyword">this</span>.nextWaiter = var2;<br>            <span class="hljs-keyword">this</span>.thread = var1;<br>        &#125;<br><br>        Node(Thread var1, <span class="hljs-keyword">int</span> var2) &#123;<br>            <span class="hljs-keyword">this</span>.waitStatus = var2;<br>            <span class="hljs-keyword">this</span>.thread = var1;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h2 id="AQS的工作原理"><a href="#AQS的工作原理" class="headerlink" title="AQS的工作原理"></a>AQS的工作原理</h2><p>AQS中的三个关键变量</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// 队列的头节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;<br><br><span class="hljs-comment">// 队列的尾结点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;<br><br><span class="hljs-comment">// 同步状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;<br></code></pre></td></tr></table></figure>



<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>当一条线程执行到一个同步代码块时, 会进行如下几步操作</p>
<h3 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h3><ol>
<li>成功获取锁</li>
<li>执行代码</li>
<li>释放锁</li>
<li>唤醒队首节点的下一个状态小于0的节点</li>
</ol>
<h3 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h3><ol>
<li>获取锁失败</li>
<li>当前线程包装成Node对象, 将AQS中tail节点通过CAS指向自己</li>
<li>死循环判断自己的前驱节点是否为头结点, 并且尝试获取锁, 如果前驱为头结点, 同时获取锁成功<ol>
<li>将自己设置为头结点</li>
<li>将原头节点后继节点设置为null</li>
<li>执行代码</li>
<li>释放锁</li>
</ol>
</li>
<li>如果获取锁失败 (进行以下两件事, 同时返回boolean值. 条件为 1&amp;&amp; 2<ol>
<li>将队列中状态为 1(超时等待或中断线程)移除队列 并将自身前驱节点状态改为 -1, 如果为 -1 返回 true 代表需要将当前线程阻塞(停留在同步队列中)</li>
<li>阻塞当前线程并判断当前线程是否被中断</li>
</ol>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>获取锁成功 -&gt; 执行代码 -&gt; 结束</p>
<p>获取锁失败 -&gt; 进入同步队列 (在次获取锁条件: 等待前驱节点释放锁后唤醒自己) 同时在尝试获取锁失败的时候会做两件事</p>
<ol>
<li>将状态为 1 的Node节点从队列移除, 将自己的前驱节点状态改为 -1 .</li>
<li>将当前线程通过自身线程阻塞, 同时判断自申是否被中断 (如果被中断, AQS 还会调用线程的 interrupte 方法</li>
</ol>
<p>以上即非公平锁的处理过程, 在获取锁失败之后进行自循环的时候, 仍然会新线程去尝试通过 CAS 获取锁, 如果新线程获取成功, 那么同步队列的队首元素将不会被唤醒. 即非公平, 先来不一定先得. 但在队列中的线程, 是满足 FIFO 的. 即先到先得锁.</p>
<p>同时, 如果释放锁的线程, 再次尝试获取锁的概率, 会非常高.</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">sync = [Thread[Thread<span class="hljs-number">-2</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-3</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-4</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-5</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-6</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-7</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-8</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-9</span>,<span class="hljs-number">5</span>,main]]<br>sync = [Thread[Thread<span class="hljs-number">-2</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-3</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-4</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-5</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-6</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-7</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-8</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-9</span>,<span class="hljs-number">5</span>,main]]<br><br>Thread<span class="hljs-number">-1</span><br>Thread<span class="hljs-number">-0</span><br><br>sync = [Thread[Thread<span class="hljs-number">-3</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-4</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-5</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-6</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-7</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-8</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-9</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-0</span>,<span class="hljs-number">5</span>,main]]<br>sync = [Thread[Thread<span class="hljs-number">-3</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-4</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-5</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-6</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-7</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-8</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-9</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-0</span>,<span class="hljs-number">5</span>,main]]<br><br>Thread<span class="hljs-number">-1</span><br>Thread<span class="hljs-number">-2</span><br><br>sync = [Thread[Thread<span class="hljs-number">-3</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-4</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-5</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-6</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-7</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-8</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-9</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-0</span>,<span class="hljs-number">5</span>,main]]<br>sync = [Thread[Thread<span class="hljs-number">-3</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-4</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-5</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-6</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-7</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-8</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-9</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-0</span>,<span class="hljs-number">5</span>,main]]<br>Thread<span class="hljs-number">-2</span><br>Thread<span class="hljs-number">-1</span><br><br><br><br><br>sync = [Thread[Thread<span class="hljs-number">-3</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-4</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-5</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-6</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-7</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-8</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-9</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-0</span>,<span class="hljs-number">5</span>,main]]<br>sync = [Thread[Thread<span class="hljs-number">-3</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-4</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-5</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-6</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-7</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-8</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-9</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-0</span>,<span class="hljs-number">5</span>,main]]<br><br>Thread<span class="hljs-number">-2</span><br>Thread<span class="hljs-number">-1</span><br><br>sync = [Thread[Thread<span class="hljs-number">-4</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-5</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-6</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-7</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-8</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-9</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-0</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-2</span>,<span class="hljs-number">5</span>,main]]<br>sync = [Thread[Thread<span class="hljs-number">-4</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-5</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-6</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-7</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-8</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-9</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-0</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-2</span>,<span class="hljs-number">5</span>,main]]<br><br>Thread<span class="hljs-number">-1</span><br>Thread<span class="hljs-number">-3</span><br><br>sync = [Thread[Thread<span class="hljs-number">-4</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-5</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-6</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-7</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-8</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-9</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-0</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-2</span>,<span class="hljs-number">5</span>,main]]<br>sync = [Thread[Thread<span class="hljs-number">-4</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-5</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-6</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-7</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-8</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-9</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-0</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-2</span>,<span class="hljs-number">5</span>,main]]<br><br>Thread<span class="hljs-number">-1</span><br>Thread<span class="hljs-number">-3</span><br><br>sync = [Thread[Thread<span class="hljs-number">-4</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-5</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-6</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-7</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-8</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-9</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-0</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-2</span>,<span class="hljs-number">5</span>,main]]<br>sync = [Thread[Thread<span class="hljs-number">-4</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-5</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-6</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-7</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-8</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-9</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-0</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-2</span>,<span class="hljs-number">5</span>,main]]<br><br>Thread<span class="hljs-number">-1</span><br>Thread<span class="hljs-number">-3</span><br><br>sync = [Thread[Thread<span class="hljs-number">-4</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-5</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-6</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-7</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-8</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-9</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-0</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-2</span>,<span class="hljs-number">5</span>,main]]<br>sync = [Thread[Thread<span class="hljs-number">-4</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-5</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-6</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-7</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-8</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-9</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-0</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-2</span>,<span class="hljs-number">5</span>,main]]<br><br>Thread<span class="hljs-number">-1</span><br>Thread<span class="hljs-number">-3</span><br><br>sync = [Thread[Thread<span class="hljs-number">-5</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-6</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-7</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-8</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-9</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-0</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-2</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-1</span>,<span class="hljs-number">5</span>,main]]<br>sync = [Thread[Thread<span class="hljs-number">-5</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-6</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-7</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-8</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-9</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-0</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-2</span>,<span class="hljs-number">5</span>,main], Thread[Thread<span class="hljs-number">-1</span>,<span class="hljs-number">5</span>,main]]<br><br>Thread<span class="hljs-number">-3</span><br>Thread<span class="hljs-number">-4</span><br><br><br></code></pre></td></tr></table></figure>





<h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><p>在新获取锁线程与, 同步队列中的线程对锁的竞争是不公平的, 即后来的可以先获取到锁. </p>
<p>加锁方法先cas获取锁, 失败后进入队列, 锁释放之后去唤醒队首节点争抢锁的时候, 锁可能已经被新到线程获取到了.</p>
<h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p>绝对时间基础上的公平</p>
<p>与非公平锁不同, 首先进行的一步操作是</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// 当前线程非队首节点的下一个节点 返回失败, 加入同步队列</span><br>                <span class="hljs-keyword">if</span> (hasQueuedPredecessors())<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>                ...<br>                ..<br>            &#125;<br>        &#125;<br>        <br>        <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasQueuedPredecessors</span><span class="hljs-params">()</span> </span>&#123;<br><br>        Node t = tail; <span class="hljs-comment">// Read fields in reverse initialization order</span><br>        Node h = head;<br>        Node s;<br>        <span class="hljs-keyword">return</span> h != t &amp;&amp;<br>            ((s = h.next) == <span class="hljs-keyword">null</span> || s.thread != Thread.currentThread());<br>        <br>    &#125;<br></code></pre></td></tr></table></figure>

<p>完全遵循FIFO, 获取锁时先判断自己是不是下一个应该得到锁的线程.</p>
<h2 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h2><p>通过保存线程的引用地址来判断是否可以重入.</p>
<h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>通过定义信号量来做控制. 即同时可以有多少线程可以共享这把锁</p>
<h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p>获取读锁 -&gt; 获取写锁 -&gt; 释放读锁 -&gt; 获取读锁 -&gt; 释放写锁 -&gt; 释放读锁</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Failed to resolve support-fragment（已解决）</title>
    <url>//post/problem-Failed-to-resolve-support-fragment.html</url>
    <content><![CDATA[<h3 id="问题出现"><a href="#问题出现" class="headerlink" title="问题出现"></a>问题出现</h3><p>在不同电脑Android Studio上运行同一个项目，出现</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Could</span> not find support-fragment.jar (com.android.support:support-fragment:<span class="hljs-number">27</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span>).<br><span class="hljs-attribute">Searched</span> in the following locations:<br>    <span class="hljs-attribute">https</span>://jcenter.bintray.com/com/android/support/support-fragment/<span class="hljs-number">27</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span>/support-fragment-<span class="hljs-number">27</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span>.jar<br><br><span class="hljs-attribute">Please</span> install the Android Support Repository from the Android SDK Manager.<br><span class="hljs-attribute">Open</span> Android SDK Manager<br></code></pre></td></tr></table></figure>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><code class="hljs vhdl">Failed <span class="hljs-keyword">to</span> resolve: support-fragment<br><span class="hljs-keyword">Open</span> <span class="hljs-keyword">File</span><br></code></pre></td></tr></table></figure>


<hr>
<a id="more"></a>



<p>解决这个问题只需要在build.gradle文件里修改allprojects 里面的repositories，把google放到jcenter前面就可以了</p>
<p><strong>原文件</strong></p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl"><br><span class="hljs-variable">allprojects</span> &#123;<br>    <span class="hljs-variable">repositories</span> &#123;<br>        <span class="hljs-function"><span class="hljs-title">jcenter</span>()</span><br>        <span class="hljs-function"><span class="hljs-title">mavenCentral</span>()</span><br>        <span class="hljs-variable">maven</span> &#123; <span class="hljs-variable">url</span> <span class="hljs-string">&#x27;https://maven.google.com&#x27;</span> &#125;<br>        <span class="hljs-variable">maven</span> &#123; <span class="hljs-variable">url</span> <span class="hljs-string">&quot;https://dl.google.com/dl/android/maven2/&quot;</span>&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p><strong>修改后</strong></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">allprojects</span> &#123;<br>    <span class="hljs-section">repositories</span> &#123;<br>        <span class="hljs-section">maven</span> &#123; <span class="hljs-attribute">url</span> <span class="hljs-string">&#x27;https://maven.google.com&#x27;</span> &#125;<br>        jcenter()<br>        mavenCentral()<br>        maven &#123; <span class="hljs-attribute">url</span> <span class="hljs-string">&quot;https://dl.google.com/dl/android/maven2/&quot;</span>&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Intellij IDEA 配置 tomcat 远程 debug 模式</title>
    <url>//post/problem-idea-remote-debug.html</url>
    <content><![CDATA[<h3 id="一-配置服务器"><a href="#一-配置服务器" class="headerlink" title="一.配置服务器"></a>一.配置服务器</h3><p>在catalina.sh 中添加 address 调试端口 9999  <strong>catalina.sh的位置在tocmat下的bin目录</strong></p>
<blockquote>
<p>以下方法任选其一</p>
</blockquote>
<p>第一种方法</p>
<a id="more"></a>

<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">JAVA_OPTS</span>=<span class="hljs-string">&quot;-agentlib:jdwp=transport=dt_socket,address=9999,suspend=n,server=y&quot;</span><br></code></pre></td></tr></table></figure>
<p>第二种方法</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">CATALINA_OPTS</span>=<span class="hljs-string">&quot;-server -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=9999&quot;</span> <br></code></pre></td></tr></table></figure>

<h3 id="二-配置IDE"><a href="#二-配置IDE" class="headerlink" title="二.配置IDE"></a>二.配置IDE</h3><p><img src="/images/posts/problem-idea-remote-debug/20180720213720867.png" alt="编辑启动配置"></p>
<p><img src="/images/posts/problem-idea-remote-debug/2018072021380811.png" alt="点击+号,选择remote"></p>
<p><img src="/images/posts/problem-idea-remote-debug/20180720213902702.png" alt="将host改成服务器的ip地址,port改成刚配置好的端口."></p>
<hr>
<p>以debug模式运行</p>
<p>当控制台出现“Connected to the target VM, address: ‘xx.xx.xx.xx:9999’, transport: ‘socket’”的字样即可,记得加入要调试的断点.</p>
<hr>
<p>#end</p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8 Consumer &amp; Supplier 什么意思</title>
    <url>//post/jdk8-consumer-supplier.html</url>
    <content><![CDATA[<h2 id="JDK1-8-函数式接口-Consumer-amp-Supplier-以及-JAVA新纪元-λ表达式的到来"><a href="#JDK1-8-函数式接口-Consumer-amp-Supplier-以及-JAVA新纪元-λ表达式的到来" class="headerlink" title="JDK1.8 函数式接口 Consumer &amp; Supplier 以及 JAVA新纪元 λ表达式的到来"></a>JDK1.8 函数式接口 Consumer &amp; Supplier 以及 JAVA新纪元 λ表达式的到来</h2><h3 id="背景什么的被吞了-直接进入主题"><a href="#背景什么的被吞了-直接进入主题" class="headerlink" title="背景什么的被吞了,直接进入主题"></a><font color=red>背景什么的被吞了,直接进入主题</font></h3><hr>
<h3 id="函数式接口-定义自己百度-一大堆"><a href="#函数式接口-定义自己百度-一大堆" class="headerlink" title="函数式接口(定义自己百度,一大堆)"></a>函数式接口(定义自己百度,一大堆)</h3><blockquote>
<p>因为看了一些关于JDK1.8函数式接口的文章,发现基本上都是糊里糊涂一笔带过.所以就抽空赶紧整理了一下.</p>
</blockquote>
<p>还是附上几个学习了解的传送门 :</p>
<ul>
<li><a href="http://www.runoob.com/java/java8-functional-interfaces.html">菜鸟教程</a></li>
<li><a href="https://www.yiibai.com/java8/java8_functional_interfaces.html">易百教程</a></li>
<li><a href="http://www.hubwiz.com/class/57525f2eda97b6e9299d301b">汇智网</a></li>
</ul>
<hr>
<h3 id="Consumer-函数式接口"><a href="#Consumer-函数式接口" class="headerlink" title="Consumer 函数式接口"></a>Consumer 函数式接口</h3><p>JDK 源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接受单个输入参数并且不返回结果的操作。</span><br><span class="hljs-comment"> * 与大多数其他功能接口不同， Consumer预期通过副作用进行操作。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.8</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Consumer</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对给定的参数执行此操作。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> t the input argument</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(T t)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回一个组合的Consumer ，依次执行此操作，然后执行after操作。 </span><br><span class="hljs-comment">     * 如果执行任一操作会抛出异常，它将被转发到组合操作的调用者。 </span><br><span class="hljs-comment">     * 如果执行此操作会引发异常，则不会执行after操作。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> 此操作后执行的操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 一个组成的 Consumer ，依次执行 after操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NullPointerException - if after is null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Consumer&lt;T&gt; <span class="hljs-title">andThen</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; after)</span> </span>&#123;<br>        Objects.requireNonNull(after);<br>        <span class="hljs-keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;<br>    &#125;<br><br></code></pre></td></tr></table></figure>
<p>刚拿过来看的时候可能会有一些绕,但是我们换个角度来看一下.</p>
<p>Consumer 直译过来就是消费者的意思,那我们是不是可以理解成消费代码.既然他要消费,那我们就要给他提供代码.</p>
<p><strong>来看一个简单的demo</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testConsumer1</span><span class="hljs-params">()</span> </span>&#123;<br>        Consumer&lt;String&gt; consumer = <span class="hljs-keyword">new</span> Consumer&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(String s)</span> </span>&#123;<br>                System.out.println(s + <span class="hljs-string">&quot;?&quot;</span>);<br>            &#125;<br>        &#125;;<br>        consumer.accept(<span class="hljs-string">&quot;李磊&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><strong>输出结果</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">李磊?<br></code></pre></td></tr></table></figure>

<p><strong>简单解释一下</strong></p>
<p><code>Consumer </code>是一个接口,所以当我们直接使用的话,要实现其 <code>accept()</code>方法,而这个方法的参数,就是我们定义接口时候给到的泛型,这里给的是一个<code>String</code>类型,方法当中的内容,就是我们所谓的消费代码,当调用<code>accept()</code>方法时执行.</p>
<p><font color=red>注意 : 也就是上面提到的通过副作用处理,我不清楚这个单词翻译的是否准确,看了很多博主和一些机器翻译都是这个意思,但我个人的理解意思,更趋近于说是</font><font color=blue>通过侧面来解决问题.</font></p>
<p>再看一下 <code>consumer.accept(&quot;李磊&quot;)</code>这一句,这里便是真正的执行的地方,也就是调用的我们刚刚自行实现的<code>accept()</code>方法.</p>
<p><strong>让我们继续刚刚的demo往下看</strong></p>
<p>这种写法和上面在JDK1.8环境中是等价的. 主要就是利用到了1.8中的 λ 表达式.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testConsumer1</span><span class="hljs-params">()</span> </span>&#123;<br>    Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s + <span class="hljs-string">&quot;?&quot;</span>);<br>    consumer.accept(<span class="hljs-string">&quot;李磊&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><code>下面的例子均使用λ表达式完成</code></p>
<p><strong>泛型为自定义对象时</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testConsumerToSupplier</span><span class="hljs-params">()</span> </span>&#123;<br>        Consumer&lt;Person&gt; consumer = person -&gt; &#123;<br>            person.setName(<span class="hljs-string">&quot;张颖&quot;</span>);<br>            person.setSize(<span class="hljs-number">34</span>);<br>        &#125;;<br>        Person person = <span class="hljs-keyword">new</span> Person();<br>        consumer.accept(person);<br>        System.out.println(<span class="hljs-string">&quot;person = &quot;</span> + person);<br>    &#125;<br><br></code></pre></td></tr></table></figure>
<p>输入结果:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">person = Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;张颖&#x27;</span>, <span class="hljs-attribute">size</span>=34&#125;<br></code></pre></td></tr></table></figure>
<p><strong>泛型为自定义接口时</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">People</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">come</span><span class="hljs-params">(Person person)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testConsumerAndInterfaceFunction</span><span class="hljs-params">()</span> </span>&#123;<br>        Consumer&lt;People&gt; consumer = people -&gt; &#123;<br>            people.come(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">23</span>));<br>            people.come(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;找钱&quot;</span>, <span class="hljs-number">34</span>));<br>            people.come(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;孙俪&quot;</span>, <span class="hljs-number">45</span>));<br>        &#125;;<br><br>        consumer.accept(<span class="hljs-keyword">this</span>::print);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Person person)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;person = &quot;</span> + person);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">person = Person&#123;name=<span class="hljs-string">&#x27;李四&#x27;</span>, size=<span class="hljs-number">23</span>&#125;<br>person = Person&#123;name=<span class="hljs-string">&#x27;找钱&#x27;</span>, size=<span class="hljs-number">34</span>&#125;<br>person = Person&#123;name=<span class="hljs-string">&#x27;孙俪&#x27;</span>, size=<span class="hljs-number">45</span>&#125;<br></code></pre></td></tr></table></figure>
<p>如果到了这里还没有明白怎么回事,我建议你亲自动手敲上那么一遍.真的,如果还不懂来杭州,我当面给你讲.</p>
<hr>
<h3 id="Supplier-函数式接口"><a href="#Supplier-函数式接口" class="headerlink" title="Supplier 函数式接口"></a>Supplier 函数式接口</h3><p>还是一样,先看一下JDK源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得对象的一个函数式接口</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.8</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Supplier</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 得到一个对象</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 目标对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这个是不是看起来很容易理解了,<code>Supplier</code>的意思是供应商,那我们是不是可以把他理解成一个商场,然后你告诉他你想要的东西是什么样子的,它是不是就会给你了.</p>
<p><strong>来看一下这个简单的demo</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testSupplier1</span><span class="hljs-params">()</span> </span>&#123;<br>        Supplier&lt;String&gt; supplier = () -&gt; <span class="hljs-string">&quot;这是你要的字符串&quot;</span>;<br>        String str = supplier.get();<br>        System.out.println(<span class="hljs-string">&quot;str = &quot;</span> + str);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">str = 这是你要的字符串<br></code></pre></td></tr></table></figure>
<p><strong>继续自定义对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testSupplier2</span><span class="hljs-params">()</span> </span>&#123;<br>        Supplier&lt;Person&gt; supplier = () -&gt; &#123;<br>            Person person = <span class="hljs-keyword">new</span> Person();<br>            person.setName(<span class="hljs-string">&quot;张三&quot;</span>);<br>            person.setSize(<span class="hljs-number">32</span>);<br>            <span class="hljs-keyword">return</span> person;<br>        &#125;;<br><br>        Person person = supplier.get();<br>        System.out.println(<span class="hljs-string">&quot;person = &quot;</span> + person);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">person = Person&#123;name=<span class="hljs-string">&#x27;张三&#x27;</span>, size=<span class="hljs-number">32</span>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>再来刺激的自定义接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testSupplier3</span><span class="hljs-params">()</span> </span>&#123;<br>    Supplier&lt;People&gt; supplier = <span class="hljs-keyword">new</span> Supplier&lt;People&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> People <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>            People people = <span class="hljs-keyword">new</span> People() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">come</span><span class="hljs-params">(Person person)</span> </span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;person = &quot;</span> + person)<br>                &#125;<br>            &#125;;<br>            <span class="hljs-keyword">return</span> people;<br>        &#125;<br>    &#125;;<br><br>    People people = supplier.get();<br>    people.come(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">24</span>));<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">person = Person&#123;name=<span class="hljs-string">&#x27;李四&#x27;</span>, size=<span class="hljs-number">24</span>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>看好别眨眼,λ表达式的写法</strong> 下面的一行和上面的一堆是等价的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testSupplier4</span><span class="hljs-params">()</span> </span>&#123;<br>    Supplier&lt;People&gt; supplier = () -&gt; person -&gt; System.out.println(<span class="hljs-string">&quot;person = &quot;</span> + person);<br>    People people = supplier.get();<br>    people.come(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">24</span>));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">person = Person&#123;name=<span class="hljs-string">&#x27;李四&#x27;</span>, size=<span class="hljs-number">24</span>&#125;<br></code></pre></td></tr></table></figure>

<p>想必看到这你不光明白了 <code>Supplier</code>的用法,更清楚的λ表达式的用处了.</p>
<hr>
<h2 id="写在最后-写这篇文章的原因是因为在整理工厂模式的时候遇到的一些问题"><a href="#写在最后-写这篇文章的原因是因为在整理工厂模式的时候遇到的一些问题" class="headerlink" title="写在最后,写这篇文章的原因是因为在整理工厂模式的时候遇到的一些问题"></a>写在最后,写这篇文章的原因是因为在整理工厂模式的时候遇到的一些问题</h2><p>工厂模式简单的是不能再简单了,但是随着技术的发展,也出现了一些新颖的工厂方法.<code>CTS</code>便是其中之一.</p>
<p>至于<code>Consumer</code>&amp;<code>Supplier</code>应用在工厂模式的代码如下,因为比较特殊,写在了一起,想要亲自体检复制粘贴运行<code>TTT</code>类的<code>main()</code>方法即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgo</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: CTS实现工厂模式</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 18-8-24 下午3:57</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CTS</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> CTS <span class="hljs-title">getCts</span><span class="hljs-params">(Consumer&lt;Peoples&gt; consumer)</span> </span>&#123;<br>        Map&lt;String, Supplier&lt;Persons&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        consumer.accept(map::put);<br>        <span class="hljs-keyword">return</span> person -&gt; map.get(person).get();<br><br>    &#125;<br><br>    <span class="hljs-function">Persons <span class="hljs-title">getPerson</span><span class="hljs-params">(String name)</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Peoples</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">come</span><span class="hljs-params">(String name, Supplier&lt;Persons&gt; personSupplier)</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TTT</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        CTS cts = CTS.getCts(people -&gt; &#123;<br>            people.come(<span class="hljs-string">&quot;张三&quot;</span>, () -&gt; <span class="hljs-keyword">new</span> Persons(<span class="hljs-string">&quot;张三&quot;</span>));<br>            people.come(<span class="hljs-string">&quot;李四&quot;</span>, () -&gt; <span class="hljs-keyword">new</span> Persons(<span class="hljs-string">&quot;李四&quot;</span>));<br>            people.come(<span class="hljs-string">&quot;王五&quot;</span>, () -&gt; <span class="hljs-keyword">new</span> Persons(<span class="hljs-string">&quot;王五&quot;</span>));<br>        &#125;);<br><br>        Persons person = cts.getPerson(<span class="hljs-string">&quot;王五&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;persons = &quot;</span> + person);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Persons</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Persons</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Persons</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;&#125;&#x27;&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>CTS工厂模式说明: Consumer To Supplier 自造词,无处可寻,他处偶遇纯属抄袭;</p>
<p>通过<code>Peoples</code>接口的<code>come()</code>方法,可以动态在CTS工厂内添加<code>person</code>,然后使其具于生产该实例的能力.</p>
<hr>
<ul>
<li><a href="https://gitee.com/lvgo/java-design-patterns-cn/blob/master/factory/src/test/java/org/lvgo/CTS.java">本文所有源代码点我</a></li>
<li><a href="https://gitee.com/lvgo/java-design-patterns-cn">更多设计模式学习点我或浏览博客设计模式专栏查看</a></li>
</ul>
<hr>
<p>参考文献</p>
<ul>
<li><a href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612">Design Patterns: Elements of Reusable Object-Oriented Software 1st Edition</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>版本特性</category>
      </categories>
      <tags>
        <tag>JDK8</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型</title>
    <url>//post/java-juc-jmm.html</url>
    <content><![CDATA[<h1 id="Java-内存模型-JMM"><a href="#Java-内存模型-JMM" class="headerlink" title="Java 内存模型 ( JMM )"></a>Java 内存模型 ( JMM )</h1><blockquote>
<p>多线程场景下需关注 , 单线程数据竞争可以通过JMM的顺序一致性来保证, 不会出现数据竞争</p>
</blockquote>
<a id="more"></a>

<p>并发编程中, 线程间通信有两种方式</p>
<ol>
<li>共享内存(隐式)</li>
<li>消息传递(显式)</li>
</ol>
<p>而我们这里要记录的则是 Java 线程间通信使用的 <strong>共享内存</strong>, 也就是 Java 的内存是怎么样子的</p>
<h2 id="Java-内存模型基础"><a href="#Java-内存模型基础" class="headerlink" title="Java 内存模型基础"></a>Java 内存模型基础</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<p>Java 的内存对于我们开发人员来讲, 是不可见的, 是透明的.</p>
</blockquote>
<p>Java 的线程间通信使用的是 共享内存 方式进行隐式通信, 所以对于我们开发人员来讲,  这部分不可见的内容存在了很多隐患问题. </p>
<p>在 Java 中分为共享内存和私有内存, 而这些概念也是由 Java 本身自己来控制的, 并不真实存在</p>
<p>主内存: i = 1</p>
<p>线程A: 与 线程B:</p>
<p>如果线程 A 与 线程 B 间想要通信, 那么必须通过 主内存(共享内存) 来实现.  Java 通过 JMM 来控制每个线程和主内存的交互, 从而来实现开发人员对内存的可见性</p>
<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><blockquote>
<p>Java 执行过程中为了提高性能, 会对执行进行重新排序</p>
</blockquote>
<ol>
<li>编译器重排序 (不改变语义的情况下重排序)</li>
<li>指令并行重排序 (处理器多条指令并行时, 不存在数据依赖, 可以进行重排序)</li>
<li>内存系统重排序 ( 内存读写缓冲行 , 可能会重排序)</li>
</ol>
<p>第一种为 JAVA 本身的编译器重排序, 可以通过 JMM 来进行控制, 而2,3属于CPU级重排序, Java 不能直接控制, 所以 Java 使用在生成指令时在中间插入 内存屏障指令 这种方式来实现禁止重排序.</p>
<h3 id="happends-before"><a href="#happends-before" class="headerlink" title="happends - before"></a>happends - before</h3><blockquote>
<p>happends - before 规则是指, 当一个操作结束后, 结果对另一个操作可见, 其中包括</p>
</blockquote>
<ol>
<li>程序顺序 : 一个线程的每步操作</li>
<li>监视器锁释放 : 一个监视器解锁应对另一个监视器加锁可见</li>
<li>volatile变量: 一个volatile域的写, 要对其他对volatile域的读可见</li>
<li>传递性 : A happends - before B , B happends - before C , 那么 A happends - before C</li>
</ol>
<h2 id="Java-顺序一致性内存模型"><a href="#Java-顺序一致性内存模型" class="headerlink" title="Java 顺序一致性内存模型"></a>Java 顺序一致性内存模型</h2><blockquote>
<p>程序如果没有正确同步, 就会出现数据竞争问题, 相反, 如果程序设置了合理的正确同步, 那就一定不会出现数据竞争, 这一点就由JMM的顺序一致性来保证</p>
</blockquote>
<p>如果做了线程同步, 那就一定会有JMM的顺序一致性加持, 来保证数据的一致结果, 反之则不保证数据的一致性结果.</p>
<p>理想状态下的数据概念模型与我们的意图完全相符, AB两条线程, 同时对数字 1 进行加1操作, 结果 为 3</p>
<h2 id="Java-同步原语"><a href="#Java-同步原语" class="headerlink" title="Java 同步原语"></a>Java 同步原语</h2><p>Load 指令, 使缓存失效, 从主内存读取数据</p>
<p>Store 指令, 使写操作之后将内存的值刷新到主内存当中, 保证其他内存可见</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><ul>
<li><p>在每个volatile写操作前插入StoreStore屏障 </p>
<p>volatile 写</p>
<p>在写操作后插入StoreLoad屏障</p>
</li>
<li><p>在每个volatile读操作前插入LoadLoad屏障  </p>
<p>volatile 读</p>
<p>在读操作后插入LoadStore屏障</p>
</li>
</ul>
<p>StoreLoad 具备其他3个屏障的所有特性, 开销较大</p>
<p>在一个 volatile 变量读之后, 无论是什么操作, 不允许进行重排序;</p>
<p>在一个 volatile 变量写之前, 无论是什么操作, 不允许进行重排序;</p>
<p>在一个 volatile 变量写之后是 volatile 读, 不允许进行重排序;</p>
<p>对一个 volatile 变量的读/写具有可见性和原子性, 但对于 volatile 变量的运算操作不具有原子性, 比如对volatile++</p>
<blockquote>
<p>volatile写和volatile读的内存屏障插入策略非常保守。在实际执行时，只要不改变volatile写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。</p>
</blockquote>
<p>X86处理器仅会对写-读操作做重排序。</p>
<p>X86不会对读-读、读-写和写-写操作做重排序，</p>
<p>因此在X86处理器中会省略掉这3种操作类型对应的内存屏障</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul>
<li>final 写操作之后插入 StoreStore屏障</li>
<li>final 读操作之前插入 LoadLoad屏障</li>
</ul>
<p>对 final 域的写, 编译器和处理器遵循以下两个重排序规则</p>
<ol>
<li>禁止将包含final域的写入的构造函数, 与该对象的引用赋值进行重排序</li>
<li>初次读包含final域的引用 与 读取该对象中的 final 域禁止重排序</li>
</ol>
<p>对于以上两个规则, 是因为, JMM禁止编译器把 final域写重排序到构造函数之后(外面), 因为在final域写之后, return 该对象执行, 会插入一条 StoreStore 屏障</p>
<p>对于 final 域的读, JMM会进制编译器把 final 域读与之前的操作进行重排序, 在读 final 域之前会插入一个 LoadLoad 屏障, </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">例 : 对象A 定义两个变量为,  在我们使用 <br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>       	<span class="hljs-keyword">int</span> i;<br> 		<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">10</span>; <br>        <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        	<span class="hljs-keyword">this</span>.i = i;<br>        &#125;<br>    &#125;<br>    A a = <span class="hljs-keyword">new</span> A(<span class="hljs-number">10</span>); <br><br></code></pre></td></tr></table></figure>

<p>在调用 a.i 的时候, 此时有可能读不到值, 而在读 a.j 的时候则一定可以. 原因就是因为 LoadLoad 屏障的禁止重排序.</p>
<blockquote>
<p>通过以上的内容, 我们知道, 当拿到一个对象的引用的时候, 在读取该对象内final域的时候, 该值一定是初始化之后的值, 而普通对象则不一定.</p>
</blockquote>
<h3 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h3><blockquote>
<p>锁是java并发编程中最重要的同步机制。锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息</p>
</blockquote>
<p>当线程尝试释放锁时, JMM会将线程内的共享变量, 刷新到主内存当中.</p>
<p>当线程尝试获取锁是, JMM会将线程内的共享变量地址设为无效.从而临界区的变量必须从主内存当中重新获取.</p>
<p>释放锁与 volatile 写具有相同的内存语义</p>
<p>获取锁与 volatile 读具有相同的内存语义</p>
<p>Java中锁的内存语义可以通过一个锁的实现来理解, 那就是 ReentrantLock .</p>
<p>ReentrantLock 依赖 Java 中的 AQS同步框架 (AbstractQueuedSynchronizer)来实现. 该框架通过使用一个 volatile 变量来代替”信号”</p>
<p>ReentrantLock 在获取锁时, 先获取到 volatile 关键词修饰的信号 state, 在使用 CAS 将该信号量更新成已上锁的状态.在释放锁的最后, 会将这个值改为无锁状态.</p>
<p>CAS 会调用 cmpxchg 指令进行原子操作, 同样在调用处理器指令的时候, 会根据处理器类型来决定具体的执行指令, 如果在单处理器机器上执行时, 将直接执行 cmpxchg 指令, 而在多处理器机器上执行时, 会增加 Lock 前缀, 最终执行指令为, Lock cmpxchg.</p>
<p>关于  Lock 前缀, 这里简单总结一下. 在执行前增加 Lock 前缀</p>
<ol>
<li>保证了对内存操作的原子性 (通过锁内存总线来实现, 这样会使所有处理器无法访问内存数据. 所以还有另外一种情况, 即所需要操作的数据在带有 Lock 前缀指令执行之前就已经被持有该缓存行的处理器锁定, 则不会通过锁总线来完成这步指令, 因为此时的数据无法被其他处理器读取, 该操作成为缓存锁定 . 但当处理器竞争程度较高, 或指令内存地址未对齐时, 仍会锁住总线)</li>
<li>禁止重排序</li>
<li>写入缓存的值刷新到主内存中</li>
</ol>
<blockquote>
<p>concurrent 包实现的通用化模式</p>
<ol>
<li>首先, 声明 volatile 共享变量</li>
<li>然后, 使用 CAS 更新来实现线程同步</li>
<li>同时, 配合 volatile 的读/写和CAS所具有的volatile读和写的内存语义来实现线程通信</li>
</ol>
</blockquote>
<h2 id="内存模型总结"><a href="#内存模型总结" class="headerlink" title="内存模型总结"></a>内存模型总结</h2><ul>
<li>Java 内存模型</li>
<li>Java 顺序一致性内存模型</li>
<li>处理器内存模型</li>
</ul>
<p>内存模型的强弱关系</p>
<p>顺序一致性模型 &gt; 语言内存模型 &gt; 处理器内存模型</p>
<p>性能关系</p>
<p>处理器内存模型 &gt; 语言内存模型 &gt; 顺序一致性模型</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程</title>
    <url>//post/java-juc-first-concept.html</url>
    <content><![CDATA[<h1 id="Java-并发编程"><a href="#Java-并发编程" class="headerlink" title="Java 并发编程"></a>Java 并发编程</h1><h2 id="为什么要使用并发编程-多线程"><a href="#为什么要使用并发编程-多线程" class="headerlink" title="为什么要使用并发编程 (多线程)"></a>为什么要使用并发编程 (多线程)</h2><ol>
<li>科技的发展, 越来越多的机器拥有更多的处理器核心</li>
<li>多线程可以带来更快的响应速度</li>
<li>更好的编程模型</li>
</ol>
<a id="more"></a>

<h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><blockquote>
<p>首先我们所写的 Java EE 程序在启动后, 会开启一条进程来执行我们的代码. 而其中的每个逻辑处理, 就是由线程去完成的.</p>
</blockquote>
<p>线程是现代操作系统所能调度的最小单元.</p>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>在Java中, 我们可以通过 priority 属性来设置线程的优先级, 参数为 1 ~ 10 参数越大, 代表优先级越高, 默认的优先级为 5</p>
<p>而这一参数在不同的虚拟机上, 在不同的操作系统上都会有不同的表现, 甚至被忽略</p>
<p><strong>知识点: 不能依赖此值来设计线程的优先顺序, 并没有绝对意义.</strong></p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><ol>
<li>初始状态, 线程被构建, 没有调用start方法</li>
<li>运行状态, Java 将操作系统的线程”就绪”和”运行”状态统一称为”运行中”</li>
<li>阻塞状态, 线程处于阻塞时</li>
<li>等待状态, 线程进入等待状态, 此时需要等待其他线程一些动作(通知或中断)</li>
<li>超时等待状态, 此状态不同于等待状态是可以在一定时间内自动返回</li>
<li>终止状态, 表示该线程已经执行完毕</li>
</ol>
<h3 id="守护线程-Daemon"><a href="#守护线程-Daemon" class="headerlink" title="守护线程 Daemon"></a>守护线程 Daemon</h3><p>负责程序运行的一个支持性工作, 当虚拟机中不存在非 Daemon 线程的时候虚拟机将会退出.</p>
<p>可以通过 <code> setDaemon(true)</code> 来指定守护线程, 该参数必须在线程启动前设置, 启动后设置无效.</p>
<p>我来理解这个绕脑的家伙, 如果一个线程设置了 <code>setDaemon(true)</code>, 那就说明他是一个支持线程, 如果没有人需要他的时候, 他自然也就跟着退出了, 否则就会一直存在. 与启动他的线程共存. 他只是用来配合的, 没人需要的时候即退出.</p>
<p><strong>知识点 : 在守护线程中不能使用 try catch  finally { doSomeThing} , 因为当主线程退出后, 守护线程会立即退出, 并不会执行 finally 代码块内容</strong></p>
<h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><p>child线程是由 parent 线程进行空间分配, 同时会集成 parent 线程的优先级、守护线程状态、可以继承 parent 线程的 ThreadLocal</p>
<p><strong>建议：为自己创建的线程分配一个名字，不需要多响亮，为的是解决问题时更容易认出他</strong></p>
<h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>线程中断是线程中的一个标识位， 他表示一个线程是否被中断。 </p>
<p>通过调用线程的 interrupted（）方法可以查看线程是否处于中断状态</p>
<h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><p>通过锁对象的 wait() 方法来释放锁, 同时进入等待队列;</p>
<p>通过锁对象的 notify()方法来唤醒等待队列的一个元素进入阻塞队列;</p>
<p>通过岁对象的notifyAll() 方法来唤醒等待队列的全部元素进入阻塞队列;</p>
<p>当调用了锁对象的 wait() 方法, 从等待队列被唤醒, 并重新获取到锁时, 将从等待地方开始, 程序计数器+1 , 继续执行下一条指令.</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的疑难问题解决</title>
    <url>//post/course-mysql42701.html</url>
    <content><![CDATA[<h4 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h4><ol>
<li>ubuntu 16.04</li>
<li>mysql-server-5.7</li>
</ol>
<hr>
<a id="more"></a>

<h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">update</span><br>apt-<span class="hljs-keyword">get</span> installl mysql-<span class="hljs-keyword">server</span><span class="hljs-number">-5.7</span><br></code></pre></td></tr></table></figure>


<p>对于出现的提示选择 y 就好 ，然后输入root密码。安装完成</p>
<hr>
<h4 id="操作使用"><a href="#操作使用" class="headerlink" title="操作使用"></a>操作使用</h4><ol>
<li>远程连接mysql<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">mysql -h<span class="hljs-built_in"> IP </span>-P<span class="hljs-built_in"> port </span>-u root -p<br><br>mysql -h 127.0.0.1 -P 3306 -u root<br></code></pre></td></tr></table></figure>


</li>
</ol>
<blockquote>
<p>以下内容为转载</p>
</blockquote>
<p>1.<a href="https://www.cnblogs.com/xujishou/p/6306765.html%EF%BC%88MySQL5.7">https://www.cnblogs.com/xujishou/p/6306765.html（MySQL5.7</a> 添加用户、删除用户与授权）<br>2.<a href="https://www.cnblogs.com/SQL888/p/5748824.html%EF%BC%88mysql">https://www.cnblogs.com/SQL888/p/5748824.html（mysql</a> 用户及权限管理 小结）</p>
<hr>
<h4 id="疑难问题解决-（后续更新）"><a href="#疑难问题解决-（后续更新）" class="headerlink" title="疑难问题解决 （后续更新）"></a>疑难问题解决 （后续更新）</h4><p>###一、ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: NO)</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">复现<br>root@itlvgo:~# mysql<br><span class="hljs-builtin-name">ERROR</span> 1045 (28000): Access denied <span class="hljs-keyword">for</span><span class="hljs-built_in"> user </span><span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> (using password: <span class="hljs-literal">NO</span>)<br>root@itlvgo:~# mysql -uroot<br><span class="hljs-builtin-name">ERROR</span> 1045 (28000): Access denied <span class="hljs-keyword">for</span><span class="hljs-built_in"> user </span><span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> (using password: <span class="hljs-literal">NO</span>)<br><br></code></pre></td></tr></table></figure>

<p><img src="/images/posts/course-mysql42701/20180704102409229.png" alt="lvgo star dust"></p>
<p><strong>恩。原因是因为需要输入输入密码的命令，少输入了一个-p using password：NO 正确操作如下</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">root@itlvgo:~# mysql -uroot -p<br>Enter password: <br>Welcome <span class="hljs-keyword">to</span> the MySQL monitor.  Commands end with ; <span class="hljs-keyword">or</span> \g.<br>Your MySQL<span class="hljs-built_in"> connection </span>id is 14<br>Server version: 5.7.22-0ubuntu0.16.04.1 (Ubuntu)<br><br>Copyright (c) 2000, 2018, Oracle <span class="hljs-keyword">and</span>/<span class="hljs-keyword">or</span> its affiliates. All rights reserved.<br><br>Oracle is a registered trademark of Oracle Corporation <span class="hljs-keyword">and</span>/<span class="hljs-keyword">or</span> its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br><br>Type <span class="hljs-string">&#x27;help;&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;\h&#x27;</span> <span class="hljs-keyword">for</span> help.<span class="hljs-built_in"> Type </span><span class="hljs-string">&#x27;\c&#x27;</span> <span class="hljs-keyword">to</span> clear the current input statement.<br><br>mysql&gt; <br><br></code></pre></td></tr></table></figure>

<p>###二、配置用户无法外网访问（本地可以）</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">/etc/mysql/mysql.conf.d<br><br>配置如下信息<br>port=<span class="hljs-number">3306</span><br><br><span class="hljs-comment">// 原来的注释掉，默认127.0.0.1</span><br>bind-address=<span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br></code></pre></td></tr></table></figure>
<p>如果还不可以，进行下面的检查操作</p>
<ol>
<li>检查一下是否有开启防火墙；（云服务器的安全组配置）</li>
<li>如果开启不想关闭，需要开放mysql的占用端口，默认3306；</li>
<li>关闭防火墙。。<br>###三、无法存储中文<br>修改mysql配置文件<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> /etc/mysql<br><span class="hljs-keyword">vi</span> my.<span class="hljs-keyword">cnf</span><br></code></pre></td></tr></table></figure>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[client]</span><br><span class="hljs-attr">default-character-set</span>=utf8<br><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">character-set-server</span>=utf8<br></code></pre></td></tr></table></figure>
重起mysql即可<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">sudo <span class="hljs-regexp">/etc/i</span>nit.d/mysql restart<br></code></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 利用数据泵导入导出数据</title>
    <url>//post/course-oracle-import-export.html</url>
    <content><![CDATA[<p>目的：使用数据泵，将一台电脑上的数据库导出，导入到另一台电脑上的数据库。</p>
<a id="more"></a>

<h4 id="A电脑上的操作。expdp数据导出"><a href="#A电脑上的操作。expdp数据导出" class="headerlink" title="A电脑上的操作。expdp数据导出"></a>A电脑上的操作。expdp数据导出</h4><p>1、运行cmd；</p>
<p>2、登录数据库，输入命令：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">sqlplus <span class="hljs-keyword">system</span>/密码；<br></code></pre></td></tr></table></figure>
<p>3、创建目录路径：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">directory</span> backup_path <span class="hljs-keyword">as</span> ‘E:\app\tws\<span class="hljs-keyword">oradata</span>\orcldv’;  <br></code></pre></td></tr></table></figure>
<p>(backup_path为路径名称，可自命名（必须是已存在路径），E:\app\tws\oradata\orcl为源数据库路径)</p>
<p>5、导入导出操作授权：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> exp_full_database,imp_full_database <span class="hljs-keyword">to</span> dmuser;  (dmuser为数据库用户名)<br></code></pre></td></tr></table></figure>
<p>6、退出：exit;    </p>
<p>7、数据导出，执行命令：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">expdp  dmuser/***** directory=backup_path dumpfile=dmuser_schema.dmp logfile=dmuser_schema_29.<span class="hljs-built_in">log</span>;<br></code></pre></td></tr></table></figure>
<p>dmuser为用户名<br>*****为密码<br>dmuser_schema.dmp为导出数据库文件，可自命名，但格式要为.dmp，dmuser_schema_29.log为日志文件，可自命名</p>
<hr>
<h4 id="B电脑上的操作。impdp-数据导入"><a href="#B电脑上的操作。impdp-数据导入" class="headerlink" title="B电脑上的操作。impdp 数据导入"></a>B电脑上的操作。impdp 数据导入</h4><p>将导出的数据库文件复制到目标数据库路径下。</p>
<p>1、运行cmd；</p>
<p>2、登录数据库，输入命令：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">sqlplus <span class="hljs-keyword">system</span>/密码；<br></code></pre></td></tr></table></figure>
<p>3、创建目录路径：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">directory</span> goup_path <span class="hljs-keyword">as</span> ‘E:\app\tws\<span class="hljs-keyword">oradata</span>\orcl’;   <br></code></pre></td></tr></table></figure>
<p>(goup_path为路径名称，可自命名，E:\app\tws\oradata\orcl为目标数据库路径)</p>
<p>4、退出：exit;    </p>
<p>5、数据导入，执行命令：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">impdp  dmuser/*****  directory=goup_path  dumpfile=dmuser_schema.dmp  logfile=dmuser_schema_29.<span class="hljs-built_in">log</span>;<br></code></pre></td></tr></table></figure>

<h4 id="完整演示"><a href="#完整演示" class="headerlink" title="完整演示"></a>完整演示</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">create directory backup_path as <span class="hljs-string">&#x27;E:\XPAD&#x27;</span>;<br>grant exp_full_database,imp_full_database <span class="hljs-keyword">to</span> xpad706;<br>expdp xpad706/xpad706 <span class="hljs-attribute">directory</span>=backup_path <span class="hljs-attribute">dumpfile</span>=xpad706.dmp <span class="hljs-attribute">logfile</span>=xpad706.log;<br>impdp  xpad706/xpad706  <span class="hljs-attribute">directory</span>=backup_path   <span class="hljs-attribute">dumpfile</span>=xpad706.dmp  <span class="hljs-attribute">logfile</span>=impxpad706.log;<br></code></pre></td></tr></table></figure>

<h4 id="Oracle-数据泵（IMPDP-EXPDP）导入导出总结"><a href="#Oracle-数据泵（IMPDP-EXPDP）导入导出总结" class="headerlink" title="Oracle 数据泵（IMPDP/EXPDP）导入导出总结"></a>Oracle 数据泵（IMPDP/EXPDP）导入导出总结</h4><p>Oracle数据泵导入导出是日常工作中常用的基本技术之一，它相对传统的逻辑导入导出要高效，这种特性更适合数据库对象数量巨大的情形，因为我日常运维的数据库对象少则几千，多则几万甚至几十万，所以传统exp/imp就会非常耗时，而数据泵方式就因此脱引而出，下面就详细总结一下数据泵的使用方法，希望能给初学者带来帮助。</p>
<p>一、新建逻辑目录</p>
<p>   最好以system等管理员创建逻辑目录，Oracle不会自动创建实际的物理目录“D:\oracleData”（务必手动创建此目录），仅仅是进行定义逻辑路径dump_dir；</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs sql">sql&gt; conn system/123456a?@orcl as sysdba;<br><br>sql&gt;create directory dump_dir as &#x27;D:\oracleData&#x27;;<br></code></pre></td></tr></table></figure>
<p>二、查看管理员目录（同时查看操作系统是否存在该目录，因为oracle并不关心该目录是否存在，假如不存在，则出错）</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs sql">sql&gt;select * from dba_directories;<br></code></pre></td></tr></table></figure>
<p>三、用expdp导出数据</p>
<p>1)导出用户及其对象</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">expdp scott/tiger@orcl <span class="hljs-attribute">schemas</span>=scott <span class="hljs-attribute">dumpfile</span>=expdp.dmp <span class="hljs-attribute">directory</span>=dump_dir;<br></code></pre></td></tr></table></figure>
<p>2)导出指定表</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">expdp scott/tiger@orcl <span class="hljs-attribute">tables</span>=emp,dept <span class="hljs-attribute">dumpfile</span>=expdp.dmp <span class="hljs-attribute">directory</span>=dump_dir;<br></code></pre></td></tr></table></figure>
<p>3)按查询条件导</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">expdp scott/tiger@orcl <span class="hljs-attribute">directory</span>=dump_dir <span class="hljs-attribute">dumpfile</span>=expdp.dmp <span class="hljs-attribute">tables</span>=empquery=&#x27;where <span class="hljs-attribute">deptno</span>=20&#x27;;<br></code></pre></td></tr></table></figure>
<p>4)按表空间导</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">expdp system/manager@orcl <span class="hljs-attribute">directory</span>=dump_dir <span class="hljs-attribute">dumpfile</span>=tablespace.dmptablespaces=temp,example;<br></code></pre></td></tr></table></figure>
<p>5)导整个数据库</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">expdp system/manager@orcl <span class="hljs-attribute">directory</span>=dump_dir <span class="hljs-attribute">dumpfile</span>=full.dmp <span class="hljs-attribute">full</span>=y;<br></code></pre></td></tr></table></figure>
<p>四、用impdp导入数据</p>
<p>   在正式导入数据前，要先确保要导入的用户已存在，如果没有存在，请先用下述命令进行新建用户</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--创建表空间</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">tablespace</span> tb_name <span class="hljs-keyword">datafile</span> <span class="hljs-string">&#x27;D:\tablespace\tb_name.dbf&#x27;</span> <span class="hljs-keyword">size</span> <span class="hljs-number">1024</span>m <span class="hljs-keyword">AUTOEXTEND</span> <span class="hljs-keyword">ON</span>;<br><br><span class="hljs-comment">--创建用户</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> user_name <span class="hljs-keyword">identified</span> <span class="hljs-keyword">by</span> A123456a <span class="hljs-keyword">default</span> <span class="hljs-keyword">tablespace</span> tb_name <span class="hljs-keyword">temporary</span> <span class="hljs-keyword">tablespace</span> TEMP;<br><br><span class="hljs-comment">--给用户授权</span><br><br>sql&gt;grant read,write on directory dump_dir to user_name;<br><br>sql&gt;grant dba,resource,unlimited tablespace to user_name;<br></code></pre></td></tr></table></figure>
<p>1)导入用户（从用户scott导入到用户scott）</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">impdp scott/tiger@orcl <span class="hljs-attribute">directory</span>=dump_dir <span class="hljs-attribute">dumpfile</span>=expdp.dmp <span class="hljs-attribute">schemas</span>=scott;<br></code></pre></td></tr></table></figure>
<p>2)导入表（从scott用户中把表dept和emp导入到system用户中）</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">impdp system/manager@orcl <span class="hljs-attribute">directory</span>=dump_dir <span class="hljs-attribute">dumpfile</span>=expdp.dmptables=scott.dept,scott.emp <span class="hljs-attribute">remap_schema</span>=scott:system;<br></code></pre></td></tr></table></figure>
<p>3)导入表空间</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">impdp system/manager@orcl <span class="hljs-attribute">directory</span>=dump_dir <span class="hljs-attribute">dumpfile</span>=tablespace.dmp <span class="hljs-attribute">tablespaces</span>=example;<br></code></pre></td></tr></table></figure>
<p>4)导入数据库</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">impdb system/manager@orcl <span class="hljs-attribute">directory</span>=dump_dir <span class="hljs-attribute">dumpfile</span>=full.dmp <span class="hljs-attribute">full</span>=y;<br></code></pre></td></tr></table></figure>
<p>5)追加数据</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">impdp system/manager@orcl <span class="hljs-attribute">directory</span>=dump_dir <span class="hljs-attribute">dumpfile</span>=expdp.dmp <span class="hljs-attribute">schemas</span>=systemtable_exists_action<br></code></pre></td></tr></table></figure>
<pre><code>以上是日常工作中实际工作中用到的，希望能够给你得到帮助。</code></pre>
]]></content>
      <categories>
        <category>笔记</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Destroying singletons ... root of factory hierarchy 问题【已解决】</title>
    <url>//post/problem-spring-destroying-singletons.html</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Destroying singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@<span class="hljs-number">13d</span>740f: <br>defining beans [dataSource,sessionFactory,dccDAO,groupueDAO,groupbasDAO,olcsDAO,hibernateTemplate,dccService,<br>groupueService,groupbasService,olcsService]; root of factory hierarchy<br></code></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>我遇到该问题的原因在公司的Eclipse项目移到IDEA上面时候报的这个错,虽然Eclipse用着也还好,但是更习惯用IDEA,这里就不对编辑器做过的内容了.</p>
<p>然后我再Eclipse上面运行没有什么问题,但是放在IDEA上面跑就行,最早的时候就去google百度了一圈.结果寥寥草草,因为这种情况也不是很常见的问题,所以无果.草草了事.</p>
<p>今天有空,就又回去看了一下这个问题,大致排查过程如下.</p>
<p>注释掉了所有的其他spring-…xml文件,只加载了一个spring application context,然后运行起来之后终于能够看到错误了,就逐个在去加载spring-…xml,直到多加载一个就出现这个错误的时候开始了问题分析.</p>
<h4 id="分析过程略"><a href="#分析过程略" class="headerlink" title="分析过程略"></a>分析过程略</h4><h4 id="分析结果"><a href="#分析结果" class="headerlink" title="分析结果:"></a>分析结果:</h4><p>JVM内存的锅,设置了虚拟机参数,完美解决</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">-Xms2048M -Xmx2048M -XX:<span class="hljs-attribute">PermSize</span>=256M -XX:<span class="hljs-attribute">MaxPermSize</span>=512M<br></code></pre></td></tr></table></figure>
<p>其实最开始的时候想到了是虚拟机内存大小的问题,但是当时只设置了堆内存,并没有设置方法区的内存大小,知道我多加载一个配置文件就报错,才考虑到这个地方,而且已经打印出来了报错信息</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.OutOfMemoryError</span>: <span class="hljs-selector-tag">PermGen</span> <span class="hljs-selector-tag">space</span><br></code></pre></td></tr></table></figure>
<p>看见这个错误开心的不得了. 至此问题完美解决.</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins 自动化部署 spring boot 项目（多图）</title>
    <url>//post/course-jenkins-auto-deploy-springboot.html</url>
    <content><![CDATA[<p><strong>前置条件</strong></p>
<ul>
<li>jenkins与部署项目所用服务器为同一台</li>
</ul>
<h2 id="1、下载并运行-jenkins-war"><a href="#1、下载并运行-jenkins-war" class="headerlink" title="1、下载并运行  jenkins.war"></a>1、下载并运行  <a href="http://mirrors.jenkins.io/war-stable/latest/jenkins.war">jenkins.war</a></h2><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">将下载好的war包，放在tomcat的webapps目录下，启动tomcat 默认 <span class="hljs-number">8080</span> 端口<br><br>wget http:<span class="hljs-regexp">//mi</span>rrors.jenkins.io<span class="hljs-regexp">/war-stable/</span>latest/jenkins.war<br><br>启动之后访问jenkins项目进行账号设置进行下一步操作<br><br>安装jenkins所需插件，安装推荐的即可<br></code></pre></td></tr></table></figure>

<a id="more"></a>

<p><img src="/images/posts/course-jenkins-auto-deploy-springboot/20180514150207538.png" alt="启动jenkins"></p>
<h2 id="2、配置jenkins所需插件"><a href="#2、配置jenkins所需插件" class="headerlink" title="2、配置jenkins所需插件"></a>2、配置jenkins所需插件</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">执行这一步之前，我们在第一次启动jenkins的时候，已经安装过大部分插件，所以我们只需要检查是否安装了以下插件即可<br><br><span class="hljs-number">1.</span>Maven Integration 使我们可以开始一个maven项目作为任务<br><br><span class="hljs-number">2.</span>Git plugin 使我们可以读取存放在git仓库的项目<br></code></pre></td></tr></table></figure>

<p><img src="/images/posts/course-jenkins-auto-deploy-springboot/20180514151243623.png" alt="配置jenkins"></p>
<p><img src="/images/posts/course-jenkins-auto-deploy-springboot/20180514152100394.png" alt="配置jenkins"></p>
<h2 id="3、配置jenkins全局工具"><a href="#3、配置jenkins全局工具" class="headerlink" title="3、配置jenkins全局工具"></a>3、配置jenkins全局工具</h2><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">配置<span class="hljs-keyword">jenkins的全局工具主要是我们所使用到的 </span><span class="hljs-keyword">jdk、git、maven等</span><br></code></pre></td></tr></table></figure>

<p><img src="/images/posts/course-jenkins-auto-deploy-springboot/20180514152706764.png"><br><img src="/images/posts/course-jenkins-auto-deploy-springboot/20180514152841580.png"></p>
<p><strong>jdk在选取安装的时候，如果在我们的服务器上已经安装好的话，直接填写JAVA_HOME路径即可，否则jenkins自动安装的话，需要提供Oracle的账号以及密码。</strong></p>
<p><img src="/images/posts/course-jenkins-auto-deploy-springboot/20180514153051307.png"></p>
<p><strong>git和maven使用jenkins自动默认配置即可</strong><br><img src="/images/posts/course-jenkins-auto-deploy-springboot/20180514153209524.png"></p>
<h2 id="4、新建任务并配置任务相关设置"><a href="#4、新建任务并配置任务相关设置" class="headerlink" title="4、新建任务并配置任务相关设置"></a>4、新建任务并配置任务相关设置</h2><p><img src="/images/posts/course-jenkins-auto-deploy-springboot/20180514153550388.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">配置任务相关参数<br></code></pre></td></tr></table></figure>

<p>1.源码管理</p>
<p><img src="/images/posts/course-jenkins-auto-deploy-springboot/20180514154017440.png"></p>
<p>如果出现 ：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">Failed <span class="hljs-keyword">to</span> connect <span class="hljs-keyword">to</span> repository : Error performing <span class="hljs-keyword">command</span>: git <span class="hljs-keyword">ls</span>-remote -h http<span class="hljs-variable">s:</span>//gitee.<span class="hljs-keyword">com</span>/lvgo/<span class="hljs-keyword">sandbox</span>.git HEAD<br></code></pre></td></tr></table></figure>
<p>请检查服务器是否安装了git</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-builtin-name">get</span> install git<br></code></pre></td></tr></table></figure>

<p>2.jenkins执行内容和操作成功后执行shell</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">clean <span class="hljs-keyword">package</span> -Dmaven.test.skip=<span class="hljs-keyword">true</span><br><br># 将应用停止<br>echo <span class="hljs-string">&quot;Stopping SpringBoot Application&quot;</span><br>pid=`ps -ef | <span class="hljs-keyword">grep</span> dofun-api.jar | <span class="hljs-keyword">grep</span> -v <span class="hljs-keyword">grep</span> | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>`<br><span class="hljs-keyword">if</span> [ -n <span class="hljs-string">&quot;$pid&quot;</span> ]<br>then<br>   kill -<span class="hljs-number">9</span> $pid<br>fi<br>mv -f <span class="hljs-regexp">/root/</span>.jenkins<span class="hljs-regexp">/workspace/</span>dofunStreet<span class="hljs-regexp">/api/</span>target<span class="hljs-regexp">/dofun-api.jar /u</span>sr<span class="hljs-regexp">/local/</span>dofun/dofun-api.jar<br>chmod <span class="hljs-number">777</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/dofun/</span>dofun-api.jar<br>#bash <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/dofun/</span>start.sh<br>BUILD_ID=dontKillMe <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/dofun/</span>start.sh<br></code></pre></td></tr></table></figure>
<p>对应sh脚本内容</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">nohup java -jar <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/dofun/</span>dofun-api.jar &gt; <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/dofun/</span>dofun.log <span class="hljs-number">2</span>&gt;<span class="hljs-number">1</span>&amp;<br></code></pre></td></tr></table></figure>


<p><img src="/images/posts/course-jenkins-auto-deploy-springboot/20180514154515871.png"></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx 怎么通过域名访问8080端口(指定端口)</title>
    <url>//post/course-nginx-port-setting.html</url>
    <content><![CDATA[<p>进入到nginx目录下,打开nginx.conf</p>
<!--more-->

<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-section">server</span> &#123;<br>		    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>            <span class="hljs-attribute">server_name</span> example.com;<br> <br>            <span class="hljs-attribute">location</span> /test1 &#123;<br>                    <span class="hljs-attribute">proxy_pass</span> http://example.com:8080/test1;<br>            &#125;<br> <br>            <span class="hljs-attribute">location</span> /test2 &#123;<br>                    <span class="hljs-attribute">proxy_pass</span> http://example.com:8081/test2;<br>            &#125;<br> <br>            <span class="hljs-attribute">location</span> / &#123;<br>                    <span class="hljs-attribute">proxy_pass</span> http://example.com;<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>重新加载一下配置文件</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./nginx</span> -s <span class="hljs-keyword">reload</span><br></code></pre></td></tr></table></figure>
<p>最主要的地方就是配置好location的地址</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">当我们输入域名之后加上<span class="hljs-regexp">/test1的时候,就会被nginx映射到我们域名:8080/</span>test1路径上去做请求.<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>node.js 部署的 vue 项目怎么在局域网访问</title>
    <url>//post/node-LAN-deploy-vue.html</url>
    <content><![CDATA[<h4 id="1-查看本机局域网ip"><a href="#1-查看本机局域网ip" class="headerlink" title="1.查看本机局域网ip"></a>1.查看本机局域网ip</h4><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> windows系统<br>在cmd页面输入ipconfig命令即可查看<br><span class="hljs-regexp">//</span> linux系统<br>在终端输入ifconfig命令可查看<br></code></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="2-修改vue配置文件"><a href="#2-修改vue配置文件" class="headerlink" title="2.修改vue配置文件"></a>2.修改vue配置文件</h4><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 进入到项目的config文件夹下,打开index.js 把host改成以上你查看到的本地ip地址<br><br><span class="hljs-regexp">//</span> Various Dev Server settings<br>host: <span class="hljs-string">&#x27;192.168.31.239&#x27;</span>, <span class="hljs-regexp">//</span> can be overwritten by process.env.HOST<br>port: <span class="hljs-number">8082</span><br>....<br>.<br>.<br></code></pre></td></tr></table></figure>
<p><img src="/images/posts/node-LAN-deploy-vue/20180720212021564.png" alt="lvgo star dust"></p>
<h4 id="3-在其他设备输入ip加端口号即可"><a href="#3-在其他设备输入ip加端口号即可" class="headerlink" title="3.在其他设备输入ip加端口号即可"></a>3.在其他设备输入ip加端口号即可</h4><p>电脑手机均可</p>
<p><a href="http://192.168.31.239:8082/">http://192.168.31.239:8082</a> 即可访问到我们项目</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>octopus 为梦而生的八爪鱼</title>
    <url>//post/octopus.html</url>
    <content><![CDATA[<p><a href="https://github.com/lvgocc/octopus">八爪鱼 Octopus</a></p>
<a id="more"></a>

<p>一个基于 Jsoup 的 Java 爬虫系统</p>
<p>目前正处于开发阶段, 博客持续更新</p>
<p>感兴趣的点击上方链接, 围观起来</p>
<p>砰!砰!</p>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>try catch 中的异常怎么处理</title>
    <url>//post/try-catch-right-operation.html</url>
    <content><![CDATA[<h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>在我们日常开发中, 经常会遇到一些异常需要去手动处理, 或者说是一些可能出现的异常去处理, 又或者说你不知道的异常, 等着暴露出来发现后去处理, 无论哪种异常, 当它出现的时候都是头疼的. </p>
<h3 id="实况"><a href="#实况" class="headerlink" title="实况"></a>实况</h3><p>在我们开发过程中对一些可能出现异常的地方, 也就是非检查型异常, 需要我们自己凭经验去做异常处理, 当然你也可以大手一挥任其随意抛出.(佛系异常, 道系领导). 下面我们把镜头转向正在加班开发需求的几位选手, 看看他们是如何对待异常处理逻辑的;</p>
<a id="more"></a>

<hr>
<h4 id="round-one"><a href="#round-one" class="headerlink" title="round one"></a>round one</h4><p>这是来自一个对try catch第一次使用的 #$%^选手</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>	......<br>	<span class="hljs-comment">// 中间嵌套10个业务处理方法</span><br>	fun1();<br>	fun2();<br>	......<br>	.<br>	.<br>	.<br>&#125; <span class="hljs-keyword">catch</span> (Execption e) &#123;<br>	<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该选手使用的<strong>不动声色管你用户死活开发法</strong>(魔法伤害), 一招制胜, 此招会使问题分析陷入僵局数天, 客户因体验极差流失等异常状态, 此招杀伤力极强, 伤害值 : ∞;</p>
<h5 id="伤害分析"><a href="#伤害分析" class="headerlink" title="伤害分析"></a>伤害分析</h5><p>伤人于无形, 破坏力 ? 视具体功能而定;</p>
<p>当在try中出现异常后, catch无反应, 相当于你作为一个bug负责人, 知道有问题, 但你谁都不告诉.</p>
<p>此招式可使问题永远藏在 #$%^ 的代码中, 永远做一个”优秀的开发者”, 相信他会在自己的梦想道路上渐行渐远</p>
<hr>
<h4 id="round-two"><a href="#round-two" class="headerlink" title="round two"></a>round two</h4><p>这是来自一个对try catch第二次使用的 *&amp;^% 选手</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>	......<br>	<span class="hljs-comment">// 中间嵌套10个业务处理方法</span><br>	fun1();<br>	fun2();<br>	......<br>	.<br>	.<br>	.<br>&#125; <span class="hljs-keyword">catch</span> (Execption e) &#123;<br>	syso(<span class="hljs-string">&quot;出现异常&quot;</span>);<br>	sout(<span class="hljs-string">&quot;处理***业务出错了&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们看到, 同样这位选手使用了<strong>不动声色随风飘摇记录知道问题不知道问题在哪抓心挠肝难受开发法</strong>(魔法伤害), 伤害值 : ∞;</p>
<h5 id="伤害分析-1"><a href="#伤害分析-1" class="headerlink" title="伤害分析"></a>伤害分析</h5><p>这种伤害类似于什么呢? 相当于你看见你给物业说你办公室灯坏了. 物业心里阴影面积.<br>不修灯被投诉, 修不知道修哪一个.</p>
<p>这种写法可以知道有问题, 但不知道哪有问题.</p>
<hr>
<h4 id="round-three"><a href="#round-three" class="headerlink" title="round three"></a>round three</h4><p>这是来自一个对try catch第三次使用的 3号选手</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>	......<br>	<span class="hljs-comment">// 中间嵌套10个业务处理方法</span><br>	fun1();<br>	fun2();<br>	......<br>	.<br>	.<br>	.<br>&#125; <span class="hljs-keyword">catch</span> (Execption e) &#123;<br>	log.error(<span class="hljs-string">&quot;处理***业务出错了&quot;</span>, e.getMessage());<br>	<span class="hljs-comment">// 写你自己的异常处理逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们看到, 这位选手使用了<strong>化骨绵掌</strong>伤害值 : 能够知道错误信息, 具体位置仍需分析;</p>
<h5 id="伤害分析-2"><a href="#伤害分析-2" class="headerlink" title="伤害分析"></a>伤害分析</h5><p>这种操作对于我们自定义异常是有一定的帮助, 但单业务内出现异常位置多的时候, 这种方式就有一些不适用了.</p>
<p>业务中如果出现非检查型异常那么恭喜你, 你又可以加班了.</p>
<p>空指针, 数组越界, 类型转换, ….. 一个一个排查吧.</p>
<hr>
<h4 id="round-four-划重点-最常见-隐患最多的一种写法"><a href="#round-four-划重点-最常见-隐患最多的一种写法" class="headerlink" title="round four (划重点, 最常见, 隐患最多的一种写法)"></a>round four (划重点, 最常见, 隐患最多的一种写法)</h4><p>这是来自一个对try catch第三次使用的 4 号选手</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>	......<br>	<span class="hljs-comment">// 中间嵌套10个业务处理方法</span><br>	fun1();<br>	fun2();<br>	......<br>	.<br>	.<br>	.<br>&#125; <span class="hljs-keyword">catch</span> (Execption e) &#123;<br>	e.printStackTrace()<br>	<span class="hljs-comment">// 写你自己的异常处理逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="伤害分析-3"><a href="#伤害分析-3" class="headerlink" title="伤害分析"></a>伤害分析</h4><p>这个时候同学会问了, 兄弟, 这有什么伤害呢? 这还不行吗? 是因为我没写注释吗, </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&#125; <span class="hljs-keyword">catch</span> (Execption e) &#123;<br>	sout(<span class="hljs-string">&quot;出错了&quot;</span>, e.getMessage());<br>	e.printStackTrace();<br>	<span class="hljs-comment">// 写你自己的异常处理逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样吗? 其实这个堆栈打印的没毛病, 但是这个底层有问题. 不推荐这样使用, 这样使用的结果就是系统日志内容与堆栈日志会并行输出, 造成抢话</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">system.log : 今天是<br><span class="hljs-keyword">exception</span>.stack : 我有<br>system.log : 好<br><span class="hljs-keyword">exception</span>.stack : 问<br>system.log : 天气<br><span class="hljs-keyword">exception</span>.stack : 题了<br></code></pre></td></tr></table></figure>
<p>具体日志随便取一个, 大家随便感受一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">genException</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> nums[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>];<br>        System.out.println(<span class="hljs-string">&quot;Before exception is generated.&quot;</span>);<br>        nums[<span class="hljs-number">7</span>] = <span class="hljs-number">10</span>;<br>        System.out.println(<span class="hljs-string">&quot;this won&#x27;t be displayed&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            genException();<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException exc)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Standard message is:&quot;</span>);<br>            System.out.println(exc);<br>            System.out.println(<span class="hljs-string">&quot;\nStack trace:&quot;</span>);<br>            exc.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;After catch&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>输出日志</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">Before</span> <span class="hljs-selector-tag">exception</span> <span class="hljs-selector-tag">is</span> <span class="hljs-selector-tag">generated</span>.<br><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ArrayIndexOutOfBoundsException</span>: 7<br><span class="hljs-selector-tag">Standard</span> <span class="hljs-selector-tag">message</span> <span class="hljs-selector-tag">is</span>:<br><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ArrayIndexOutOfBoundsException</span>: 7<br><br><span class="hljs-selector-tag">Stack</span> <span class="hljs-selector-tag">trace</span>:<br><span class="hljs-selector-tag">After</span> <span class="hljs-selector-tag">catch</span><br>	<span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.erayt</span><span class="hljs-selector-class">.xpad</span><span class="hljs-selector-class">.ipdp</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.IpdpServiceImpl</span><span class="hljs-selector-class">.genException</span>(<span class="hljs-selector-tag">IpdpServiceImpl</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:47)</span><br>	<span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.erayt</span><span class="hljs-selector-class">.xpad</span><span class="hljs-selector-class">.ipdp</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.IpdpServiceImpl</span><span class="hljs-selector-class">.main</span>(<span class="hljs-selector-tag">IpdpServiceImpl</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:52)</span><br></code></pre></td></tr></table></figure>

<p>同时当堆栈深度较深时, 当该方法被多线程访问时. 会出现内存爆掉系统瘫痪.</p>
<p>关于堆栈打印直接调用的相关文章列几篇<br><a href="https://my.oschina.net/sxgkwei/blog/825700">https://my.oschina.net/sxgkwei/blog/825700</a><br><a href="https://zsk-china.iteye.com/blog/1133918">https://zsk-china.iteye.com/blog/1133918</a></p>
<hr>
<h4 id="标准写法-不接受反驳"><a href="#标准写法-不接受反驳" class="headerlink" title="标准写法. 不接受反驳"></a>标准写法. 不接受反驳</h4><p>这是来自一个对try catch第n次使用以上几种方法后的 X 选手</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>	......<br>	<span class="hljs-comment">// 中间嵌套10个业务处理方法</span><br>	fun1();<br>	fun2();<br>	......<br>	.<br>	.<br>	.<br>&#125; <span class="hljs-keyword">catch</span> (Execption e) &#123;<br>	log.error(<span class="hljs-string">&quot;处理***业务出错了&quot;</span>, e);<br>	<span class="hljs-comment">// 写你自己的异常处理逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="结尾再说两句"><a href="#结尾再说两句" class="headerlink" title="结尾再说两句"></a>结尾再说两句</h3><p>使用log框架中方法.进行日志输出. 保证异常使用的输出流与系统日志一致, 同时将异常信息内容输出到日志文件中, 不占用字符缓冲区大小</p>
<p>同时与大家共勉, 为我们热爱的代码做一点贡献, 发现自己的项目中有以上列举的缺陷代码能够及时完善.</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>编码技巧</category>
      </categories>
      <tags>
        <tag>编码技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>《1024，程序人生，这个属于我们的特殊日子》</title>
    <url>//post/example.html</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我第一次知道 1024 这个特殊的日子应该是在2年前（我总是一个后知后觉的家伙），而且还要感谢 <strong>CSDN</strong> 让我“提前”知道了特殊的日子<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那是在浏览博文的时候看到了 1024 的徽章。<br><img src="https://img-blog.csdnimg.cn/img_convert/36dc6a962df45e8c0b04c6065ce9d871.png#pic_center" alt="在这里插入图片描述"><center>这是现在的，可能当时不长这样毕竟 CSDN 这几年的 UI 变化还是挺多的</center></p>
<h1 id="如何与编程结缘"><a href="#如何与编程结缘" class="headerlink" title="如何与编程结缘"></a>如何与编程结缘</h1><blockquote>
<p>上学的时候我可不是个“好学生”，每天玩的忘了时间，现在想想可真后悔。</p>
</blockquote>
<h3 id="上课的时候第一次写代码"><a href="#上课的时候第一次写代码" class="headerlink" title="上课的时候第一次写代码"></a><center>上课的时候第一次写代码</center></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 记得那是第一次上机课，老师还是在黑板上写下了一段汇编代码，叫我们自己照着写然后运行观察有没有 <code>error</code> 字样出现，果不其然，我照着写报错了。但当时不以为然，和同学哈哈大笑“这啥玩应啊”。那是第一次写代码。</p>
<hr>

<h3 id="临毕业开始校招找工作"><a href="#临毕业开始校招找工作" class="headerlink" title="临毕业开始校招找工作"></a><center>临毕业开始校招找工作</center></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 时光总是短暂的，很快大学快毕业了，自己开始为大学这几年欠下的“<strong>债</strong>”开始担心，没有优秀的成绩，老师传授的硬件编程也没有学到手，可以说只是一个<code>到了考试自习室通宵</code>过完了“<code>枯燥</code>”的三年。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 记得那是大四下学期，九月份的校招，室友们都去参加校招，而我还在寝室打游戏。是的，还在打游戏，指挥着那个打了 4 年的副本—— 血战天策。我现在回想起来都不知道自己当时到底要干什么，家里也没矿啊？也没看到我爸和谁谈过石油的生意啊。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  室友回来了，“今天咋样？”，“没玄晶，你呢？”，“不怎么样，你明天也去看看吧，工作不太好找啊。”这是我大学四年最要好的一个玩伴，然而他背着我可是学了不少东西！我跟他玩游戏，我真玩，他是假玩啊，我清晰的记得跟他 lol 在读条进游戏的时候他可是在看书！！渣男！“嗯，明天去看看”。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  “上啊”， “人太多了，等等吧”，“那我先去了”。大概10分钟他出来之后问他如何，“英语自我介绍，感觉没戏”，“走吧”，“你不试试啊”。“我这英语咋试啊”，“试试呗，万一呢”。我硬着头皮进去了，结果中午吃饭他们要休息了，老天不让我去啊。突然被叫住，“过来吧，我等会去吃。”，可能是因为吃饭比较急，大概聊了10多分钟？我不记得时间了，结果是通过了，<code>‘测试工程师’</code>明天到xxx签三方协议。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  我做梦也没想到我能这么顺利找到工作，想着我都能过，那室友肯定不能差，结果他没有通过，我当时就不想去了。我说不能跟你在一起，没意思，不去。他劝我先别急，跟家里商量商量，然后再看看其他机会。</p>
<hr>

<h3 id="阴差阳错的培训"><a href="#阴差阳错的培训" class="headerlink" title="阴差阳错的培训"></a><center>阴差阳错的培训</center></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  我赶紧把这个做测试“<code>工程师</code>”“<code>喜讯</code>”告诉了家里，本以为会高兴，结果因为地方太远，家里都不同意。我这个人倔强的很，跟爸妈拧了很久，没定妥，后来有一天我爸给我打电话说他找到一个地方，让我去看看，从此，那里成了我程序人生的起点—— 达内，对于达内我不想评价太多。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  当我打开 eclipse 写下代码，看到控制台输出 Hello World 的时候，我便从此爱上了编程。因为签了三方协议，然后现在在培训，没办法实习，毁约给他们转了2000块钱，取消了原本的实习计划。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  四个月在那里当了四个月的技术班长，周末自习给大家讲过数不清次数的课，帮同学解决了多少问题也记不清，班级活动做了一个抽奖的程序，总之，那里的每一天都让我对编程的喜爱越来越深。</p>
<h1 id="程序人生"><a href="#程序人生" class="headerlink" title="程序人生"></a>程序人生</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  当我第一次坐在办公室开发第一个需求的时候，我没有担心哪个需求可不可以实现，从一开始我最担心的事情是<strong>我开发的功能会不会有人使用</strong>。我不知道有多少伙伴会有和我一样的想法，对待自己成程序，从开始设计它到实现它，我都在为它“将来”考虑。事实证明是没有，我写的功能很多情况下是无人使用。所以从那个时候我就励志！我做的功能一定要有人用！。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  在老家做了1年多，当个小组长，领了3个人一起开发，但我开始不安，因为我听到了很多我没听过东西，而我所接触到的却没人提及，强烈的危机感每天都在提醒着我自己。最终还是选择了背井离乡，我将地图折了一下，将老家的点对应的地方定为了目的地，是的，我现在跨了半个中国在异乡。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  到了外面的难，异乡人懂异乡人。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  没想到来到大都市之后，我便经历了公司倒闭、老板跑路，我欠了一屁股债第一年回家借钱回去的。我恨自己，恨自己没有好好学习，没有好的技术能力跑出来，但从没想过放弃。因为我所热爱的程序人生它一定就在这里。在出来的第一份工作，在那个倒闭的公司中，度过了我职业生涯的第二年的后半年，没错，我荒废了这半年的经历，因为每天都在想着下顿饭怎么省钱，感谢强哥和马爸爸那段时间的大力支持，不然真不知道自己会不会被网贷逼死。每天喝着“鸡汤”过日子，留着泪吃饭的日子经历的人才会懂。那段时间凭着一丝丝希望，坚持接触了 netty、springboot、springcloud、dubbo、redis、mysql、ibatis、mybatis。是的，只是接触。我想很多人都应该知道空虚的学习有多难。我学的再多无处施展，我用不到。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  老板跑路之后，开始寻找我的第三份工作，我每次都相信好运会降临，可每次都是倒霉到家。以为自己找到了归宿，可没干半年，警察陪着我上班，那一年的关键词，P2P 暴雷、我老板、300 亿、又跑路。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  我再一次被迫离职。当时被没有太多的难过心情了，因为当你经历过绝望过后，这点痛算什么呢？</p>
<h1 id="为何坚持"><a href="#为何坚持" class="headerlink" title="为何坚持"></a>为何坚持</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  在我出来的那一年，也就是17年，我虽经历了难堪的一年多，但那个时候我想到的是自己出发时的立志“<strong>死都要死外面</strong>”，同时也是最凄惨的那一年</p>
<ul>
<li>认识了<code>傅政委</code>，当时傅哥叫我去大厂试试，害，那时能活下来就是我最开心的事了，但我很高兴认识他。</li>
<li>接触到了<code>CSDN</code>，那一年开始试着写博客，我也不知道这是什么东西，我也不会写，完全当笔记来用。</li>
<li>注册了<code>码云</code>，不然我一直都不知道还有“码云”，也就只知道“马云”。</li>
<li>知道了<code>马云</code>、知道了<code>阿里巴巴</code>。我可能是唯数不多做了<code>一年多将近两年</code>程序员才知道阿里的人吧。这也是为什么我是在两年前才知道<code>1024</code>的。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  我一直相信上学老师说的一句话，“只要你肯学，永远都不晚”。我把这句话当成真理。同时又送给自己“不要抱怨、坚持下去。”我写过幸存者偏差的文章，我没幸存下来，我说的所有的言论屁都不如，这就是我为什么坚持的原因。我要坚持下去，要证明自己。我不想输。当你幸存下来，放个屁都是香的。</p>
<h1 id="如何坚持"><a href="#如何坚持" class="headerlink" title="如何坚持"></a>如何坚持</h1><blockquote>
<p>追求我所向往的程序人生，为开源做贡献，为社区做贡献。</p>
</blockquote>
<p><strong>不要给我说 5 点起床，1 点钟睡觉，我试过，天天累得跟狗一样，学习效率低，工作效率差，等死？我想做一个正常人，一个稍微有点理想，有点动作的正常人，偶尔拼一拼命而已。</strong></p>
<hr>
<h4 id="1-拿别人来刺激自己"><a href="#1-拿别人来刺激自己" class="headerlink" title="1. 拿别人来刺激自己"></a>1. 拿别人来刺激自己</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  拿别人来刺激自己。每次我看到优秀的大佬在学习的时候就是我最有劲的时候，我想着的是，当他松懈的时候，我便能超过他！这一招屡试不爽，找个你喜欢的人，关注他！</p>
<hr>
<h4 id="2-尝试动手做一点东西"><a href="#2-尝试动手做一点东西" class="headerlink" title="2. 尝试动手做一点东西"></a>2. 尝试动手做一点东西</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  看看自己口口声声说着热爱的编程，你用它做过什么？它为你带来了什么？emm… 我现在做了一堆稀里糊涂的东西，爬虫、并发任务执行工具、浏览器插件、博客模版？总之乱七八糟，但一直在尝试动手</p>
<hr>
<h4 id="3-专注，成为“T”型人才"><a href="#3-专注，成为“T”型人才" class="headerlink" title="3. 专注，成为“T”型人才"></a>3. 专注，成为“T”型人才</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  我以前一直都在东看看，西望望，这也学那也学，结果都知道个皮毛，深一点啥都不会。现在专注 Java 技术，并发网络编程方面，偶尔研究研究大数据，感觉方向也清楚了，学的是什么也明白了，最主要的，迷茫的时候少了。坚持努力让自己成为“幸存的人”。然后狠狠的“装一次逼！”。</p>
<hr>
<h4 id="4-为了一次完美的装逼。（意会）"><a href="#4-为了一次完美的装逼。（意会）" class="headerlink" title="4. 为了一次完美的装逼。（意会）"></a>4. 为了一次完美的装逼。（意会）</h4><hr>
<h1 id="1024"><a href="#1024" class="headerlink" title="1024"></a><center>1024</h1><div align='center'>
<p>1024，程序人生，这个属于我们的特殊日子。感触良多。</p>
<p>我因热爱而在这里。因热爱而坚持。</p>
<p>仍在路上坚持，希望同你一样，一起坚持！为了梦想、学习技术，不要抱怨，坚持下去。</p>
</div>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title>《Spring的设计理念和整体架构》</title>
    <url>//post/spring-structure-concept.html</url>
    <content><![CDATA[<h3 id="Spring的设计理念"><a href="#Spring的设计理念" class="headerlink" title="Spring的设计理念"></a>Spring的设计理念</h3><p><code>以下为官方文档内容</code></p>
<blockquote>
<p>When you learn about a framework, it’s important to know not only what it does but what principles it follows. Here are the guiding principles of the Spring Framework:<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/overview.html#overview-philosophy">传送门</a></p>
</blockquote>
<ul>
<li><p>Provide choice at every level. Spring lets you defer design decisions as late as possible. For example, you can switch persistence providers through configuration without changing your code. The same is true for many other infrastructure concerns and integration with third-party APIs.</p>
<p>  提供各个层面的选择。Spring允许您尽可能晚地推迟设计决策。例如，您可以通过配置切换持久性提供程序，而无需更改代码。许多其他基础架构问题以及与第三方API的集成也是如此。</p>
</li>
<li><p>Accommodate diverse perspectives. Spring embraces flexibility and is not opinionated about how things should be done. It supports a wide range of application needs with different perspectives.</p>
<p>  适应不同的观点。Spring拥抱灵活性，并不认为应该如何做。它以不同的视角支持广泛的应用需求。</p>
</li>
<li><p>Maintain strong backward compatibility. Spring’s evolution has been carefully managed to force few breaking changes between versions. Spring supports a carefully chosen range of JDK versions and third-party libraries to facilitate maintenance of applications and libraries that depend on Spring.</p>
<p>  保持强大的向后兼容性。Spring的演变经过精心设计，可以在版本之间进行一些重大改变。Spring支持精心挑选的JDK版本和第三方库，以便于维护依赖于Spring的应用程序和库。</p>
</li>
<li><p>Care about API design. The Spring team puts a lot of thought and time into making APIs that are intuitive and that hold up across many versions and many years.</p>
</li>
</ul>
<pre><code>为代码质量设定高标准。Spring Framework强调有意义，最新且准确的Javadoc。它是极少数项目之一，可以声称干净的代码结构，包之间没有循环依赖。</code></pre>
<ul>
<li><p>Set high standards for code quality. The Spring Framework puts a strong emphasis on meaningful, current, and accurate Javadoc. It is one of very few projects that can claim clean code structure with no circular dependencies between packages.</p>
<p>  关心API设计。Spring团队投入了大量的思考和时间来制作直观的API，并且可以支持多个版本和多年。</p>
</li>
</ul>
<hr>
<pre><code>官方给出的解释更像是说明了Spring的开发方向定义，而我们在真正的使用过程中远远不止这些。Spring为我们真正带来的价值，
更像是一个引路人，带我们更轻松的“上道”。</code></pre>
<h4 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h4><ol>
<li>Spring为开发者提供了一站式的轻量级开发平台。它抽象出了我们在许多应用中常常遇到的共性问题，并且Spring在Java EE的应用开发中，支持POJO和使用JavaBean的开发方式，使应用面向接口开发。充分支持OO的设计方法。<br>:<br>POJO其实是比javabean更纯净的简单类或接口。<br>POJO严格地遵守简单对象的概念，而一些JavaBean中往往会封装一些简单逻辑。<br>POJO主要用于数据的临时传递，它只能装载数据， 作为数据存储的载体，而不具有业务逻辑处理的能力。<br>Javabean虽然数据的获取与POJO一样，但是javabean当中可以有其它的方法</li>
</ol>
<ol start="2">
<li>简化开发，Spring中的核心IoC和AOP有效的帮我们大幅简化开发成本，对象间的依赖耦合关系，使用Spring的IoC便可以轻松的实现。AOP则把我们开发过程中可能出现的大量重复代码在AOP内完成，比如应用日志，安全控制等。</li>
<li>应用集成，Spring的设计使其与生俱来的能够与其他第三方框架无缝结合，使我们的开发更加灵活，比如与Struts框架，hibernate框架，redis框架，mybatis框架等。</li>
</ol>
<hr>
<h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><blockquote>
<p>Spring框架一共模块有20+，大体可分为五大类</p>
</blockquote>
<p><img src="/images/posts/spring-structure-concept/20180505214030958.png" alt="lvgo star dust"></p>
<h4 id="一、核心模块"><a href="#一、核心模块" class="headerlink" title="一、核心模块"></a>一、核心模块</h4><ul>
<li><p>Core（Spring的核心实用程序，为Spring其他模块奠定了基础）</p>
</li>
<li><p>Beans（Spring的核心bean，以及bean工厂的支持）</p>
</li>
<li><p>Contexts（该模块构建在core和beans之上，集成了beans的特性，为Spring核心提供了大量扩展）</p>
</li>
<li><p>Expression（提供了一个强大的表达式语言用于在运行时查询和操纵对象。它是 JSP 2.1 规范中定义的 unifed express language 的一个扩展）</p>
</li>
</ul>
<h4 id="二、AOP模块"><a href="#二、AOP模块" class="headerlink" title="二、AOP模块"></a>二、AOP模块</h4><ul>
<li><p>Aspects（ AspectJ 的集成支持，提供了AOP 实现方法）</p>
</li>
<li><p>Instrumentation（提供了 class instrumentation 支持和 classloader 实现，使得可以在特定应用服务器上使用）</p>
</li>
<li><p>Messaging（ Spring4之后增加，为集成一些基础的报文传送应用）</p>
</li>
</ul>
<h4 id="三、数据访问-集成模块"><a href="#三、数据访问-集成模块" class="headerlink" title="三、数据访问/集成模块"></a>三、数据访问/集成模块</h4><ul>
<li>JDBC （提供了一个 JDBC 抽象层，它可以消除冗长的 JDBC 编码和解析数据库厂商特有的错误代码。此模块包含了 Spring 对 JDBC 数据访问进行封装的所有类。）</li>
<li>ORM （为流行的对象－关系映射 API ，例如 JPA、JDO、 Hibernate、 iBatis等，提供了一个交互层。利用 ORM 封装包，可以混合使用 Spring 提供的特性进行 O/R映射(Object/Relation)。）</li>
<li>OXM （提供了一个对 Object/XML映射实现的抽象层，Object/XML 映射实现包括 JAXB、Castor 、XMLBeans 、JiBX 和 XStream。）</li>
<li>JMS (Java Messaging Service) 模块主要包含了一些制造和消费消息的特性。</li>
<li>(tx)Transaction 模块支持编程和生命性的事务管理，这些事物必须实现特定的接口，并且对所有的 POJO 都适用。</li>
</ul>
<h4 id="四、Web模块"><a href="#四、Web模块" class="headerlink" title="四、Web模块"></a>四、Web模块</h4><ul>
<li><p>web</p>
</li>
<li><p>webflux（Spring5新增，非堵塞函数式 Reactive Web 框架，可以用来建立异步的，非阻塞，事件驱动的服务）</p>
</li>
<li><p>webmvc</p>
</li>
<li><p>websocket</p>
</li>
</ul>
<h4 id="五、Test模块"><a href="#五、Test模块" class="headerlink" title="五、Test模块"></a>五、Test模块</h4><hr>
<p>参考资料</p>
<ol>
<li><a href="http://spring.io/">Spring</a></li>
<li><a href="https://book.douban.com/subject/10470970/">Spring技术内幕（第二版）</a></li>
<li><a href="https://www.cnblogs.com/EnzoDin/p/6556825.html">Spring整体架构</a></li>
<li><a href="https://blog.csdn.net/lj1314ailj/article/details/80118372">Spring5 系统架构</a></li>
<li><a href="https://blog.csdn.net/panweiwei1994/article/details/76529086">Spring源码-整体架构</a></li>
</ol>
]]></content>
      <categories>
        <category>informal</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>《多线程并发任务处理组件》——无声</title>
    <url>//post/silent.html</url>
    <content><![CDATA[<h2 id="Silent-Task-Handler-Kit"><a href="#Silent-Task-Handler-Kit" class="headerlink" title="Silent Task Handler Kit"></a>Silent Task Handler Kit</h2><p><strong>源码</strong><br><a href="https://github.com/lvgocc/silent">github地址</a><br><a href="https://gitee.com/lvgo/silent">码云地址</a></p>
<h2 id="What’s-Silent-Task-Handler-Kit"><a href="#What’s-Silent-Task-Handler-Kit" class="headerlink" title="What’s Silent Task Handler Kit"></a>What’s Silent Task Handler Kit</h2><p>静默任务处理器组件可以赋予你的应用一键式多线程处理任务的能力, 它基于jdk1.8中concurrent包内容进行封装简化, 无任何第三方代码,<br>它提供了更简单的多线程任务处理方法,  其中你可以通过插拔式配置来满足你的需求<br>目前提供了以下配置</p>
<ol>
<li>启动线程大小</li>
<li>自定义线程池</li>
<li>同异步处理机制</li>
<li>任务结束异步处理机制</li>
</ol>
<a id="more"></a>

<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>当你有一组任务数据需要处理, 只需像这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 待处理任务数据, 比如是一组待更新的每天凌晨需要处理的数据</span><br>List&lt;String&gt; testData = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-comment">// 多线程操作</span><br><span class="hljs-keyword">new</span> TaskHandler&lt;String&gt;(testData) &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-comment">//TODO 你的业务代码 根据每个数据的内容进行后续的业务操作</span><br>    &#125;<br>&#125;.execute();<br></code></pre></td></tr></table></figure>

<p>它就可以帮你完成多线程任务处理. 并且它还支持同异步处理机制, 例如这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 待处理任务数据, 比如是一组待更新的每天凌晨需要处理的数据</span><br>List&lt;String&gt; testData = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-comment">// 多线程操作</span><br><span class="hljs-keyword">new</span> TaskHandler&lt;String&gt;(testData) &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-comment">//TODO 你的业务代码 根据每个数据的内容进行后续的业务操作</span><br>    &#125;<br><span class="hljs-comment">// 设置 sync 同异步处理, 默认为异步</span><br>&#125;.sync(<span class="hljs-keyword">true</span>).execute();<br><br><span class="hljs-comment">// 方法 fun1() 需要等待所有任务处理结束后才能执行</span><br>fun1();<br><br></code></pre></td></tr></table></figure>

<p>又或者说你的 fun1() 后面还有其他事情, 比如 fun2(), 但你想让任务处理结束后执行fun1(), 但fun2()不想同fun1()一起去等待任务结束, 此时你可以这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 待处理任务数据, 比如是一组待更新的每天凌晨需要处理的数据</span><br>List&lt;String&gt; testData = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-comment">// 多线程操作</span><br><span class="hljs-keyword">new</span> TaskHandler&lt;String&gt;(testData) &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-comment">//TODO 你的业务代码 根据每个数据的内容进行后续的业务操作</span><br>    &#125;<br><span class="hljs-comment">// athend来实现异步执行结束后执行指定方法</span><br>&#125;.athend(() -&gt; &#123;<br>            fund1();<br>         &#125;.execute();<br><br><span class="hljs-comment">// 方法 fun2() 不需要等待所有任务处理结束后执行, 将与任务并行</span><br>fun2();<br><br></code></pre></td></tr></table></figure>

<p>希望看到这里的你能支持我. 给个star</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>《多线程并发任务处理组件》序章——生活不能就这样悲泣</title>
    <url>//post/silent-first.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote>
<p>入行也有些日子，</p>
</blockquote>
<p>最近突然心中迸发出一个想法, 想要去解决多线程并发环境的一些问题. 并不是说现在社区找不到优秀的这方面的开源项目, 更多的是想自己动手做一些东西出来, 毕竟性格一直在驱使着我要去做这一切. 也是想要证明一下自己, 今天能在这里立下这个flag我觉得对我自己也是极好的。更巧的是，今天是我的生日(农历).因为两年前做一个重大决定的时候，也是我的生日。 today is my birthday</p>
<p>事情的起因或者说是导火索, 会在另外一篇文章&lt;因为一个线程池引发的”血案”&gt;讲一下.</p>
<p>所以有这篇文章两个原因，一是自己开始准备着手做这件事情立flag，二就是想听听有缘在看这篇文章的你，在多线程并发场景下最希望解决哪些痛点问题。我认为这会对我接下来的事情有很大帮助</p>
<p>我先说说我的想法，我首先希望这是一个傻瓜式的多线程并发场景下的组件。<br>只需关心具体业务实现。然后是一个容错率低，拥有公平策略，支持同步异步机制，而且要支持扩展。<br>总结下来就是</p>
<ol>
<li>操作简单</li>
<li>同步异步机制处理</li>
<li>公平策略</li>
<li>高可用</li>
<li>可扩展</li>
</ol>
<p>希望有缘的你也能为我的第一个flag加油鼓劲。当然我会竭尽全力来完成这件事情。无论结果怎样。最后都会有个交代。</p>
<hr>
<p>最后送大家一首马荣成先生的诗《风云》</p>
<blockquote>
<p>《风云》马荣成<br>　<br>金麟岂是池中物， 一遇风云便化龙。<br>九霄龙吟惊天变， 风云际会浅水游。<br>成也风云，败也风云。<br>毋用强求，一切随缘。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>了解一下，什么是数据结构</title>
    <url>//post/data-structure-concept.html</url>
    <content><![CDATA[<h1 id="数据结构-（计算机存储、组织数据方式）"><a href="#数据结构-（计算机存储、组织数据方式）" class="headerlink" title="数据结构 （计算机存储、组织数据方式）"></a>数据结构 （计算机存储、组织数据方式）</h1><p><a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450?fr=aladdin">来自百度百科</a></p>
<blockquote>
<p>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常<br>情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。</p>
</blockquote>
<hr>
<h1 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h1><ul>
<li>逻辑结构</li>
<li>物理结构</li>
</ul>
<hr>
<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><ol>
<li>集合结构：集合结构的集合中任何两个数据元素之间都没有逻辑关系，组织形式松散。</li>
<li>线性结构：数据结构中线性结构指的是数据元素之间存在着“一对一”的线性关系的数据结构。</li>
<li>树状结构：树状结构是一个或多个节点的有限集合</li>
<li>网络结构：网络结构是指通信系统的整体设计，它为网络硬件、软件、协议、存取控制和拓扑提供标准。它广泛采用的是国际标准化组织（ISO）在1979年提出的开放系统互连（OSI-Open System Interconnection)的参考模型。</li>
</ol>
<hr>
<h2 id="物理结构-存储结构"><a href="#物理结构-存储结构" class="headerlink" title="物理结构(存储结构)"></a>物理结构(存储结构)</h2><p>顺序存储和链接存储</p>
<blockquote>
<p>在顺序存储中，每个存储空间含有所存元素本身的信息，元素之间的逻辑关系是通过数组下标位置简单计算出来的线性表的顺序存储，若一个元素存储在对应数组中的下标位置为i，则它的前驱元素在对应数组中的下标位置为i-1，它的后继元素在对应数组中的下标位置为i+1。在链式存储结构中，存储结点不仅含有所存元素本身的信息，而且含有元素之间逻辑关系的信息。数据的链式存储结构可用链接表来表示。</p>
</blockquote>
<hr>
<h1 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a><div id='top_type'>常用数据结构</div></h1><ul>
<li><a href="#array">数组</a></li>
<li><a href="#stacks">栈</a></li>
<li><a href="#queue">队列</a></li>
<li><a href="#linked_list">链表</a></li>
<li><a href="#tree">树</a></li>
<li><a href="#map">图</a></li>
<li><a href="#heap">堆</a></li>
<li><a href="#hash">散列表</a></li>
</ul>
<hr>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><div id='array'>数组</div></h2><p><a href="#top_type">返回分类</a></p>
<blockquote>
<p>在我们程序设计中,为了处理方便,会把一些具有相同类型的元素有序的放在一起.这些有序排列的数据元素的集合称为<code>数组</code></p>
</blockquote>
<div id='return_tip_1'></div>

<hr>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a><div id='stacks'>栈</div></h2><p><a href="#top_type">返回分类</a></p>
<blockquote>
<p>栈是只能在一端插入或删除的特殊<a href="#linear_list">线性表</a>,先入栈的数据在栈底,后入的数据在栈顶.需要读取数据的时候,最先获取到的是栈顶的数据.也就是先进后出,后进先出</p>
</blockquote>
<hr>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a><div id='queue'>队列</div></h2><p><a href="#top_type">返回分类</a></p>
<blockquote>
<p>一种特殊的线性表,它只允许在表的前端进行删除,后端进行插入操作,队列是先进先出,后进后出原则.</p>
</blockquote>
<hr>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a><div id='linked_list'>链表</div></h2><p><a href="#top_type">返回分类</a></p>
<blockquote>
<p>链表是一种物理存储单元上非连续的,非顺序的存储结构,它既可表示线性的,也可以表示非线性的,<font color='red'>在这里(逻辑结构中)</font>链表是通过其中的指针来链接次序的,它是由一系列结点(链表中的每一个元素称为结点)组成的,结点可以在运行时生成,当中包含两个重要数据,一个是存储结点内容的数据域,另一个是存储下一个结点地址的指针域.</p>
</blockquote>
<hr>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a><div id='tree'>树</div></h2><p><a href="#top_type">返回分类</a></p>
<blockquote>
<p>包含n(n&gt;0)个结点的有穷集合k,且在k中定义了一个关系N,N满足以下条件:</p>
<ol>
<li>有且只有一个k0结点,k0结点称为树的根(root)结点.</li>
<li>除k0外,k中的每个结点有且只有一个前驱结点.</li>
<li>k中各结点,对关系N来说,可以有m个后续(m&gt;=0)</li>
</ol>
</blockquote>
<div id='return_tip_2'></div>
---

<h2 id="图"><a href="#图" class="headerlink" title="图"></a><div id='map'>图</div></h2><p><a href="#top_type">返回分类</a></p>
<blockquote>
<p>图是由有穷集合V和边集合E组成的.为和树做区别,图中的结点称为顶点,边是顶点的<a href="#ordered_pair">有序偶</a>对,若两个顶点中间存在一条边则表示这两个顶点为相邻关系</p>
</blockquote>
<hr>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a><div id='heap'>堆</div></h2><p><a href="#top_type">返回分类</a></p>
<blockquote>
<p>在计算机科学中，堆是一种特殊的树形数据结构，每个结点都有一个值。通常我们所说的堆的数据结构，是指二叉堆。堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。</p>
</blockquote>
<hr>
<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a><div id='hash'>散列表</div></h2><p><a href="#top_type">返回分类</a></p>
<blockquote>
<p>若结构中存在关键字和K相等的记录，则必定在f(K)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数(Hash function)，按这个思想建立的表为散列表。</p>
</blockquote>
<hr>
<h1 id="涉及名词说明"><a href="#涉及名词说明" class="headerlink" title="涉及名词说明:"></a>涉及名词说明:</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a><div id='linear_list'>线性表</div></h2><blockquote>
<p>线性表（linear list）是数据结构的一种，一个线性表是n个具有相同特性的数据元素的有限序列。数据元素是一个抽象的符号，其具体含义在不同的情况下一般不同。</p>
</blockquote>
<p>我们说“线性”和“非线性”，只在逻辑层次上讨论，而不考虑存储层次，所以双向链表和循环链表依旧是线性表。<br>在数据结构逻辑层次上细分，线性表可分为一般线性表和受限线性表。一般线性表也就是我们通常所说的“线性表”，可以自由的删除或添加结点。受限线性表主要包括栈和队列，受限表示对结点的操作受限制。</p>
<p>优点:</p>
<ul>
<li>线性表的逻辑结构简单，便于实现和操作。因此，线性表这种数据结构在实际应用中是广泛采用的一种数据结构。<br><a href="#return_tip_1">返回继续阅读</a></li>
</ul>
<hr>
<h2 id="有序偶"><a href="#有序偶" class="headerlink" title="有序偶"></a><div id='ordered_pair'>有序偶</div></h2><blockquote>
<p>在数学中，有序偶是两个对象的搜集，使得可以区分出其中一个是“第一个元素”而另一个是“第二个元素”（第一个元素和第二个元素也叫做左投影和右投影）。带有第一个元素a和第二个元素b的有序偶通常写为(a,b)。<br> <a href="#return_tip_2">返回继续阅读</a></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 Java volatile 的随笔记</title>
    <url>//post/informal-volatile.html</url>
    <content><![CDATA[<p>问题的开始, 今天偶然见到一位群友的问题</p>
<p><code> synchronized</code> 是怎么保证可见性的?</p>
<a id="more"></a>

<p>先说一下这个问题的答案, </p>
<p><code>java 在锁释放的时候,通过jmm将缓存中的值, 刷新到内存当中, 以此来保证了数据的可见性</code></p>
<p>其实这个问题, 我们在群里延伸了很多内容, 从JMM到MESI, 从 Java 代码到汇编指令. 因为讨论的内容较多较深, 固有这篇随笔记, 这一切要感谢提出 <code>synchronized</code>是怎么保证可见性的这位同学;</p>
<p>今天讨论的内容主要就是围绕 volatile 展开的, 主要的是讨论了一下 volatile 的实现, 对于 volatile 的实现, 这里有一个很好的文章来理解 @何登成 的《C/C++ volatile 关键字剖析》</p>
<p>在 C/C++ 中，volatile具有易变性，是因为当读取 volatile 关键字修饰的变量的时候，不会读取寄存器的值，而是通过缓存重新加载到寄存器，然后再去读取这个值。同时volatile关键字还具有不可优化的特性，主要体现在不可用常量替换。必须要取缓存中读取寄存器在使用。接下来的就是 volatile 关键字的顺序性问题，在 C/C++中, 普通操作与volatile操作可能出现乱序的情况. 而 volatile操作与volatile操作在不同的处理器情况下, 仍然可能出现乱序的情况. 这是因为 cpu 要对指令优化可能进行排序, 在 x86 上, 读指令就有可能提前到写指令之前. storeload 乱序. </p>
<p>volatile 的顺序性问题, 在 C/C++中对于不同的处理器, 仍然会出现乱序的情况, volatile 决定不了. (解决的办法就是实现顺序一致规则 happends-before 语义)</p>
<hr>
<p>Java 中, volatile 关键字继承了 C/C++中的可见性之外, 又进行了一个操作, 使得 volatile 关键字拥有了顺序性. 那就是内存屏障. 最关键的就是 StoreLoad 屏障, 解决了在X86处理器上的写读重排序的问题</p>
<blockquote>
<p>X86处理器仅会对写-读操作做重排序。X86不会对读-读、读-写和写-写操作做重排序</p>
</blockquote>
<p>在 Java 层面, 虚拟机通过插入内存屏障来实现 volatile, 这部内容可以在虚拟机源码中 OrderAccess 类中找到, 一共是4个方法, 分别对应到4个内存屏障中.</p>
<p>而在CPU层面, 具体的执行则是使用了 Lock 前缀指令关于 Lock 前缀的指令作用</p>
<p>关于  Lock 前缀, 这里简单总结一下. 在执行前增加 Lock 前缀</p>
<ol>
<li>保证了对内存操作的原子性 (通过锁内存总线来实现, 这样会使所有处理器无法访问内存数据. 所以还有另外一种情况, 即所需要操作的数据在带有 Lock 前缀指令执行之前就已经被持有该缓存行的处理器锁定, 则不会通过锁总线来完成这步指令, 因为此时的数据无法被其他处理器读取, 该操作成为缓存锁定 . 但当处理器竞争程度较高, 或指令内存地址未对齐时, 仍会锁住总线)</li>
<li>禁止重排序</li>
<li>写入缓存的值刷新到主内存中</li>
</ol>
]]></content>
      <categories>
        <category>informal</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Spring事务管理 之 默认事务间调用问题</title>
    <url>//post/spring-transaction-invocation.html</url>
    <content><![CDATA[<p>由事务的传播行为我们知道, 如果将方法配置为默认事务(<b>REQUIRED</b>)在执行过程中Spring会为其新启事务(<b>REQUIRES_NEW</b>), 作为一个独立事务来执行. 由此存在一个问题.</p>
<p>如果使用不慎, 会引发  <code>org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only</code></p>
<a id="more"></a>

<hr>
<p>具体原因见以下demo简例:</p>
<h4 id="部分关键代码"><a href="#部分关键代码" class="headerlink" title="部分关键代码"></a>部分关键代码</h4><h5 id="DemoService1"><a href="#DemoService1" class="headerlink" title="DemoService1"></a>DemoService1</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoService1Impl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DemoService1</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="hljs-keyword">this</span>.getClass());<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> DemoDao demoDao;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> DemoService2 demoService2;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 业务逻辑 , 默认事务, 事务回滚异常 : Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED,rollbackFor = Exception.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doService</span><span class="hljs-params">()</span> </span>&#123;<br>        HashMap&lt;String, Integer&gt; param = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">2</span>);<br>        param.put(<span class="hljs-string">&quot;applId&quot;</span>, <span class="hljs-number">19</span>);<br>        param.put(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-number">19</span>);<br>        demoDao.insert1(param);<br>        <span class="hljs-keyword">try</span> &#123;<br>            demoService2.doService();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            logger.error(<span class="hljs-string">&quot;业务2处理异常,&#123;&#125;&quot;</span>, e.getMessage());<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="DemoService2"><a href="#DemoService2" class="headerlink" title="DemoService2"></a>DemoService2</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoService2Impl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DemoService2</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> DemoDao demoDao;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 业务逻辑, 默认事务, 事务回滚异常 : Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED,rollbackFor = Exception.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doService</span><span class="hljs-params">()</span> </span>&#123;<br>        HashMap&lt;String, Integer&gt; param = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">2</span>);<br>        param.put(<span class="hljs-string">&quot;applId&quot;</span>, <span class="hljs-number">10</span>);<br>        param.put(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-number">10</span>);<br>        demoDao.insert2(param);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;因为一些原因,我处理失败了.&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>


<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoService1ImplTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> DemoService1 demoService1;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doService</span><span class="hljs-params">()</span> </span>&#123;<br>        demoService1.doService();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p><i>这里用到的事务配置为注解方式, 目前我们项目开发过程中使用配置文件方式, 一般为以下方式 . 这种方式的事务配置, 更容易引起问题</i></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><br>       	...<br>		<span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;do*&quot;</span>  /&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;doNew*&quot;</span>  <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRES_NEW&quot;</span> /&gt;</span><br>           ...<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">27</span>:<span class="hljs-number">38</span> [DEBUG] - [com<span class="hljs-selector-class">.erayt</span><span class="hljs-selector-class">.cms</span><span class="hljs-selector-class">.cms</span><span class="hljs-selector-class">.dao</span><span class="hljs-selector-class">.DemoDao</span>.insert1] prepare sql:[         insert into  ...<br><span class="hljs-number">27</span>:<span class="hljs-number">38</span> [DEBUG] - [com<span class="hljs-selector-class">.erayt</span><span class="hljs-selector-class">.cms</span><span class="hljs-selector-class">.cms</span><span class="hljs-selector-class">.dao</span><span class="hljs-selector-class">.DemoDao</span>.insert1] prepare parameters:[<span class="hljs-number">19</span>, <span class="hljs-number">19</span>]  ...<br><span class="hljs-number">27</span>:<span class="hljs-number">38</span> [DEBUG] - &#123;pstm-<span class="hljs-number">100001</span>&#125; Executing Statement:          insert into   ...<br><span class="hljs-number">27</span>:<span class="hljs-number">38</span> [DEBUG] - &#123;pstm-<span class="hljs-number">100001</span>&#125; Types: [java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Integer</span>, java<span class="hljs-selector-class">.lang</span>.Integer]  ...<br><span class="hljs-number">27</span>:<span class="hljs-number">38</span> [DEBUG] - [com<span class="hljs-selector-class">.erayt</span><span class="hljs-selector-class">.cms</span><span class="hljs-selector-class">.cms</span><span class="hljs-selector-class">.dao</span><span class="hljs-selector-class">.DemoDao</span>.insert2] prepare sql:[         insert into   ...<br><span class="hljs-number">27</span>:<span class="hljs-number">38</span> [DEBUG] - [com<span class="hljs-selector-class">.erayt</span><span class="hljs-selector-class">.cms</span><span class="hljs-selector-class">.cms</span><span class="hljs-selector-class">.dao</span><span class="hljs-selector-class">.DemoDao</span>.insert2] prepare parameters:[<span class="hljs-number">10</span>, <span class="hljs-number">10</span>]  ...<br><span class="hljs-number">27</span>:<span class="hljs-number">38</span> [DEBUG] - &#123;conn-<span class="hljs-number">100002</span>&#125; Preparing Statement:          insert into   ...<br><span class="hljs-number">27</span>:<span class="hljs-number">38</span> [DEBUG] - &#123;pstm-<span class="hljs-number">100003</span>&#125; Types: [java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Integer</span>, java<span class="hljs-selector-class">.lang</span>.Integer]  ...<br><span class="hljs-number">27</span>:<span class="hljs-number">38</span> [ERROR] - 业务<span class="hljs-number">2</span>处理异常,因为一些原因,我处理失败了.<br><span class="hljs-number">27</span>:<span class="hljs-number">38</span> [WARN ] - Caught exception while allowing TestExecutionListener  ...<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.transaction</span><span class="hljs-selector-class">.UnexpectedRollbackException</span>: Transaction rolled back because it has been marked as rollback-only<br>	at org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.transaction</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.AbstractPlatformTransactionManager</span><span class="hljs-selector-class">.commit</span> ...<br>	at org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.transaction</span><span class="hljs-selector-class">.TransactionContext</span><span class="hljs-selector-class">.endTransaction</span> ...<br>	at org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.transaction</span><span class="hljs-selector-class">.TransactionalTestExecutionListener</span><span class="hljs-selector-class">.afterTestMethod</span> ...<br>	at org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.TestContextManager</span><span class="hljs-selector-class">.afterTestMethod</span> ...<br>	<br><br></code></pre></td></tr></table></figure>

<h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>问题出现的代码为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>           demoService2.doService();<br>       &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>           logger.error(<span class="hljs-string">&quot;业务2处理异常,&#123;&#125;&quot;</span>, e.getMessage());<br>       &#125;<br></code></pre></td></tr></table></figure>

<p>问题原因是因为两个service中的方法doService均为默认事务(<b>REQUIRED</b>),<br>默认事务再被调用时, 如外层方法无事务, 自身会新启事务. 此时<code>#demoService1.doService()</code>的事务则为新启事务(<b>REQUIRES_NEW</b>) , 之后再被调用的方法<code>#demoService2.doService()</code>会加入到调用者<code>#demoService1.doService()</code>事务中. </p>
<p>又由于spring的事务回滚依托在异常之上, 当demoService2.doService()出现异常后它将事务标记为回滚. 异常抛出后被catch , demoService1.doService 没有接受到里面抛出的异常, 方法继续执行, 执行结束后, 事务提交. </p>
<p>但当demoService1在做commit的时候检测到事务被标记为回滚, 与预期不符, 也就是<code>Unexpected</code> 意想不到的</p>
<p><code>UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only</code></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>事务</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>初识并发编程</title>
    <url>//post/java-juc-first-meet.html</url>
    <content><![CDATA[<h1 id="初识并发编程"><a href="#初识并发编程" class="headerlink" title="初识并发编程"></a>初识并发编程</h1><blockquote>
<p>用了将近半年的碎片时间, 共计40个小时, 终于读完了这本阿里大佬方腾飞编写的《Java并发编程的艺术》现在将书中内容理解并消化，现在用自己的理解将书中内容‘倒出来’。后续将会更新这一系列的读书笔记。内容随笔作为自我知识学习的沉淀积累。</p>
</blockquote>
<a id="more"></a>

<p>我一般讲什么东西都喜欢用简单的理解去讲，而不是去按部就班。教材中有明确的字样对某些知识点的概况，但你去理解要理解很多新的内容，如果是具体的内容还好，如果是抽象的内容，可能会打消你学习的积极性或者让你对要理解的内容更难以理解接收。我总在试图用最简单的办法去传播知识，去学习接收知识。当然事实总会给你一记无情的巴掌，但我仍坚持用已知事务类比的方法去传播知识，让更多的人能够接收到更容易学而且更深的知识，当然这显然是一件很困难的事情（复杂度守恒定律），不过我愿意尽力的去坚持去做。</p>
<h2 id="什么是并发"><a href="#什么是并发" class="headerlink" title="什么是并发"></a>什么是并发</h2><blockquote>
<p>公交车的前门上车，后面下车其实就是一种并发。</p>
</blockquote>
<p>根据具体的业务场景不同，使用的并发形态也不同。但其中的原理都是一样，那就是<strong>同时进行皆并发</strong></p>
<ul>
<li>世界上所有生物同时呼吸就是并发</li>
<li>你现在听着歌看我的文章你也是在并发</li>
<li>你边走路边打电话是在并发</li>
<li>灯泡并联也是并发</li>
<li>~</li>
</ul>
<p>如果以上的例子中的同时进行改成按序执行即串行，非并发。在某些情况下可能会导致‘灾难’</p>
<ul>
<li>每个生物按序呼吸</li>
<li>你听歌的时候看不见东西，看得见东西听不了歌</li>
<li>你只能一动不动的打电话（而且你说话的时候什么都听不见）</li>
<li>灯泡串联</li>
<li>~</li>
</ul>
<h2 id="并发的应用"><a href="#并发的应用" class="headerlink" title="并发的应用"></a>并发的应用</h2><blockquote>
<p>上面是根据<strong>同时进行皆并发</strong>举了几个生活的例子，那并发如果将其应用到具体的程序中是什么呢？同时也说了一些串行的内容，在某些情况可能会导致‘灾难’。</p>
</blockquote>
<p>要知道并发的应用要知道两个计算机上的概念进程和线程。</p>
<ul>
<li>进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>结构的基础。</li>
<li>线程是<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>能够进行运算<a href="https://baike.baidu.com/item/%E8%B0%83%E5%BA%A6">调度</a>的最小单位</li>
</ul>
<p>用我的方法学习什么是进程什么是线程</p>
<ul>
<li>进程是我们每个人的一心一意，当你三心二意的时候就开启了多进程</li>
<li>线程就是你一心一意中的每个动作，包括你的思想。这就一定是多线程</li>
</ul>
<p><strong>举例</strong></p>
<p>张三今天在专心的写作业  - 启动了写作业进程</p>
<p>在写作业的时候张三用脑子思考，用手写，用眼睛看 - 张三开了3条线程来完成写作业这个进程的调度</p>
<p>张三边唱歌边吃饭边玩滑板 - 启动了玩滑板进程，吃饭进程，唱歌进程</p>
<p>他的脑子接到了很多指令，开始运行，啪！最后张三的腿脚线程一直阻塞着没机会执行，最后抛出异常张三没能完成这个作业。</p>
<hr>
<h2 id="并发程序"><a href="#并发程序" class="headerlink" title="并发程序"></a>并发程序</h2><blockquote>
<p>通过上面的内容我们知道了线程和进程的区别，线程是运行在进程中的 ，线程可以有多线程，进程也可以有多进程</p>
</blockquote>
<p>说了这么多，那我们并发编程到底是什么呢。</p>
<p><strong>需求一</strong></p>
<p>有100个人来参加一个宴会，需要在海报上签上自己的名字。大会需要大家在10分钟完成这个任务。假入只有一个笔，而且每个人签字的平均速度是7秒，签完名的时间大概是11分钟，我们要怎么解决这个问题？</p>
<p><strong>需求二</strong></p>
<p>我们有一个10TB的文件需要解析，我们假设需要3天完成这个任务，但是你设计个程序把文件从头读到为就需要4天，看似不可完成的任务该怎么做？</p>
<p><strong>解决方案</strong></p>
<p>针对需求一，我们可以再买一支笔，那大概6分钟就可以写完，3支笔4分钟， 4支笔3分钟 。。。100支笔 10秒钟？</p>
<p>需求二我们可以将文件分成两部分，让两个程序一起读，这样2天就看完了，拆成4部分1天拆成8部分半天，拆成100部分文件给你就看完了？</p>
<h2 id="并发遇到的问题"><a href="#并发遇到的问题" class="headerlink" title="并发遇到的问题"></a>并发遇到的问题</h2><p>在并发场景我们需要考虑几个问题</p>
<ol>
<li>数据一致性（安全性）</li>
<li>系统资源（性能，可用性）</li>
</ol>
<p><code>那什么是数据一致性问题？</code></p>
<p><strong>第一种情况</strong></p>
<p>在签到过程中，张三看见还有5支笔摆在那，但是张三却看不见他前面刚过去了5个人（多线程情况下各线程间隔离，共享进程资源）等张三过去的时候发现没有笔了，这个时候张三就会抛出来一个没有笔异常（NullPointException） 这里说明的就是张三看到的笔数量和实际的笔数量不相同（数据一致性问题）</p>
<p><strong>第二种情况</strong></p>
<p>将文件分开两部分后，两个程序过来读，恰好两个程序读的都是第一部分，等到程序执行完发现还有一部分没读，这个时候显然时间已经来不及了，这里说明两个程序看到的都是两部分数据，所有从第一部分开始读，但是当一个程序已经读了第一部分第二个程序不知道，所以它也读了第一部分（数据一致性问题）</p>
<p><code>那什么是系统资源问题呢？</code></p>
<p><strong>第一种情况</strong></p>
<p>你提供了100支笔给大家签到,100个人都会过去签到 , 假设100个人都拿到了笔,( 这里同样会有数据一致性的安全问题) 当他们过去海报签字的时候, 发现根本站不下, 不过好在当时海报边上设计的空地还有很大的位置, 大家可以站边上等一等. 你写完我在写(实际程序可不是这样, 实际程序的话有可能是你写一笔我写一笔, 上下文切换), (但实际情况可能更糟, 两个人写在了同一块地方, 张三名字写在了李四的上面, 只能看到张三的名字, 根本看不到李四的名字了(同样的数据一致性问题)) 如果海报设计的位置不够, 这个时候就会出现一个问题, 内存溢出</p>
<p>第二种情况类似</p>
<hr>
<h2 id="并发问题的引申问题"><a href="#并发问题的引申问题" class="headerlink" title="并发问题的引申问题"></a>并发问题的引申问题</h2><p>在上面我们发现了一些并发时的问题, 那问题清楚后, 我们就想办法去解决出现的问题. </p>
<ol>
<li>数据一致性（安全性）</li>
<li>系统资源（性能，可用性）</li>
<li>·····</li>
</ol>
<p>不同的问题我们有不同的解决方案, 如数据一致性的问题, 我们可以通过加锁来实现.</p>
<p>加锁以后我们会迎来另一系列的新的问题(性能问题, 死锁)</p>
<p>对于系统资源的问题我们也有对应的解决方案, 即分配合理的内存(这里不关注这个) 和 分配合理的线程数(笔的支数)</p>
<blockquote>
<p>这里引申的几个问题我们后面逐个从书中寻找答案, 带着问题去慢慢读享受这个过程, 加锁, 什么是锁, 怎么用锁. 分配资源, 分多少刚好合适?</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>和 lvgo 一起学设计模式（一）创建型之单例模式</title>
    <url>//post/lvgo-design-patterns-singleton.html</url>
    <content><![CDATA[<h1 id="单例（Singleton）模式-📍"><a href="#单例（Singleton）模式-📍" class="headerlink" title="单例（Singleton）模式 📍"></a>单例（Singleton）模式 📍</h1><blockquote>
<p>前排提醒：学习设计模式的时候，千万不要咬文嚼字。因为模式本身就是一种思想，我们将其思想领悟，然后活学活用，而不是为了学语文。为了技术，放下语文。因为你接触的模式越多，越会发现很多模式的定义的界线开始模糊，这就是模式本身。一生万物，万物归一。</p>
</blockquote>
<p>　　单例模式，顾明思议。单独的实例模式，其表达的意思即字面意思。它要解决的问题就是全局只能存在一个这样的类，或者说存在一个这样的类就可以满足业务需要了。</p>
<h2 id="思考以下问题🙄"><a href="#思考以下问题🙄" class="headerlink" title="思考以下问题🙄"></a>思考以下问题🙄</h2><p>　　你现在在做一个游戏，游戏中需要用到一个动作的音效🎵，而这个音效的大小有50M（假设），加载一次需要 2s 🕐左右的时间。你在测试的过程中发现，每次人物🧛‍♂️做出动作 2s 左右之后才会出现之前动作音效，现在你需要如何解决这个问题❓</p>
<h2 id="资源的合理分配和利用"><a href="#资源的合理分配和利用" class="headerlink" title="资源的合理分配和利用"></a>资源的合理分配和利用</h2><p>　　说到资源的合理分配和利用我想到了缓存，现在基本上大部分系统都会配备缓存，那为什么要配备缓存呢？扯远了，我们要谈的还是单例的问题。缓存的内容其实就是对资源的合理利用，比如我们<u>将一些大对象或者频繁的 IO 操作内容保存（缓存）在一个对象中</u>。而单例模式要解决的一个问题，就是这个问题，<strong>资源的合理分配和利用问题</strong></p>
<h2 id="你一直都在用的-singleton-模式"><a href="#你一直都在用的-singleton-模式" class="headerlink" title="你一直都在用的 singleton 模式"></a>你一直都在用的 singleton 模式</h2><blockquote>
<p>其实你如果细心一些你会发现，单例模式你每天都在使用</p>
</blockquote>
<p>　　相信我们每位小伙伴都写过一个类，叫做 GlobalConstants （全局常量）而这个类中定义的所有变量（variable）都是 static final 的，大家肯定都知道其中的原因，有 2 个原因：</p>
<ol>
<li>静态类变量全局访问</li>
<li>final 修饰使其内容不可变</li>
</ol>
<blockquote>
<p>哦，顺带一提，java  中 String 类也是 singleton 模式的一种体现，当然，这不绝对</p>
</blockquote>
<ul>
<li>常量</li>
<li>数据库连接池</li>
<li>Spring ApplicationContext</li>
<li>JSP Application</li>
<li>…….</li>
</ul>
<h2 id="单例模式结构📐"><a href="#单例模式结构📐" class="headerlink" title="单例模式结构📐"></a>单例模式结构📐</h2><p><img src="../images/posts/design-pattern/singleton/singleton.png" alt="单例模式结构类图 https://lvgocc.github.io"></p>
<p><strong>📢要点</strong></p>
<ol>
<li>对象有本身自行创建，即构造函数私有化。</li>
<li>全局统一访问，实例可被反复访问，即实例为静态实例。</li>
</ol>
<h2 id="单例模式实现的6种方式"><a href="#单例模式实现的6种方式" class="headerlink" title="单例模式实现的6种方式"></a>单例模式实现的6种方式</h2><blockquote>
<p><a href="https://github.com/lvgocc/java-design-patterns/tree/main/singleton">完整代码请参考源码目录</a></p>
</blockquote>
<p>　　对于单例模式的实现方法有很多种，也看到大家的思维很活跃。但我脑子也不好使。我只想解决一些根本问题（使用单例模式），所以，我们每种方法都讨论一下。🤣</p>
<p><strong><span style="color:red">划重点 : <u>‼ 单例模式的创建只能自己完成</u></span></strong></p>
<h3 id="1-延迟加载方式1（懒汉式）-线程不安全❓"><a href="#1-延迟加载方式1（懒汉式）-线程不安全❓" class="headerlink" title="1. 延迟加载方式1（懒汉式）(线程不安全❓)"></a>1. 延迟加载方式1（懒汉式）(线程不安全❓)</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayLoadSingleton1</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DelayLoadSingleton1 delayLoadSingleton1;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">DelayLoadSingleton1</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DelayLoadSingleton1 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (delayLoadSingleton1 == <span class="hljs-keyword">null</span>) &#123;<br>            delayLoadSingleton1 = <span class="hljs-keyword">new</span> DelayLoadSingleton1();<br>        &#125;<br>        <span class="hljs-keyword">return</span> delayLoadSingleton1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于<strong>延迟加载（懒汉式）</strong>单例模式的线程不安全其实说的就线程对共享数据的使用而言，但就具体问题而言，<u>单例模式本身就没有线程安全与不安全只分。之所以考虑到线程安全不安全，其实是对上面所说的<strong>资源的合理分配和利用</strong></u>，这种方式很明显没有做到<strong>资源的合理分配和利用</strong>。如果在多线程场景下很可能造成资源的浪费。</p>
<p>单例模式，根本就没有线程安全与不安全，是错误的使用导致它有了这个问题。</p>
<blockquote>
<p>📃lvgo语录：学东西要知其然而知其所以然，即使千年流传的东西，你都应该保持着一颗质疑的心。❓❤🙄</p>
</blockquote>
<h3 id="2-延迟加载方式2（懒汉式）"><a href="#2-延迟加载方式2（懒汉式）" class="headerlink" title="2. 延迟加载方式2（懒汉式）"></a>2. 延迟加载方式2（懒汉式）</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayLoadSingleton2</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 增加 volatile 修饰，解决变量可见性问题</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> DelayLoadSingleton2 delayLoadSingleton1;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">DelayLoadSingleton2</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法使用同步锁🔒，同时只能有一个客户端来请求该方法，去创建实例。</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 如果不使用同步方法，可能会出现两个以上线程同时创建了多个对象，破坏了单例模式，至于线程安全，其实也是说对资源的合理利用。拒绝了重复创建</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> DelayLoadSingleton2 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (delayLoadSingleton1 == <span class="hljs-keyword">null</span>) &#123;<br>            delayLoadSingleton1 = <span class="hljs-keyword">new</span> DelayLoadSingleton2();<br>        &#125;<br>        <span class="hljs-keyword">return</span> delayLoadSingleton1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>关于 volatile 的更多内容欢迎在个人博客搜索关键字 “volatile”</p>
</blockquote>
<p>通过使用同步锁与 volatile 使得单例模式变得<del>安全</del>资源合理的分配和利用，但每次调用都要同步，岂不是另外一种资源的浪费体现？🙄</p>
<h3 id="3-双重检查锁-（DCL）"><a href="#3-双重检查锁-（DCL）" class="headerlink" title="3. 双重检查锁 （DCL）"></a>3. 双重检查锁 （DCL）</h3><p>　　既然要合理利用资源，又要保证调用方法本身不产生资源浪费。这样就促成了 DCL 双重检查锁方式。<em>（技术人的思维就是这么活，一个单例模式被实现的五花八门。害的我们这些设计模式学徒从入门到放弃越来越快）</em></p>
<p>　　前面说了 DCL 是为了解决资源的合理分配和利用，那我们一起来看看 DCL 是如何工作的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DCLSingleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> DCLSingleton dclSingleton;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">DCLSingleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DCLSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 定义这个局部变量可以提高大约25%的性能🚀 依据:Joshua Bloch &quot;Effective Java, Second Edition&quot;, p. 283-284</span><br>        DCLSingleton current = dclSingleton;<br>        <span class="hljs-comment">// 1️⃣ 第一次检查</span><br>        <span class="hljs-keyword">if</span> (dclSingleton == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 🔒此时为了保证线程安全,我们不清楚其他线程是否已经实例化该对象,所以将类上锁达到互斥效果</span><br>            <span class="hljs-keyword">synchronized</span> (DCLSingleton.class) &#123;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * 再次将实例分配给局部变量并检查它是否由其他某个线程初始化</span><br><span class="hljs-comment">                 * 当前线程被阻止进入锁定区域。 如果它已初始化，那么我们可以</span><br><span class="hljs-comment">                 * 返回先前创建的实例，就像上面检查对象是否为空一样。</span><br><span class="hljs-comment">                 */</span><br>                current = dclSingleton;<br>                <span class="hljs-comment">// 2️⃣ 第二次检查</span><br>                <span class="hljs-keyword">if</span> (dclSingleton == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// 如果此时该类还没有被实例化,那么我们就可以安全的实例化一个单例的该对象实例.</span><br>                    current = dclSingleton = <span class="hljs-keyword">new</span> DCLSingleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> current;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>　　📃笔记：DCL 方式是为了解决延迟加载（懒汉式）中的资源合理分配和利用问题。</p>
<p>　　<strong>当然，以上 3 种方式我，注意是我！全不推荐使用！！</strong>😂</p>
<hr>
<h3 id="4-立即加载方式（饿汉式）"><a href="#4-立即加载方式（饿汉式）" class="headerlink" title="4. 立即加载方式（饿汉式）"></a>4. 立即加载方式（饿汉式）</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StraightwaySingleton</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> StraightwaySingleton straightwaySingleton = <span class="hljs-keyword">new</span> StraightwaySingleton();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">StraightwaySingleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StraightwaySingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> straightwaySingleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>　　立即加载方式是通过 classloader 来完成单例的创建，即当类第一次被主动调用初始化的时候。即使该类你不会使用（但是❗不用你还要设计成单例，我觉得这种方式已经可以满足一般的业务场景了）</p>
<p><strong>Runtime.java 中使用该种方式实现</strong></p>
<blockquote>
<p>拓展类的装载过程：加载 -  验证 - 准备 - 解析 - 初始化 - 使用 -  卸载</p>
</blockquote>
<h3 id="5-内部类-（推荐使用）"><a href="#5-内部类-（推荐使用）" class="headerlink" title="5. 内部类 （推荐使用）"></a>5. 内部类 （推荐使用）</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClassSingleton</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">InnerClassSingleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InnerClassSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> InnerClassSingletonBuild.innerClassSingleton;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClassSingletonBuild</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> InnerClassSingleton innerClassSingleton = <span class="hljs-keyword">new</span> InnerClassSingleton();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方式综合使用了Java的 <strong><u>类级内部类</u></strong> 和多线程缺省同步锁的知识 JVM 来保证资源不会被浪费，巧妙地同时实现了<strong>延迟加载和线程安全</strong>，比起花里胡哨的 DCL ，这种方式更好的解决了实质的问题，并且没有了 DCL 的副作用，同时不受jdk版本的影响。</p>
<p><span style="color:red"><strong>👍当你的业务场景，很明确系统 📢<u>启动不需要的时候，以后也不知道需不需要</u> ，不用怀疑，用它！稳！资源控制的死死的</strong></span></p>
<p><em>一般我们默认会选择这种方式来实现单例模式，简单、好用、强大。</em></p>
<p>关于内部类的一些拓展，更多关于内部类内容查看我的 <a href="https://blog.csdn.net/sinat_34344123/article/details/81942427">CSDN 博客</a></p>
<p><strong>内部类分为对象级别和类级别</strong></p>
<ul>
<li><p>类级内部类指的是，有static修饰的成员变量的内部类。</p>
</li>
<li><p>如果没有static修饰的成员变量的内部类被称为对象级内部类。</p>
</li>
</ul>
<p>类级内部类相当于其外部类的static成员，它的对象与外部类对象间不存在依赖关系，相互独立，因此可直接创建。</p>
<p>对象级内部类的实例，是必须绑定在外部对象实例上的。</p>
<p><strong><u>类级内部类只有在第一次被使用的时候才被会装载。</u></strong></p>
<h3 id="6-枚举（推荐使用）"><a href="#6-枚举（推荐使用）" class="headerlink" title="6. 枚举（推荐使用）"></a>6. 枚举（推荐使用）</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">EnumIvoryTower</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 实例</span><br><span class="hljs-comment">     */</span><br>    INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>这种方法是一个叫做 Joshua Bloch 的人提出的，对于学习这种单例模式，我觉得更有必要带大家认识一下这个人。待会介绍。先说这种设计方式。</p>
</blockquote>
<p><span style="color:red"><strong>👍 Joshua Bloch 推荐的一种单例方式，与立即加载方式有过之而无不及。</strong></span></p>
<p><strong>简单、大方、得体、<del>完美</del>❓</strong></p>
<p>对于用枚举来实现单例模式近乎完美。因为它完完全全的由虚拟机来完成单例创建，这种方式是不是想到了和我们上面讲到的一个方式有点类似，没错，就是我们的立即加载方式（饿汉式），但是它相比立即加载方式却多了很多内容。就是我们接下来要说的保护单例模式。</p>
<h2 id="保（po）护（huai）单例模式"><a href="#保（po）护（huai）单例模式" class="headerlink" title="保（po）护（huai）单例模式"></a>保（po）护（huai）单例模式</h2><h3 id="破坏单例"><a href="#破坏单例" class="headerlink" title="破坏单例"></a>破坏单例</h3><p>有即时我们使用了以上的方式创建单例对象，同样会有两种方式来破坏单例对象 （除枚举方式外）</p>
<ol>
<li>通过反射破坏单例</li>
<li>通过序列化破坏单例</li>
</ol>
<h3 id="保护单例"><a href="#保护单例" class="headerlink" title="保护单例"></a>保护单例</h3><p>上面的两点对于枚举来说，不存在。但我们自己写的方法如何规避这两点呢？</p>
<ol>
<li>调整私有构造函数，阻止反射调用单例。</li>
<li>重写 readResolve() 方法。</li>
</ol>
<h4 id="调整私有构造函数，阻止反射调用单例"><a href="#调整私有构造函数，阻止反射调用单例" class="headerlink" title="调整私有构造函数，阻止反射调用单例"></a>调整私有构造函数，阻止反射调用单例</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 解决反射创建对象破解单例模式</span><br>   <span class="hljs-keyword">if</span> (dclSingleton != <span class="hljs-keyword">null</span>) &#123;<br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Already initialized&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure>

<h4 id="重写-readResolve-方法"><a href="#重写-readResolve-方法" class="headerlink" title="重写 readResolve() 方法"></a>重写 readResolve() 方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 解决反序列化创建对象破坏单例模式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> straightwaySingleton;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="单例模式总结"><a href="#单例模式总结" class="headerlink" title="单例模式总结"></a>单例模式总结</h2><h3 id="📢要点"><a href="#📢要点" class="headerlink" title="📢要点"></a>📢要点</h3><ol>
<li>对象有本身自行创建，即构造函数私有化。</li>
<li>全局统一访问，实例可被反复访问，即实例为静态实例。</li>
</ol>
<h3 id="实现方式的选择"><a href="#实现方式的选择" class="headerlink" title="实现方式的选择"></a>实现方式的选择</h3><p>内部类 &gt; 枚举 &gt; 立即加载</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><del>优缺点</del></h3><p><del>我以为设计模式本身就是一种解决问题的办法，优缺点就本身而言有意义。相对来说即无意义。既然选择了这种模式，那固然有一定的道理。所以以后设计模式的优缺点也不会过多发表意见，没有最好，只有最合适。优缺点已经没有意义了。</del></p>
<p><del>优点：资源的合理分配和利用</del></p>
<p><del>缺点：违反了单一职责原则</del></p>
<h2 id="简单说说-Joshua-Bloch"><a href="#简单说说-Joshua-Bloch" class="headerlink" title="简单说说 Joshua Bloch"></a>简单说说 Joshua Bloch</h2><p>《Effective Java》、Effective 系列图书作者。同时我们每天都在使用着他写的代码，集合框架，它们的位置位于<code>java.util.*</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> * <span class="hljs-meta">@param</span> &lt;E&gt; the type of elements in <span class="hljs-keyword">this</span> collection<br> *<br> * <span class="hljs-meta">@author</span>  Josh Bloch<br> * <span class="hljs-meta">@author</span>  Neal Gafter<br> * <span class="hljs-meta">@see</span>     Set<br> * <span class="hljs-meta">@see</span>     List<br> * <span class="hljs-meta">@see</span>     Map<br> * <span class="hljs-meta">@see</span>     SortedSet<br> * <span class="hljs-meta">@see</span>     SortedMap<br> * <span class="hljs-meta">@see</span>     HashSet<br> * <span class="hljs-meta">@see</span>     TreeSet<br> * <span class="hljs-meta">@see</span>     ArrayList<br> * <span class="hljs-meta">@see</span>     LinkedList<br> * <span class="hljs-meta">@see</span>     Vector<br> * <span class="hljs-meta">@see</span>     Collections<br> * <span class="hljs-meta">@see</span>     Arrays<br> * <span class="hljs-meta">@see</span>     AbstractCollection<br> * <span class="hljs-meta">@since</span> <span class="hljs-number">1.2</span><br> */<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">E</span>&gt; </span><br></code></pre></td></tr></table></figure>



<p>老爷子的github ：<a href="https://github.com/jbloch">https://github.com/jbloch</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>和 lvgo 一起学设计模式（七）结构型之装饰者模式</title>
    <url>//post/lvgo-design-patterns-decorator.html</url>
    <content><![CDATA[<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>一直都有看到“包装者模式“ 出现在一些文章，甚至书中。它们被应用在装饰者模式和适配器模式中，这个原因笔者猜测源自 GOF 最早在书中给模式命名的时候提到了这两个模式的别名 wrapper同时还有适配器也被成为 wrapper, 所以有人将这几个名称混来混去。后来 GOF 在结尾讲书的简史的时候有提到一些模式的名称变化，其中 glue 改成了 facade， wrapper 改为 decorator ，walker 变成了 visitor 。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前阵子出于自己学习使用的原因开发了一个 chrome extension ，这样我的 chrome 变得比以前更强了，我赋予了它一个可以保存某个页面的某个片段的位置，后续通过点击这个记录可以快速的回到并高亮当时浏览的记录。</p>
<p><img src="https://i.loli.net/2020/10/24/hb75jWUIlHGdmu1.png" alt="memo1"></p>
<p><img src="https://i.loli.net/2020/10/24/HamO9V56Y3bMKJP.png" alt="memo"></p>
<p><strong>我给 chrome 简单的装饰了一下（加了一个插件），它就变强了</strong></p>
<p><code>插件开源，可以作为基础进行二次开发，想要开发 chrome 插件但是不知道如何开始的可以参考。关注</code><strong>星尘的一个朋友</strong><code>公众号，回复源码获取</code></p>
<h2 id="不知不觉你已经知道了装饰者的概念。"><a href="#不知不觉你已经知道了装饰者的概念。" class="headerlink" title="不知不觉你已经知道了装饰者的概念。"></a>不知不觉你已经知道了装饰者的概念。</h2><blockquote>
<p>动态地给一个对象添加一些额外的职责</p>
</blockquote>
<p><img src="https://i.loli.net/2020/10/24/j7fU3RozypgGWAN.png" alt="chrome"></p>
<p><img src="https://i.loli.net/2020/10/24/EqQbkpzTeP6n5t3.png" alt="chrome"></p>
<p>上面两个举出的例子在实际过程中只要你想，你可以无限的装饰它，所以装饰者的类，可以一直嵌套下去。就像</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">InputStream in = <span class="hljs-keyword">new</span> DataInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;filePath&quot;</span>)));<br></code></pre></td></tr></table></figure>

<p>如果IO不熟，看得不理解，那再看看这个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;Object&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list = Collections.synchronizedList(list);<br></code></pre></td></tr></table></figure>

<p>其实，当我写到这里的时候已经很清楚装饰者的概念了，它就是通过“套娃”变强了😂！</p>
<p>让我继续深入看看它的结构图👀。</p>
<h2 id="装饰者模式类图-📌"><a href="#装饰者模式类图-📌" class="headerlink" title="装饰者模式类图 📌"></a>装饰者模式类图 📌</h2><p><img src="https://i.loli.net/2020/10/25/L2a951Jf7cIspGK.png" alt="装饰者模式类图"></p>
<p>一个浏览器的接口，一个 Chrome 实现类，一个 ChromeExtension 插件的实现类（用以装饰 Chrome），扩展中的构造函数为 浏览器类型，在插件类中会对浏览器 Brower 的 browse 方法进行一层装饰（增强，或减弱），在不改变对象的情况下，对对象行为进行动态的改变。</p>
<p>上面的类图在抽象一层的话就变成了了这个样子</p>
<p><img src="https://i.loli.net/2020/10/24/iJMe7mblkcOGTV2.png" alt="装饰者模式类图"></p>
<blockquote>
<p>为了示意，名称使用了中文，当然如果能够让人清楚你在干什么，无所谓你怎么表达。</p>
</blockquote>
<p>通过对象的组合来实现类的增强要比继承更加的灵活。这也是软件设计原则中的组合复用原则的一种体现，优先使用组合，然后考虑继承。</p>
<h2 id="代码-📄"><a href="#代码-📄" class="headerlink" title="代码 📄"></a>代码 📄</h2><blockquote>
<p>关注公众号：星尘的一个朋友 回复：<code>源码</code>，获取全部代码和类图</p>
</blockquote>
<p><img src="https://i.loli.net/2020/10/25/qsjOMU9HLpcnlzP.png" alt="decorator-code"></p>
<p>代码演示通过一个游戏获取道具的方式来理解装饰者模式的具体实现；</p>
<p>想来想去，我没有选择超级玛丽，图难找，代码不好表达🤣</p>
<p>所以我选择了它 <strong>Tank Battle</strong> <img src="https://i.loli.net/2020/10/24/KED9OZhFk7WGtbl.jpg" alt="tank">😂</p>
<p><code>很多回忆都在这里</code>而且好表达😁</p>
<p>在这游戏中，我们吃到一个星星⭐的时候，就会变强，可以发射两发子弹，同时样子也会发生改变。</p>
<p><img src="https://i.loli.net/2020/10/25/hfzJVmHCj6sNIEq.png" alt="image-20201025111349260"> 吃了这个星（装饰），我变得更强 <img src="https://i.loli.net/2020/10/24/uQvdNDEV7JmLBCZ.gif" alt="p1tankU">  ==&gt;&gt;  <img src="https://i.loli.net/2020/10/24/QvIyB28tdxSjnrK.gif" alt="star"> ==&gt;&gt; <img src="https://i.loli.net/2020/10/25/ANrTSZUghK5lcot.gif" alt="enemy3U"></p>
<h3 id="结构组成"><a href="#结构组成" class="headerlink" title="结构组成"></a>结构组成</h3><ol>
<li>被装饰者接口</li>
<li>具体的装饰者类</li>
<li>抽象装饰者</li>
<li>具体的装饰者</li>
</ol>
<p>因为星星强化一共有 3 个级别</p>
<ul>
<li><p>移动、子弹加速</p>
</li>
<li><p>连发</p>
</li>
<li><p>打掉白色方块</p>
</li>
</ul>
<p>所以我们应该有 3 个装饰者。类角色。</p>
<ol>
<li>被装饰者接口 -&gt; 坦克 Tank</li>
<li>具体的被装饰者 -&gt; 玩家坦克 PlayerTank</li>
<li>抽象装饰者 -&gt; 用来抽象定义装饰者基本信息，如构造函数等 TankDecorator</li>
<li>具体的装饰者 -&gt; OneStarTankDecorator -&gt; TwoStarTankDecorator -&gt; ThreeStarTankDecorator</li>
</ol>
<p><img src="https://i.loli.net/2020/10/25/LySXmYe7CJov9wx.png" alt="decorator"></p>
<p><strong>部分代码</strong></p>
<blockquote>
<p>关注公众号：<code>星尘的一个朋友</code> 回复：<code>源码</code>，<strong>获取全部代码和类图</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 玩家坦克</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/10/25 11:40</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlayerTank</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tank</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 玩家默认坦克数据，移动，设计速度 1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PlayerTank</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义坦克抽象装饰者</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/10/25 11:40</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TankDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tank</span></span>&#123;<br><br>    <span class="hljs-keyword">protected</span> Tank tank;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TankDecorator</span><span class="hljs-params">(Tank tank)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.tank = tank;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">()</span> </span>&#123;<br>        tank.move();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fire</span><span class="hljs-params">()</span> </span>&#123;<br>        tank.fire();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>测试结果</p>
<p><img src="https://i.loli.net/2020/10/25/FaRXJTVbftoL3sY.png" alt="image-20201025141131981"></p>
<h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>坦克增强的过程是一颗星一颗星获取的一个过程，一直在动态的增强。这个案例中只是一个维度，坦克吃星星。如果在增加一些额外的功能时，比如坦克变身，进化等等，不断的增加装饰时，就可以体会到装饰者模式组合的可扩展性。当然使用继承来实现的话，如果是单一不变的多种状况是很好的，比如说我的玩家坦克的选择不同的外观，可通过不同的子类来确定下来，但如果动态的想要增加一个类的时候，继承就显得非常的困难。</p>
<p>装饰者模式在不改变原对象的情况下，动态的增强具有较好的可扩展性。这也体现了<code>开闭原则</code>。但我们发现，如果你不合理的使用装饰者模式，类的数量会变的更多，且多重装饰使一个对象的维护变的更加复杂。所以，就像前面说的，具体的特性就完全可以用继承来实现而非装饰者模式，装饰者模式一定是使用在想要动态的给对象增加一些功能的时候使用。</p>
<ul>
<li><p>比如 JDK 中对 IO 的操作有一个 read() 操作，对它进行装饰之后就变成了 readLine().<br><img src="https://i.loli.net/2020/10/25/hBN54spCA7yaqto.png" alt="image-20201025143102142"><br><img src="https://i.loli.net/2020/10/25/thRfTdxnbvZpNEV.png" alt="image-20201025143124892"><br><img src="https://i.loli.net/2020/10/25/abst7No5EjLGFQY.png" alt="image-20201025143158945"></p>
</li>
<li><p>再比如 JDK 中的 Collections 工具类，通过对集合类的装饰，使其变得线程安全，而对象本身却没有发生改变</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/10/25/qfHuhsSwnGMLY4F.png" alt="image-20201025143320753"></p>
<p><img src="https://i.loli.net/2020/10/25/VXEMplcQaYkmHBy.png" alt="image-20201025143355998"></p>
<p>仅仅是对原来的方法前面都加了 <code> synchronized</code> 关键字来对原对象做了增强</p>
<p><img src="https://i.loli.net/2020/10/25/MFXhDSzmRg3lAoT.png" alt="image-20201025143507646"></p>
<p>而 List 本身仍有更多的子类。Collections 工具类提供的就是对 List 对象做增强。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>当我们明白了一件事物的本质之后，再去看表象会变的轻而易举。而这最关键的是要去亲自的操作它，看着再简单不过的东西，你第一次动手都会有很大的收获。这也让我想起了初中物理课本最常见的一句话</p>
<p><img src="https://i.loli.net/2020/10/25/TI5ECVzNZQgqi6A.jpg" alt="img"></p>
<p>任何情况下，看会和听懂都不是掌握。再不济语文课也学过“书读百遍其义自见”也是要动动嘴的🗣。加油！</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>和 lvgo 一起学设计模式（三）创建型之抽象工厂模式</title>
    <url>//post/lvgo-design-patterns-abstract-factory.html</url>
    <content><![CDATA[<h1 id="抽象工厂模式-🌉"><a href="#抽象工厂模式-🌉" class="headerlink" title="抽象工厂模式 🌉"></a>抽象工厂模式 🌉</h1><blockquote>
<p>提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</p>
</blockquote>
<h2 id="概念理解（重要❗❗❗）"><a href="#概念理解（重要❗❗❗）" class="headerlink" title="概念理解（重要❗❗❗）"></a>概念理解（重要❗❗❗）</h2><p>　　特别强调了一下抽象工厂模式的概念理解部分我觉得是非常有必要的，当然我在写下这篇文章之前看过很多优秀的博文、书籍、视频等资料对抽象工厂模式的讲解和代码示例等内容，但我发现。抽象工厂的概念被一次又一次的刷新，所以我也想表达一下自己对抽象工厂的理解。如果你和我持不同的意见，可以继续往下看，我很愿意和你一起讨论这个问题。</p>
<p>　　看我过之前的文章应该知道了我写的工厂模式的概念和代码实现，以及使用的时机。而抽象工厂模式的实现，等于工厂方法模式的实现。</p>
<p>　　那为什么会有两个模式的定义出现呢？这个问题解决了，那我们的概念就捋清楚了。我们一起来回顾一下这两个模式的定义：</p>
<ol>
<li>工厂（Factory）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li>
<li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li>
</ol>
<p>　　我们将上面的两个模式的定义放在一起总结一下，是不是可以认为是，首先定义一个工厂接口，由子类去实现具体的工厂。如果我总结的定义你可以认可，那继续往下看。不认可忍一忍，看完再喷。让我们通过代码在理解一下。</p>
<p>　　<strong>❗下面内容很关键，希望你能认真看完</strong>。当然，不建议死扣字眼和代码，还是最初的那个誓言，学习设计模式的思想。而不是学语文。</p>
<h2 id="一行代码-❗"><a href="#一行代码-❗" class="headerlink" title="一行代码 ❗"></a>一行代码 ❗</h2><h3 id="工厂方法模式的伪代码"><a href="#工厂方法模式的伪代码" class="headerlink" title="工厂方法模式的伪代码"></a>工厂方法模式的伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 电子工厂</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ElectronicsFactory</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生产一个手机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Phone <span class="hljs-title">creatPhone</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 苹果手机电子工厂</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IphoneElectronicsFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ElectronicsFactory</span></span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生产一个苹果手机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Phone <span class="hljs-title">creatPhone</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IPhone()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 小米手机电子工厂</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiPhoneElectronicsFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ElectronicsFactory</span></span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生产一个苹果手机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Phone <span class="hljs-title">creatPhone</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MiPhone()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="让我们在看一下抽象工厂模式的伪代码"><a href="#让我们在看一下抽象工厂模式的伪代码" class="headerlink" title="让我们在看一下抽象工厂模式的伪代码"></a>让我们在看一下抽象工厂模式的伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 电子工厂</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ElectronicsFactory</span> </span>&#123;<br><br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生产一个手机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Phone <span class="hljs-title">creatPhone</span><span class="hljs-params">()</span></span>;<br>    <br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生产一个电脑</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Computer <span class="hljs-title">creatComputer</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 苹果电子工厂</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleElectronicsFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ElectronicsFactory</span></span>&#123;<br><br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生产一个苹果手机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Phone <span class="hljs-title">creatPhone</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IPhone()<br>    &#125;<br>    <br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生产一个苹果电脑</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Computer <span class="hljs-title">creatComputer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MACBook();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 小米电子工厂</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiElectronicsFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ElectronicsFactory</span></span>&#123;<br><br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生产一个小米手机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Phone <span class="hljs-title">creatPhone</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MiPhone()<br>    &#125;<br>    <br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生产一个小米电脑</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Computer <span class="hljs-title">creatComputer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MiComputer();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>我们通过工厂方法模式，可以得到各种各样的同类型产品（都是手机），但我们如果通过抽象工厂模式，就可以得到各种各样同个产品族的产品（一个品牌的所有产品）<strong>而这一切的内容，仅仅相差了一行代码</strong> 。<strong>同样的，当抽象工厂中只有一个工厂时，它与工厂模式，没有什么不同。</strong></p>
<p><img src="https://i.loli.net/2020/10/15/ojTOhcA9eB8X2IJ.gif"></p>
<blockquote>
<p>工厂方法模式只考虑生产同等级的产品，抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族（品牌）</p>
<p>来源：<a href="http://c.biancheng.net/view/1351.html">http://c.biancheng.net/view/1351.html</a></p>
</blockquote>
<h2 id="抽象工厂类图-🖌"><a href="#抽象工厂类图-🖌" class="headerlink" title="抽象工厂类图 🖌"></a>抽象工厂类图 🖌</h2><p><img src="https://i.loli.net/2020/10/16/9Rj52oePSYbqiry.png" alt="抽象工厂类图"></p>
<h2 id="具体代码-📄"><a href="#具体代码-📄" class="headerlink" title="具体代码 📄"></a>具体代码 📄</h2><blockquote>
<p>完整代码及单元测试结果 <a href="https://github.com/lvgocc/java-design-patterns/tree/main/abstract-factory">https://github.com/lvgocc/java-design-patterns/tree/main/abstract-factory</a></p>
</blockquote>
<p>代码在上面已经罗列过，这里就不在赘述，需要的同学可以移步上面链接。可以的话，给个star吧（脸皮厚的不行）</p>
<h2 id="总结-✨"><a href="#总结-✨" class="headerlink" title="总结 ✨"></a>总结 ✨</h2><p>抽象工厂与工厂方法模式为同一种设计思想，他们不同于简单工厂。因为看了很多资料，对这部分内容的描述各有千秋。所以我在这里也表达了自己的一些看法。参考内容感兴趣的小伙伴可以看一下，我们一起讨论一下是极好的</p>
<ul>
<li><a href="http://c.biancheng.net/view/1351.html">http://c.biancheng.net/view/1351.html</a></li>
<li><a href="https://www.journaldev.com/1392/factory-design-pattern-in-java">https://www.journaldev.com/1392/factory-design-pattern-in-java</a></li>
<li><a href="https://www.journaldev.com/1418/abstract-factory-design-pattern-in-java">https://www.journaldev.com/1418/abstract-factory-design-pattern-in-java</a></li>
</ul>
<p>再回到上面的两个定义：</p>
<ol>
<li>工厂（Factory）模式：<strong>定义一个用于创建产品的接口，由子类决定生产什么产品。</strong></li>
<li>抽象工厂（AbstractFactory）模式：<strong>提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</strong></li>
</ol>
<p>抽象工厂，比如’富士康‘，细品一下，他就有多个产品族，此时你应该明白了抽象工厂的概念和与工厂方法模式的区别（相差一行代码，相差一个产品族），如果被我说晕了，我真的很抱歉，愿意的话可以与我私聊。</p>
<p>当然相差一行代码是为了表达两者直接的关系，在实际应用情况下还是遵循标准的命名规范。避免产生歧义，出现理解误差。</p>
<p>　　文末的<strong>JDK中的抽象工厂设计模式示例</strong>生产的就是一个系列，所以上面也提到了抽象工厂与工厂本身并无大差别，当你一个工厂可以生产出多个系列的产品的时候，其实他就是抽象工厂了。比如看过我上一篇工厂模式文章的小伙伴就会发现，文末给出的 JDK 例子使用的是静态工厂模式。这一次给出的是抽象工厂（工厂方法模式）。抽象工厂与工厂方法本是同根生。我知道我把你说绕了，但是我的初衷是让你清楚这两者（抽象工厂模式与所谓的工厂方法模式），本就是一个思想。</p>
<p><strong>🔔如果觉得我没说明白的请联系我，非常乐意被打扰</strong></p>
<p><code>如果上面星尘表述的内容没能讲清楚抽象工厂的概念，大家不要急。继续往下看。如果我说的还不明白，给我个机会，加我微信（lvgocc）或者公众号内私聊，直到聊清楚为止。你若不会，我愿受累，为了你，我愿意执着🐱‍💻。</code></p>
<h2 id="使用时机"><a href="#使用时机" class="headerlink" title="使用时机"></a>使用时机</h2><ul>
<li>当你想要管理多个系列产品的时候，比如多个套餐？多种策略组合？看你需求，合理使用，总之多系列就用它！</li>
</ul>
<p>例如你有一套方法，在不同的操作系统需要使用不同的实现，那这个时候你就可以使用抽象工厂，可以让它在不同的操作系统下发挥不同的功能。</p>
<p>　　</p>
<h2 id="JDK中的抽象工厂设计模式示例"><a href="#JDK中的抽象工厂设计模式示例" class="headerlink" title="JDK中的抽象工厂设计模式示例"></a>JDK中的抽象工厂设计模式示例</h2><blockquote>
<p>案例来源：<a href="https://www.journaldev.com/1418/abstract-factory-design-pattern-in-java">https://www.journaldev.com/1418/abstract-factory-design-pattern-in-java</a></p>
</blockquote>
<ul>
<li>javax.xml.parsers.DocumentBuilderFactory＃newInstance（）</li>
<li>javax.xml.transform.TransformerFactory＃newInstance（）</li>
<li>javax.xml.xpath.XPathFactory＃newInstance（）</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>和 lvgo 一起学设计模式（九）结构型之适配器模式</title>
    <url>//post/lvgo-design-patterns-adapter.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/10/29/ir7LvpWXUykRABw.png" alt="adapter-title.png"></p>
<h1 id="什么是”榫”"><a href="#什么是”榫”" class="headerlink" title="什么是”榫”"></a>什么是”榫”</h1><p>嘶衣唔嗯ěn损，fao喽密，榫！</p>
<p>首先，让我们面向百度学习一波。</p>
<p><img src="https://i.loli.net/2020/10/28/aDRfCgLMbvmUZnS.png" alt="sun.png"></p>
<p>榫[sǔn]：制木竹等器物时，为使两块材料接合所特制的凸凹部分。</p>
<p>感觉不够直观，找点图看看。</p>
<p><img src="https://i.loli.net/2020/10/28/xPUfBl5RESaKW8J.png" alt="sun-picture.png"></p>
<p>再来点</p>
<p><img src="https://i.loli.net/2020/10/28/k4rIqmhKWfe5L76.png" alt="sun-picture2.png"></p>
<p>这里我借花献佛一下，榫说的是两块材料接合凸起的部分，凹进去的部分叫卯。</p>
<p>这东西是干什么用的呢，我不说大家也知道，是两块材料接合所用（切，这不废话吗，就是百度百科上说的么）。在中国建筑当中这个榫卯的用途可以说是处处皆是。现在已经火到了国外。</p>
<h1 id="榫卯"><a href="#榫卯" class="headerlink" title="榫卯"></a>榫卯</h1><p>本来两种材料，一榫、一卯搭配的天衣无缝，怪就怪这建筑用的多了起来之后，各种各样的榫，各种各样的卯。也没办法统一，垄断法了解一下。</p>
<blockquote>
<p>以下图片资源来自《设计模式之禅（第2版）》对其进行了一些简单的调整。</p>
</blockquote>
<p><strong>原来都是这样进行搭配</strong></p>
<p><img src="https://i.loli.net/2020/10/28/Qx7Om2BNFEro8fW.png" alt="adapter.png"></p>
<p><strong>突然有一天给了我一个</strong></p>
<p><img src="https://i.loli.net/2020/10/28/TzyObZe9FwC8GEh.png" alt="adapter1.png"></p>
<p>这两个材料怎么接，榫不对卯，卯不对榫，接不上啊。</p>
<p><img src="https://i.loli.net/2020/10/29/1h7yW2JRQPDzpgl.png" alt="adapter2.png"></p>
<p>这可难不倒伟大的工匠艺人们，他们做出来了一个 榫卯，大概是这个样子。</p>
<p><img src="https://i.loli.net/2020/10/28/w165r3qAvaLFNXO.png" alt="adapter3.png"></p>
<p>这样他们就能完美的接在一起使用了。这就是榫卯。</p>
<p><img src="https://i.loli.net/2020/10/28/Enzvuswex8IKpDX.png" alt="adapter4.png"></p>
<p>榫卯使得本来不能直接接合的材料能够接合起来了。看到这里让我想到了插在大哥电脑上的扩展坞</p>
<img src="https://i.loli.net/2020/10/28/bxq2FramOUyuzh1.jpg" alt="kuozhanwu" style="zoom:25%;" />

<p>这是华为的扩展坞，整个电脑上就两个外接口，一个充电口，一个这个扩展坞的口。想接 USB 设备必须要经过这个扩展坞才可以。</p>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><blockquote>
<p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p>
</blockquote>
<p>首先大家要知道一个可能一直被大家忽略的一个问题就是，适配器模式一共有两种，一种是类适配器，另一种叫做对象适配器。这两个是什么东西呢。</p>
<p><strong>类适配器：通过类的继承或者接口的实现来达到适配目的；</strong></p>
<p><strong>对象适配器：通过对象的组合来达到适配目的；</strong></p>
<h2 id="适配器模式类图-📌"><a href="#适配器模式类图-📌" class="headerlink" title="适配器模式类图 📌"></a>适配器模式类图 📌</h2><p>再来看看图，消化吸收一下。</p>
<p><img src="https://i.loli.net/2020/10/28/FcmQRrVDGqSCsuz.png" alt="adapter-class.png"></p>
<p>目标接口为应用期望的一个接口格式，源接口为已经存在的一种接口规范格式。</p>
<p>代码不能重写。（工作量，系统稳定性，等等原因。）</p>
<p>这时我们需要引入一个中间类，继承原来的业务逻辑类，也就是源接口，然后实现我们所期望的目标接口，通过中间的类将源接口中的方法，封装到我们自己所期望的目标接口方法中。这种方式就是<strong>类适配器</strong>。</p>
<p><img src="https://i.loli.net/2020/10/28/Vc71iPM6j3BXfvl.png" alt="adapter-object"></p>
<p><strong>对象适配模式</strong>是通过对象的组合来替代类的继承，好处我真的不想再说了，合成复用原则中讲过优先使用对象组合，其次考虑类的继承。</p>
<p>就像上一篇的桥接模式一样，继承虽方便，但扩展性太差。同时耦合度很多，如果真的是使用继承，一定是具备一定强度的耦合条件时才会考虑。</p>
<p>像对象四佩奇这种方式会更加的灵活。一般适配器更多会选为这种方式来进行两个接口的连接。</p>
<h2 id="代码-📃"><a href="#代码-📃" class="headerlink" title="代码 📃"></a>代码 📃</h2><p>学习适配器模式的时候，我没有再去找一些应用的案例来学习，因为我就一直在用这个模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateUtil</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String YYYY_MM_DD = <span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String YYYY_MM_DD_TIGHT = <span class="hljs-string">&quot;yyyyMMdd&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getTightDate</span><span class="hljs-params">(Date date)</span> </span>&#123;<br>        Calendar calendar = <span class="hljs-keyword">new</span> GregorianCalendar();<br>        calendar.setTime(date);<br>        SimpleDateFormat df = <span class="hljs-keyword">new</span> SimpleDateFormat(YYYY_MM_DD_TIGHT, Locale.CHINA);<br>        <span class="hljs-keyword">return</span> df.format(calendar.getTime());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">format</span><span class="hljs-params">(Date date)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (date == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleDateFormat(YYYY_MM_DD, Locale.CHINA).format(date);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个是日期工具类，我们经常会有这种场景，数据库存放的是 Date 类型，但接口给过来的是 String 类型，或者这两者相反，总之需要将其正常存储或返回，这个时候我们通常会采取使用一个日期工具类，将数据格式进行一个转换，这其中，工具类担任的角色，我认为就是适配器的一个职责，”将两个本不能直接结合的材料进行了接合“。这个看起来很简单，但这就是适配的模式的精髓，就是为了解决类似问题而存在的。如果把上面的程序用一个类图来表示的话，就是这个样子。</p>
<p><img src="https://i.loli.net/2020/10/29/ZOHQ6bjR3otV9MP.png" alt="dateUtil-adapter.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 数组工具类</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 欢迎跟我一起学习，公众号搜索：星尘的一个朋友</span><br><span class="hljs-comment"> * 也可以加我微信（lvgocc）拉你进群</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@blog</span> <span class="hljs-doctag">@see</span> http://lvgo.org</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CSDN</span> <span class="hljs-doctag">@see</span> https://blog.csdn.net/sinat_34344123</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/10/29</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArraysUtil</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">asList</span><span class="hljs-params">(T... a)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(a);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">            <span class="hljs-keyword">implements</span> <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><br><span class="hljs-class">    </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">2764017481108945198L</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> E[] a;<br><br>        ArrayList(E[] array) &#123;<br>            a = Objects.requireNonNull(array);<br>        &#125;<br>        .......<br>            ......<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一个数组工具类，大家应该都很熟悉，没错，这就是 JDK 中的 Arrays 工具类中的 asList 方法。记住哦，这种方式创建出来的 List 是不能够使用 add 方法的哦，因为此 ArrayList（java.util.Arrays.ArrayList） 非彼 ArrayList (java.util.ArrayList)，这个 ArrayList 里面没有重写 add 方法，这个知识点是送的，别客气。</p>
<p>在列举一下 JDK 中的适配器大家看一看，随便感受一下就好了。</p>
<p><img src="https://i.loli.net/2020/10/29/iEl5pgUCJtTqYbQ.png" alt="jdk-adapter1.png"></p>
<p><img src="https://i.loli.net/2020/10/29/EPbLzTx47Oljfu8.png" alt="jdk-adapter2.png"></p>
<p><img src="https://i.loli.net/2020/10/29/acZyqYIs7onLUVw.png" alt="jdk-adapter3.png"></p>
<p>哦，这里还有群里小伙伴@ruize 提供的一个他写的适配器，一起和大佬学习一下</p>
<p><img src="https://i.loli.net/2020/10/29/qHFrDaKclkP8MOY.png" alt="ruize-adapter.png"></p>
<h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>适配器模式叫我总结，只有两字。”能用就行“，为什么用这两个字来总结，是因为适配器本身就是一个在出现问题以后用来补救的。像一个补丁一样。一般人不会上来就在系统初期写一些适配器在那里，如果是像上面列的一些对象转换的话合情合理。</p>
<p>适配器模式的出现是为了解决系统一些牵一发而动全身的事情，我们可以想象一下我的电脑没有 USB 接口（华为今年的最新款）难道我要把电脑拆了装个 USB 模组在里面吗？这显然是不可能的。所以有了扩展坞这东西。他就是为了解决这个问题的。（华为电脑这个是设计就没把外接设备接口留着，只留了一个充电的，和一个扩展坞的两个口）</p>
<ol>
<li>首先，适配器模式不会用在系统初期。</li>
<li>其次，他是一个亡羊补牢一样的存在，你永远不知道系统的发展会遇到什么变故。只有出现需要的时候才会使用，不是故意设计的。就像你本来好好的接的 A 厂商接口，系统都开发完上线一年了，A 厂商说啥都不干了，你怎么办，现在有 B 厂商一样功能的接口，但接口规范不一样。这个时候就需要用适配器去补救了。</li>
<li>代码复用，适配器模式可以充分的体现出代码复用。用一个适配类，解决修改老代码的尴尬局面。体现粗了老的代码可以完美的继续使（复）用。否则需要将老代码重构成新接口的规范，如果 B 厂商在换一次，估计开发人员头要炸了。</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>和 lvgo 一起学设计模式（二十一）行为型之中介者模式</title>
    <url>//post/lvgo-design-patterns-mediator.html</url>
    <content><![CDATA[<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><blockquote>
<p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
</blockquote>
<p>与其说中介者模式还不如说是软件设计原则的具体体现。这个原则就是——迪米特法则。</p>
<p><em>这里可以参考之前的系列文章<strong>《和 lvgo 一起学习设计模式 - 序》</strong>中的软件设计基本原则 6 迪米特法则</em></p>
<ul>
<li>6️⃣ 迪米特法则又叫作最少知识原则 LOD/LKP ，1987 年美国东北大学👨‍🎓（Northeastern University）的一个名为迪米特（Demeter）的研究项目，由伊恩·荷兰（Ian Holland）提出，被 UML 创始人之一布奇（Booch）🧙‍♂️普及，后来又在经典著作《程序员修炼之道》📕中提及，从而传播开来。原则定义：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：<u>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用</u>。其目的是降低类之间的耦合度，提高模块的相对独立性。</li>
</ul>
<p>通过这个原则的核心内容我们知道，迪米特法则（中介者模式）要解决的问题就是提高软件程序的聚合度、降低对象之间的耦合。</p>
<h2 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h2><h3 id="王二入职"><a href="#王二入职" class="headerlink" title="王二入职"></a>王二入职</h3><p>前阵子王二刚刚毕业，入职了一家公司，报道的第一天，人事将王二带到部门后介绍了接头人就走了，王二坐在座位上等待人“接待”他，等了20分钟，没人管他，于是他起身去找了当时的部门接头人旺仔。</p>
<p>“仔哥，我~“，”啊，我知道，你新来的“。”我还没电脑“</p>
<p>“没电脑？你去找那个角落里，那是网管，问他们要一台”，”好的“</p>
<p>王二初来乍到，总觉得哪里不对，又不好意思说，就去角落里问：”您好，我是xxx部新来的，需要领台电脑“，”啊，去找你组长申请“。</p>
<p>“仔哥，那面叫我来和组长申请。我组长是谁啊？”，“我啊，我就是你组长，跟我申请”。王二没说话。“把这个表格打出来，填一下，给我和部门经理签字”，“仔哥，去哪里打印？”，“茶水间边上的房间，找打印机管理员”。</p>
<p>王二蹑手捏脚的过去了，到了那里“您好，我想打份申请单。” “什么申请？”，“离职申请。“王二淡定的说。</p>
<p><img src="https://i.loli.net/2020/12/03/6v5UQJkTwA8YqBZ.png" alt="mediator-wanger-ruzhi.png"></p>
<h3 id="王二找房"><a href="#王二找房" class="headerlink" title="王二找房"></a>王二找房</h3><p>王二最终找到了一个让他满意的地方，然后开始找地方住，所以他开始了繁忙的 “找房之旅” ，一开始，王二一口气就找到了三个房东</p>
<p><img src="https://i.loli.net/2020/12/03/SBtYkczJxvgPwIm.png" alt="mediator-wanger-zufang.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">房东一 = <span class="hljs-number">10</span>平米，无窗<br>房东二 = <span class="hljs-number">20</span>平米，半个窗<br>房东三 = <span class="hljs-number">1000</span>平米，<span class="hljs-number">108</span>个窗<br></code></pre></td></tr></table></figure>

<p>找了很多，王二也没找到自己心仪的，而此时的王二已经累了。</p>
<p><img src="https://i.loli.net/2020/12/03/RdHNVnpkZlYjXtf.png" alt="mediator-wanger-zufang2.png"></p>
<p>最后经历了第 10 个房东的时候，王二终于找到自己满意的房子了。</p>
<p><del><strong>通过这件事我们知道了买房的重要性</strong></del></p>
<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><h3 id="王二入职-1"><a href="#王二入职-1" class="headerlink" title="王二入职"></a>王二入职</h3><p>如果你是这家公司的人事，你会怎么来安排一个新同事的到来的各种事情呢，或者说怎么管理公司间同事的交叉问题呢？</p>
<p>如果是我的话，我会制定一个专员负责管理同事间的诉求，比如人事专员、行政专员等等，当然还可以设立其他专员来解决这种类似的问题。</p>
<p>有了专员之后，专员就负责在各种业务流程上起引导督促等作用。比如刚刚王二入职，人事专员需负责跟踪引导其完成入职知道可以开展工作之前的相关事项。于此同时，王二只需要和人事专员进行通信，其中间的流程步骤变得清晰了很多。</p>
<p>王二：“你好，我这里没有电脑”</p>
<p>人事专员：“已经再给你申请了，稍等”</p>
<p>王二：“好的”</p>
<p>过了，20分钟</p>
<p>设备管理员：“电脑登记好了，给你吧”</p>
<p>人事专员：“好的，我给王二送过去，<strong>你也不认识他</strong>”；</p>
<p>人事专员：“王二，这是你的电脑，编号在背面，有什么问题再联系我”</p>
<p>通过专员的加入，解耦了各个同事之间的耦合，同时降低了各个同事间复杂的交互，<del>也避免了不必要的“人才流失”</del></p>
<p><img src="https://i.loli.net/2020/12/03/XYe7vWomLqV3FKs.png" alt="mediator-wanger-ruzhi2.png"></p>
<h3 id="王二找房-1"><a href="#王二找房-1" class="headerlink" title="王二找房"></a>王二找房</h3><p>因为有了输入就会有输出，王二给市场上输入了一种“找房”的需求，市场自然而然的反馈回来一个输出，那就是“房屋中介”</p>
<p>当有了“房屋中介”的加入，王二就没那么辛苦了，并且各个房东的资源因为在“房屋中介”这也会让“租房”变得高效起来。</p>
<p><img src="https://i.loli.net/2020/12/03/NUi32SgBvtb6X4E.png" alt="mediator-wanger-zufang3.png"></p>
<h2 id="中介者模式类图-📌"><a href="#中介者模式类图-📌" class="headerlink" title="中介者模式类图 📌"></a>中介者模式类图 📌</h2><p><img src="https://i.loli.net/2020/12/03/hHZYAVLNRWvd2za.png" alt="mediator-UML.png"></p>
<p>模式结构：</p>
<ol>
<li>中介者接口 Mediator</li>
<li>具体中介者 ConcreteMediator</li>
<li>同事抽象类 Colleague</li>
<li>具体同事 ConcreteColleague</li>
</ol>
<p><em>多学一点：在设计模式中发现几乎所有的模式结构图中，都会有接口或者抽象类，这其实是依赖倒置的默认思路，任何的程序设计这一点原则都要优先考虑。</em></p>
<h2 id="代码-📃"><a href="#代码-📃" class="headerlink" title="代码 📃"></a>代码 📃</h2><blockquote>
<p>篇幅和过长代码展示原因：完整代码关注回复 “ <strong>源码</strong> “ 获取。</p>
</blockquote>
<p>这里通过王二入职案例的解决方案为背景，用程序来表示一下如何解决多个对象间复杂交错导致程序难以维护最终崩溃（离职）的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HRTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;<br>        HR hr = <span class="hljs-keyword">new</span> HR();<br>        DeviceManager deviceManager = <span class="hljs-keyword">new</span> DeviceManager(hr);<br>        hr.addColleague(deviceManager);<br>        WangEr wangEr = <span class="hljs-keyword">new</span> WangEr(hr);<br>        hr.addColleague(wangEr);<br>        WangZai wangZai = <span class="hljs-keyword">new</span> WangZai(hr);<br>        hr.addColleague(wangZai);<br><br>        wangEr.send(<span class="hljs-string">&quot;我没有电脑&quot;</span>);<br>        deviceManager.send(<span class="hljs-string">&quot;设备管理员下发一台电脑&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">设备管理员收到消息：我没有电脑<br>王二收到消息：设备管理员下发一台电脑<br></code></pre></td></tr></table></figure>



<h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p><strong>解决的问题</strong></p>
<ol>
<li>在 1 对多对象关系中，可以通过 <code>中介者模式</code> 来解耦，达成 1 对 1 的松耦合关系。</li>
</ol>
<p><strong>存在的问题</strong></p>
<ol>
<li><code>中介者模式</code> 自身有个隐患问题，就是中介者自己本身知道了太多的内容。稍有不慎，就会导致 <code>同事</code> 的信息出现问题。</li>
<li>由于 <code>中介者模式</code>  本身的原因，这个 <code>中介者</code> 会变得特别复杂。（对象间的复杂转换成成了类复杂，两权相害取其轻的道理。）</li>
<li>在 多对多 的问题上，最好仔细的考虑一下，甚至考虑要不要用这种模式。</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>和 lvgo 一起学设计模式（二十三）行为型之解释器模式</title>
    <url>//post/lvgo-design-patterns-interpreter.html</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>这篇是<strong>《和 lvgo 一起学设计模式》</strong>系列的最后一个设计模式了，这篇就轻松一些吧。</p>
<h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h1><blockquote>
<p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>
</blockquote>
<p>因为时代的发展、技术的更替等等原因（你想做的解释器都有人做好了，且开源）吧，可能这个是我们很长一段时间都用不到的一种设计模式了。</p>
<h2 id="你能看懂TA的“眼色”吗？"><a href="#你能看懂TA的“眼色”吗？" class="headerlink" title="你能看懂TA的“眼色”吗？"></a>你能看懂TA的“眼色”吗？</h2><p>还记得那些年看过的影视剧吗？或是表情包吗？</p>
<p><img src="https://i.loli.net/2020/12/03/dFSRYxU9AEDji4v.jpg" alt="interpreter-1.jpg"></p>
<p><img src="https://i.loli.net/2020/12/03/pazvAJuBRKZhkco.jpg" alt="interpreter-2.jpg"></p>
<p>你能看懂柯镇恶和“老婆”的眼色吗？</p>
<p>反正我是看不懂，单是看这情况，完全看不懂是什么意思。</p>
<p>但如果我提前给你说下规则呢？</p>
<p><strong>柯镇恶图</strong></p>
<ol>
<li>柯镇恶往左摆头，冲！</li>
<li>柯镇恶往右摆头，撤！</li>
</ol>
<p><strong>“老婆”图</strong></p>
<ol>
<li>“老婆”坐在坐垫上，生气！</li>
<li>“老婆”坐在摩的后面架子上，开心！</li>
</ol>
<p>那这个时候再看他们的“眼色”，你能看懂了吗？如果有了上面的定义，我便知道了：</p>
<ul>
<li>柯镇恶的意思是冲！（假设是往左摆头了）</li>
<li>“老婆”很开心！</li>
</ul>
<h2 id="再谈解释器模式"><a href="#再谈解释器模式" class="headerlink" title="再谈解释器模式"></a>再谈解释器模式</h2><p><u>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</u></p>
<p>定义一个语言：“眼色”</p>
<p>定义他的文法表示：“摆头”、“坐的位置”</p>
<p>定义解释器：“规则”</p>
<p>这样我们就可以通过这个解释器来了解TA了。</p>
<p><strong>给定一个”眼色“，定义”摆头“或”坐的位置“，并定义一个规则，这样就可以解释图中的柯镇恶和”老婆“了。</strong></p>
<h2 id="解释器模式类图-📌"><a href="#解释器模式类图-📌" class="headerlink" title="解释器模式类图 📌"></a>解释器模式类图 📌</h2><p><img src="https://i.loli.net/2020/12/03/IrtOF8hdjB3PDnG.png" alt="interpreter-UML.png"></p>
<p>这个结构比较简单，定义一个解释接口，然后就是两个具体的解释器</p>
<ol>
<li>最终解释器</li>
<li>非最终解释器</li>
<li>环境</li>
</ol>
<p>这两个有点像组合模式中的子节点和叶节点的意思。这里的 <code>NonTerminalExpression </code> 是可以有多个的；</p>
<p>这里最麻烦的其实是 <code>Context</code> 环境。</p>
<h2 id="代码-📃"><a href="#代码-📃" class="headerlink" title="代码 📃"></a>代码 📃</h2><p>我们来看看代码来实现上面的”眼色“</p>
<blockquote>
<p>完整代码关注回复“源码”获取。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;<br>    EyeColor eyeColor = <span class="hljs-keyword">null</span>;<br>    Context context = <span class="hljs-keyword">new</span> Context(<span class="hljs-string">&quot;柯镇恶往左摆头 | 老婆坐在了架子上&quot;</span>);<br>    String content = context.getContent();<br>    String[] strings = content.split(<span class="hljs-string">&quot;\\|&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strings.length; i++) &#123;<br>        String string = strings[i];<br>        context.setContent(string);<br>        <span class="hljs-keyword">if</span> (string.contains(<span class="hljs-string">&quot;柯镇恶&quot;</span>)) &#123;<br>            eyeColor = <span class="hljs-keyword">new</span> KeZhenE();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (string.contains(<span class="hljs-string">&quot;老婆&quot;</span>)) &#123;<br>            eyeColor = <span class="hljs-keyword">new</span> Wife();<br>        &#125;<br>        <span class="hljs-keyword">assert</span> eyeColor != <span class="hljs-keyword">null</span>;<br>        eyeColor.interpreter(context);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KeZhenE</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EyeColor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (context.getContent().contains(<span class="hljs-string">&quot;左摆头&quot;</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;冲！&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (context.getContent().contains(<span class="hljs-string">&quot;右摆头&quot;</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;撤！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wife</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EyeColor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (context.getContent().contains(<span class="hljs-string">&quot;座椅&quot;</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;生气！&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (context.getContent().contains(<span class="hljs-string">&quot;架子&quot;</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;开心！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">冲！<br>开心！<br></code></pre></td></tr></table></figure>



<h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>通过上面的内容我们了解到，<strong>解释器可以自己定义一些规则和对应的解释规则</strong>，<strong>来完成一些复杂的事情</strong>，这样就使得可以用一个简单的“动作”来达成一件复杂的事情。你看柯镇恶一个眼色，我就知道他想冲，他省去了复杂的“张嘴”过程。</p>
<p>其实解释器模式就像是我们现在用高级语言来开发软件程序一样，是怎么才能让计算机知道我们在说什么呢？其实这就是解释器的作用，我们按照一定规则（语法）来编写代码，然后解释器按照定义好的规则来将我们的代码翻译成机器认识的 01 代码。</p>
<p>对于解释器，它将复杂的事自己“包揽”了，但是一旦<strong>发生新的规则</strong>，你就<strong>不得不去修改“包揽”的复杂解析过程</strong>。</p>
<p>在今天，解释器模式应该很少会在我们的应用自己去设计了，毕竟这如同设计一门语言一样，过程很复杂，还记得我们正在用的正则表达式吗？他就是一个轻量级的语言，如果有能力有机会的时候，也可以挑战一下，开发一个自己的语言。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>和 lvgo 一起学设计模式（二十二）行为型之访问者模式</title>
    <url>//post/lvgo-design-patterns-visitor.html</url>
    <content><![CDATA[<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><blockquote>
<p>将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。</p>
</blockquote>
<p>刚看到这个模式的时候，我人都傻了，完全不知道说的是啥，直到看了近5份资料！才搞清楚这个设计模式，不愧是最复杂的一种，我也这样觉得。不过千万别被复杂吓到，捋清了之后，还是比较简单的。</p>
<h2 id="开门见山"><a href="#开门见山" class="headerlink" title="开门见山"></a>开门见山</h2><p>访问者模式“人如其名”，就是说不同的访问者对同一个对象的访问结果不同。为什么会不同呢？因为这个访问者是我们自己定义的，我们就想让他不同😂。</p>
<p>而实际情况更是如此。我通过几份资料总结下来，这个访问者模式所谓的访问者其实就是我们想要控制的访问权限一样。因为任何一个“访问者”都可以看到具体数据的全部内容，他只是选择性的”不看“，这样便区分开了”访问者“<strong>关注的内容</strong>，或者<strong>”限制“了”访问者“的权限</strong>。</p>
<p>可能我说的有点绕，有点抱歉，我再简化一下这个内容。</p>
<h2 id="网络用语"><a href="#网络用语" class="headerlink" title="网络用语"></a>网络用语</h2><p><strong>抛开表象看本质</strong></p>
<p>如果我们抛开访问者模式这些专业的定义，单纯的去理解这个访问者模式要表达的意思，我觉得用一个东西最合适不过。那就是“网络用语”；</p>
<p>不知道大家听没听过前阵子火了的百度广告《你说啥》单曲。歌曲中的朝阳大妈就是一个不知道关注点或者是被限制了访问权限的访问者，当然他歌曲中说的网络语有好多我也不知道是啥🙃。没听过的快去听吧。</p>
<p>还有最近的 <code>凡尔赛文学</code> 我不百度的时候以为是个地名，所以我的 <code>权限</code> 也被限制了。</p>
<p>正好提到这个了，那我们就拿 <code>凡尔赛文学</code> 这个网络语来学习一下访问者模式吧~🤩</p>
<h2 id="凡尔赛文学"><a href="#凡尔赛文学" class="headerlink" title="凡尔赛文学"></a>凡尔赛文学</h2><p><strong>首先我们就要再一次抛开表象看本质😂</strong></p>
<p>下面是我搜集到有关凡尔赛的释义：</p>
<ol>
<li>凡尔赛是法国巴黎的卫星城以及伊夫林省省会，曾是法兰西王朝的行政中心。</li>
<li>《凡尔赛》是皮埃尔·苏勒执导的剧情片。</li>
<li>以法国路易十四为时代背景的电视剧。</li>
<li>凡尔赛文学，网络热词，指通过先抑后扬、自问自答或第三人称视角，不经意间露出”贵族生活的线索”。</li>
<li>啥？？？</li>
</ol>
<p>对于凡尔赛一共有 5 种释义，他的结构应该是这样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Versailles</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation1 = <span class="hljs-string">&quot;凡尔赛是法国巴黎的卫星城以及伊夫林省省会，曾是法兰西王朝的行政中心。&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation2 = <span class="hljs-string">&quot;《凡尔赛》是皮埃尔·苏勒执导的剧情片。&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation3 = <span class="hljs-string">&quot;以法国路易十四为时代背景的电视剧。&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation4 = <span class="hljs-string">&quot;凡尔赛文学，网络热词，指通过先抑后扬、自问自答或第三人称视角，不经意间露出\&quot;贵族生活的线索\&quot;。&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation5 = <span class="hljs-string">&quot;啥？？？&quot;</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>因为我们还要对这个数据进行访问，所以还要给他加个访问的方法 #visit</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Versailles</span> </span>&#123;<br><br>   .....<br>       ....<br>       ...<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 访问</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>既然要访问，肯定要有访问者啊，因为访问者挺多的，比如我、我的小伙伴、还有你，所以我们就使用依赖倒置原则来定义一个访问者接口 <code>Visitor</code> 然后有个访问方法，再把凡尔赛给访问者去让其自己访问，那代码实现起来应该是这样的。</p>
<p> <code>Visitor</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Visitor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Versailles versailles)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>凡尔赛的访问方法调整一下，最终完整类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Versailles</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation1 = <span class="hljs-string">&quot;凡尔赛是法国巴黎的卫星城以及伊夫林省省会，曾是法兰西王朝的行政中心。&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation2 = <span class="hljs-string">&quot;《凡尔赛》是皮埃尔·苏勒执导的剧情片。&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation3 = <span class="hljs-string">&quot;以法国路易十四为时代背景的电视剧。&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation4 = <span class="hljs-string">&quot;凡尔赛文学，网络热词，指通过先抑后扬、自问自答或第三人称视角，不经意间露出\&quot;贵族生活的线索\&quot;。&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String interpretation5 = <span class="hljs-string">&quot;啥？？？&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将该对象提供给访问者访问</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> visitor 访问者</span><br><span class="hljs-comment">     * 方法名改成 accept 更好，表示这个类接受一个访问者来访问自己🙅</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span></span>&#123;<br>        visitor.visit(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来就是具体的访问者了，那我根据实际情况来定义一些访问者</p>
<ol>
<li>I</li>
<li>MyFriend</li>
<li>You</li>
</ol>
<p>一共三个访问者</p>
<p><strong>I</strong>（我自己）</p>
<p>我比较博学多识，我知道凡尔赛是地名、电影、电视剧三个</p>
<p><strong>MyFriend</strong>（狗哥）</p>
<p>看他的样子应该是不知道</p>
<p><img src="https://i.loli.net/2020/12/03/fBnOdChGT9mZ2Yj.png" alt="visitor-unkown.png"></p>
<p><strong>You</strong>（你呢？）</p>
<p>我就当你知道凡尔赛文学，已经领悟到了无形装逼的境界好了🌚</p>
<p>看下这三个类的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 我比较博学多识</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 欢迎跟我一起学习，微信（lvgocc）公众号搜索：星尘的一个朋友</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@blog</span> <span class="hljs-doctag">@see</span> http://lvgo.org</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CSDN</span> <span class="hljs-doctag">@see</span> https://blog.csdn.net/sinat_34344123</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">I</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Visitor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Versailles versailles)</span> </span>&#123;<br>        System.out.println(versailles.getInterpretation1());<br>        System.out.println(versailles.getInterpretation2());<br>        System.out.println(versailles.getInterpretation3());<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 弱智狗哥</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFriend</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Visitor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Versailles versailles)</span> </span>&#123;<br>        System.out.println(versailles.getInterpretation5());<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 网络达人</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">You</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Visitor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Versailles versailles)</span> </span>&#123;<br>        System.out.println(versailles.getInterpretation4());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后我们在模拟一下运行起来的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VisitorTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span> </span>&#123;<br>        Versailles versailles = <span class="hljs-keyword">new</span> Versailles();<br><br>        System.out.println(<span class="hljs-string">&quot;lvgo 你知道凡尔赛吗？&quot;</span>);<br>        versailles.accept(<span class="hljs-keyword">new</span> I());<br><br>        System.out.println(<span class="hljs-string">&quot;\n狗哥 你知道凡尔赛吗？&quot;</span>);<br>        versailles.accept(<span class="hljs-keyword">new</span> MyFriend());<br>        <br>        System.out.println(<span class="hljs-string">&quot;\n你知道凡尔赛吗？&quot;</span>);<br>        versailles.accept(<span class="hljs-keyword">new</span> You());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结果，狗哥拉胯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">lvgo 你知道凡尔赛吗？<br>凡尔赛是法国巴黎的卫星城以及伊夫林省省会，曾是法兰西王朝的行政中心。<br>《凡尔赛》是皮埃尔·苏勒执导的剧情片。<br>以法国路易十四为时代背景的电视剧。<br><br>狗哥 你知道凡尔赛吗？<br>啥？？？<br><br>你知道凡尔赛吗？<br>凡尔赛文学，网络热词，指通过先抑后扬、自问自答或第三人称视角，不经意间露出<span class="hljs-string">&quot;贵族生活的线索&quot;</span>。<br></code></pre></td></tr></table></figure>

<p>不同的访问者，看到数据结构中的结果不同。再来看下访问者的定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。<br></code></pre></td></tr></table></figure>

<p>虽然我们这里用的是一个对象，试着将它变成集合（多个网络语而已）吧。使用循环把每个元素都“送”给访问者，这个就留着给你动手试试吧，也留给自己以后回来看的时候能被逼动动脑😂。实在不想动，关注回复 “源码” 吧！😀</p>
<h2 id="访问者模式类图-📌"><a href="#访问者模式类图-📌" class="headerlink" title="访问者模式类图 📌"></a>访问者模式类图 📌</h2><p>最后，我们来看下标准的访问者模式结构图</p>
<p><img src="https://i.loli.net/2020/12/03/mKRj7h6eZVp2gt8.png" alt="visitor-UML.png"></p>
<p>这个结构比较复杂</p>
<ol>
<li>客户端高层模块 <code>Client</code>；</li>
<li>访问者接口，依赖倒置接口 <code>Visitor</code>；</li>
<li>被访问的元素，<code>Element</code>；</li>
<li>最后一个，<code>ObjectStructure</code> 对象结构；</li>
</ol>
<p>这里唯一可能需要解释的就是这个 <code>ObjectStructure</code> 了，他即用于来定义管理 <code>Element</code> 的对象载体。它可以是我们业务场景中任何需要被访问元素的载体对象，比如上述例子中，我们想把这个结构放进去那我就可以定义一个词语类 <code>Word</code> ，里面可以有 <code>NetWordLanguage</code>，<code>Professional vocabulary</code> 等等对象。如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Word</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 网络语</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;NetWordLanguage&gt; netWordLanguages = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addWord</span><span class="hljs-params">(NetWordLanguage netWordLanguage)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!netWordLanguages.contains(netWordLanguage))&#123;<br>            netWordLanguages.add(netWordLanguage);   <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>访问者全部源代码关注回复 “源码” 获取</p>
</blockquote>
<h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>访问者模式适合在<strong>数据结构稳定</strong>的系统中，即很少或不变的数据结构场景；</p>
<p>当你想要对一个数据集合增加一些不同的使用规则，或者是“权限”控制时，可以考虑使用访问者模式，并要一同考虑数据结构是否稳定（是否会在增加类），因为这会导致访问者需要“重构”。</p>
<p><strong>解决的问题：</strong></p>
<ol>
<li>访问者模式使数据结构与数据访问分离</li>
<li>可以很灵活的增加不同的访问规则</li>
</ol>
<p><strong>自身的问题：</strong></p>
<ol>
<li>一旦出现数据结构变更（新增类型），将会使访问者发生较大的修改，因为需要调整访问者接口！严重违反了开闭原则</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>和 lvgo 一起学设计模式（二十）行为型之状态模式</title>
    <url>//post/lvgo-design-patterns-state.html</url>
    <content><![CDATA[<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><blockquote>
<p>允许一个对象在其内部状态发生改变时改变其行为能力。</p>
</blockquote>
<p>我刚开始看到这个模式的时候，没啥感觉，不知道这东西要说的是个啥，后来看了个案例，渐渐清楚了，这个模式本身还是比较简单的。</p>
<h2 id="小菜的工作状态"><a href="#小菜的工作状态" class="headerlink" title="小菜的工作状态"></a>小菜的工作状态</h2><blockquote>
<p>这个案例出自程杰的《大话设计模式》，抽取案例模型，完整案例还请大家自行阅读</p>
</blockquote>
<p>案例说的是主人公“小菜”上班写代码时的各种状态，上午的时候精神饱满，中午时有点萎靡，下午状态一般，晚上状态疲惫。然后这一天各个时段的写代码状态用程序表达出来是这个样子的；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Work</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> clock;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 上午 9 点</span><br>        clock = <span class="hljs-number">9</span>;<br>        writeCode();<br>        <span class="hljs-comment">// 中午 12 点</span><br>        clock = <span class="hljs-number">12</span>;<br>        writeCode();<br>        <span class="hljs-comment">// 下午 15 点</span><br>        clock = <span class="hljs-number">15</span>;<br>        writeCode();<br>        <span class="hljs-comment">// 晚上 21 点</span><br>        clock = <span class="hljs-number">21</span>;<br>        writeCode();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (clock &lt; <span class="hljs-number">12</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;精神抖擞写代码&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clock &lt; <span class="hljs-number">13</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;饿了困了写代码&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clock &lt; <span class="hljs-number">17</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;状态一般写代码&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clock &lt; <span class="hljs-number">23</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;加班疲惫写代码&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一段典型的面向过程编程代码，之后根据面向对象的思想来改了一版变成了这样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OOPWork</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Working working = <span class="hljs-keyword">new</span> Working();<br>        <span class="hljs-comment">// 上午 9 点</span><br>        working.clock = <span class="hljs-number">9</span>;<br>        working.writeCode();<br>        <span class="hljs-comment">// 中午 12 点</span><br>        working.clock = <span class="hljs-number">12</span>;<br>        working.writeCode();<br>        <span class="hljs-comment">// 下午 15 点</span><br>        working.clock = <span class="hljs-number">15</span>;<br>        working.writeCode();<br>        <span class="hljs-comment">// 晚上 21 点</span><br>        working.clock = <span class="hljs-number">21</span>;<br>        working.writeCode();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Working</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> clock;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (clock &lt; <span class="hljs-number">12</span>) &#123;<br>            <span class="hljs-keyword">new</span> MorningState();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clock &lt; <span class="hljs-number">13</span>) &#123;<br>            <span class="hljs-keyword">new</span> NoonState();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clock &lt; <span class="hljs-number">17</span>) &#123;<br>            <span class="hljs-keyword">new</span> AfterNoonState();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clock &lt; <span class="hljs-number">23</span>) &#123;<br>            <span class="hljs-keyword">new</span> EveningState();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MorningState</span> </span>&#123;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;精神抖擞写代码&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoonState</span> </span>&#123;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;饿了困了写代码&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AfterNoonState</span> </span>&#123;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;状态一般写代码&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EveningState</span> </span>&#123;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;加班疲惫写代码&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其实写到这里我相信大家就算没看过这本书也能多少发现一点端倪，就是这个 Working 类是不是有点奇怪。每新增一个状态就要去改这个类，而且这里负责了全部的工作状态，还有最关键的就是这个 <code>if else</code> 是不是有点太长了？？？没错，其实这些都可以用 <code>状态模式</code> 来规避掉，并且这些在软件设计中也都违反了一些原则或建议。</p>
<ol>
<li>每新增一个状态就要去改这个类（违反了 <code>开闭原则</code>）</li>
<li>而且这里负责了全部的工作状态（违反了 <code>单一职责原则</code>）</li>
<li>还有最关键的就是这个 <code>if else</code> 是不是有点太长了？？？（这是 <code>重构</code> 书中提到的 <code>long method</code> 的坏味道）</li>
</ol>
<h2 id="利用状态模式解决这-3-个问题"><a href="#利用状态模式解决这-3-个问题" class="headerlink" title="利用状态模式解决这 3 个问题"></a>利用状态模式解决这 3 个问题</h2><p>首先来看下状态模式的结构类图</p>
<h3 id="状态模式类图-📌"><a href="#状态模式类图-📌" class="headerlink" title="状态模式类图 📌"></a>状态模式类图 📌</h3><p><img src="https://i.loli.net/2020/11/29/YWsdEVzrgFheG3A.png" alt="state-UML"></p>
<p>这里有几个关键的角色</p>
<ol>
<li>运行的上下文环境 <code>Context</code> 对应到程序中就是 <code>Working</code> 类</li>
<li>状态接口 <code>State</code> 这是为了解决单一职责和开闭原则；</li>
<li>具体的状态，也就是 <code>State</code> 接口的实现</li>
</ol>
<h3 id="状态模式代码-📃"><a href="#状态模式代码-📃" class="headerlink" title="状态模式代码 📃"></a>状态模式代码 📃</h3><p>将上面的写法改成用状态模式的话就长这个样子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writeCode</span><span class="hljs-params">()</span> </span>&#123;<br>    Working working = <span class="hljs-keyword">new</span> Working(<span class="hljs-keyword">new</span> MorningState());<br>    <span class="hljs-comment">// 手动模拟不同时刻</span><br>    working.setClock(<span class="hljs-number">9</span>);<br>    working.writeCode();<br><br>    working.setClock(<span class="hljs-number">12</span>);<br>    working.writeCode();<br><br>    working.setClock(<span class="hljs-number">15</span>);<br>    working.writeCode();<br><br>    working.setClock(<span class="hljs-number">21</span>);<br>    working.writeCode();<br><br><br>    working.setClock(<span class="hljs-number">24</span>);<br>    working.writeCode();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Working</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前工作状态</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WorkState concurrentState;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前时刻</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> clock;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Working</span><span class="hljs-params">(WorkState concurrentState)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.concurrentState = concurrentState;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeCode</span><span class="hljs-params">()</span> </span>&#123;<br>        concurrentState.handle(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    ....<br>    ....<br>    <span class="hljs-comment">// 篇幅原因，完整代码关注回复“源码”获取。</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">精神抖擞写代码<br>饿了困了写代码<br>状态一般写代码<br>加班疲惫写代码<br>别再写了，程序员回家了，明早再试吧😢，现在都已经<span class="hljs-number">24</span>点了。放过他吧<br></code></pre></td></tr></table></figure>

<blockquote>
<p>篇幅原因，完整代码关注回复“源码”获取。</p>
</blockquote>
<p>这样不仅消除了 <code>if else</code> 的臃肿 <code>long method</code> 坏味道代码，同时 Working 类更专注 “写代码”，同时有 <code>State</code> 接口的出现，实现了开闭原则，让程序的扩展的到了保障，并且一个关键的内容就是“在不同时刻，调用 writeCode 方法的结果是不同的。这也是状态模式的定义中提到的 <code>一个对象在其内部状态发生改变时改变其行为能力。</code> 改变对象的一个状态，使他的行为也发生了变化，这看起来就像我们对这个类的代码进行了修改一样。</p>
<h2 id="状态模式延伸"><a href="#状态模式延伸" class="headerlink" title="状态模式延伸"></a>状态模式延伸</h2><p>如果大家有做过交易系统的订单的话，有一个东西应该不会陌生，叫做 <code>有限状态机</code> 也叫做 <code>状态机</code>。</p>
<p><img src="https://i.loli.net/2020/11/29/ODt68sjlZchYk3M.png" alt="state-order"></p>
<p>这是正常情况，也就是如果一个订单按照正常步骤来流转是会按照上图所示来进行。但是，真实的订单场景远比这个要复杂的多。</p>
<p>这里我们只看一些简单的几个场景：</p>
<ol>
<li>提交订单之后突然心思转变，不买了，那这个时候给客户就是<code>取消订单</code>和<code>付款</code>两种选择，这一步发生的时候，订单状态为 <code>待付款</code>；</li>
<li>付款之后又看了看发现有更好的店铺选择，此时钱已经付了，所以此时的操作提供给客户的就是 <code>申请退款</code>，此时订单状态为 <code>待发货</code>；</li>
<li>等等订单场景较为复杂，不过万变不离其宗，即 <code>不同的状态，用户的操作行为和这笔订单之后的行为是有限的</code>；</li>
</ol>
<p>用一个图来看下上述几个问题场景</p>
<p><img src="https://i.loli.net/2020/11/29/gbnuih81x7ZYMBr.png" alt="state-exception-order"></p>
<p>我们可以通过图可以看到，即使只有这简单的两种情况，整个订单的处理逻辑就已经开始变得复杂了起来，如果利用传统的面向过程编程或简单的面向对象编程思路来设计这个订单流程逻辑，我想，第一版，也就是正常的订单流程开发实现起来问题应该“不大”，无非代码啰嗦一点、判断逻辑多一点。</p>
<p>不过一旦产品经理提出在付款时可以进行撤单操作、在发货时可以进行退款、发货前可以修改接收地址又或者收货时可以拒收等等这些需求时，我觉得这个业务应该不会有人愿意去开发了。</p>
<p>不是开发人员不愿意做这个业务，而是不愿意在糟糕的代码上进行再次迭代（当然在现实情况，一个糟糕的团队确有可能继续在糟糕的代码上继续迭代，原因很简单，因为他们从一开始便能设计出来，领导能通过就说明这是一个没有技术沉淀的团队，他们很愿意将一坨坨代码“至死不渝”的一直维护下去）。</p>
<p>如果订单状态利用 <code>状态模式</code> 来设计，无论状态如何变化，高层模块也永远不需要关心，这也是开闭与单一职责这两个原则的很好体现。在哪个状态能做哪些事情，完全有对应的状态说了算，即使在复杂的业务，也会因为状态的区分而是业务颗粒变得很小（如果传统的 <code>if else</code> 到底，整个业务流程必须全部重新测试一遍，这不是谁说的，这是由高耦合紧密设计决定的，逃不开），这一点在开发和测试上，都会大幅提高开发和测试效率和节省成本。</p>
<p>好了，关于这一块内容确实大家可以看看 <code>有限状态机</code> ，订单业务在实际情况是交由 <code>状态机</code> 来管理的。</p>
<h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>当你的应用程序可能会存在多种状态，而且每种状态的行为会随着状态的改变而改变，这时你可以考虑使用状态模式。通过状态模式不光可以使应用程序可以和应用状态可以很好的解耦，同时在状态的管理和扩展上都是非常的有帮助。</p>
<p>状态模式关键的几个点：</p>
<ol>
<li>应用环境的上下文，这个是用来作为状态模式的入口，他负责来调用当前状态的执行方法。</li>
<li>状态接口，这个接口负责管理全部的状态，这里在使用的时候需要好好设计，可以将整个业务所有的状态方法全部维护好，在具体接口类中间放一个抽象状态类，如果当前状态不能操作这个方法可以放在一个抽象类中来实现一个空方法，而不是子类去实现全部的接口方法。</li>
</ol>
<p>设计模式是一把双刃剑，在合理的时机使用可以达到很好的应用效果，反之亦然。大家要谨慎对待。不要变成手里只有一把锤子的人。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>和 lvgo 一起学设计模式（二）创建型之工厂模式</title>
    <url>//post/lvgo-design-patterns-factory.html</url>
    <content><![CDATA[<h1 id="工厂模式-🏗"><a href="#工厂模式-🏗" class="headerlink" title="工厂模式 🏗"></a>工厂模式 🏗</h1><blockquote>
<p>定义一个用于创建产品的接口，由子类决定生产什么产品。</p>
</blockquote>
<p>大家可能都知道工厂模式，可真正理解应用的又有多少呢？此文本着能让大家彻底了解和何时适合使用工厂模式的原则来书写，希望能对你有所帮助，点个关注，一起开启新的思维来学习设计模式。</p>
<h2 id="概念-👀"><a href="#概念-👀" class="headerlink" title="概念 👀"></a>概念 👀</h2><p>　　首先我们要知道的是，工厂模式是**<u>创建型</u><strong>设计模式分类下的一种，用来创建对象时选择使用。而还有一种看似功能一样，但实际的实现却大相径庭的方式叫做 <em>简单工厂模式或（静态工厂模式）</em>。要注意这两者区别。即使他们完成的工作都是 <u>**创建对象</strong></u></p>
<ul>
<li>简单工厂模式（静态工厂模式）：通过一个工厂类完成所有对象的创建工作；</li>
<li>工厂方法模式：如引用说明 <strong>定义一个用于创建产品的接口，由子类决定生产什么产品</strong>；</li>
</ul>
<h2 id="简单工厂模式-😉"><a href="#简单工厂模式-😉" class="headerlink" title="简单工厂模式 😉"></a>简单工厂模式 😉</h2><p>　　让我们先来看一下简单工厂模式，这个模式‘人如其名’，非常简单。</p>
<h3 id="类图-🖌"><a href="#类图-🖌" class="headerlink" title="类图 🖌"></a>类图 🖌</h3><p><img src="https://i.loli.net/2020/10/13/RbNwGdVjuQAnkY9.png" alt="通过 idea UML 工具构建"></p>
<h3 id="具体代码-📄"><a href="#具体代码-📄" class="headerlink" title="具体代码 📄"></a>具体代码 📄</h3><blockquote>
<p>完整代码及单元测试结果 <a href="https://github.com/lvgocc/java-design-patterns/tree/main/factory">https://github.com/lvgocc/java-design-patterns/tree/main/factory</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 抽象图形类</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/10/8 21:33</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractGraphical</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getClass().getSimpleName();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 圆形</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/10/8 21:55</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circular</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractGraphical</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 矩形</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/10/8 22:10</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractGraphical</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 三角形</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/10/8 22:10</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractGraphical</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 图形工厂</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/10/8 22:05</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphicalFactory</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CIRCULAR = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RECTANGLE = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TRIANGLE = <span class="hljs-number">2</span>;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AbstractGraphical <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type)</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span> (type) &#123;<br>            <span class="hljs-keyword">case</span> CIRCULAR:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Circular();<br>            <span class="hljs-keyword">case</span> RECTANGLE:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Rectangle();<br>            <span class="hljs-keyword">case</span> TRIANGLE:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Triangle();<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;please check param， range 0 - 2&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="使用时机"><a href="#使用时机" class="headerlink" title="使用时机"></a>使用时机</h3><p>　　当我们所要创建的<u>对象个数较少</u>，<u>创建过程较复杂</u>，<u>使用较频繁</u> 可以通过简单工厂模式将创建对象的过程封装起来，这样可以提高代码可读性，业务代码更专注于业务本身（当然案例代码中没有模拟构建复杂对象的情景）同时为了便于使用，将方法定义为静态。故也称之为静态工厂模式。</p>
<p>　　❗这里在强调一下，同时解释一下使用时机</p>
<ol>
<li>对象个数少：指的是需要通过这种方式创建的对象个数，通常为不变个数。因为如果对象个数迭代频繁，个数较多，在这种方法的维护上会出现一个很大的问题，即每新增加一个 class （一种图形，比如在增加一个正方形）就要调整一次 GraphicalFactory 类的代码。同样，即违反了开闭原则。</li>
<li>创建过程较复杂：通过反向推理可知，如果创建对象过程不复杂，我选择直接 new。</li>
<li>使用较频繁：同上可得，如果使用不频繁，我选择直接 new。不会考虑相对较复杂的设计模式。</li>
</ol>
<h2 id="工厂方法模式-😊"><a href="#工厂方法模式-😊" class="headerlink" title="工厂方法模式 😊"></a>工厂方法模式 😊</h2><p>　　当我们将上面的简单工厂模式中的创建图形的方法抽象出来，将创建的过程延迟到子类中。满足了开闭原则的时候，那这就是工厂方法模式了。</p>
<p>　　<strong>工厂方法模式怎么理解呢，顾名思义，通过工厂的方法来创建对象，每个对象都由一个工厂来创建，怎么创建这个工厂说了算</strong>。理解工厂方法模式对后面的抽象工厂理解可以说是“很精彩”</p>
<h3 id="类图-🖌-1"><a href="#类图-🖌-1" class="headerlink" title="类图 🖌"></a>类图 🖌</h3><p><strong>工厂方法模式</strong>的类图</p>
<p><img src="https://i.loli.net/2020/10/13/jdoIiGvwtP2JCFY.png"></p>
<p><strong>简单工厂模式</strong>的类图</p>
<p><img src="https://i.loli.net/2020/10/13/RbNwGdVjuQAnkY9.png" alt="通过 idea UML 工具构建"></p>
<p>通过类图的比较我们发现。简单工厂的工厂类抽象成了一个抽象工厂，而工厂方法模式中多了3个工厂。这就是工厂模式的定义诠释 </p>
<blockquote>
<p><strong>定义一个用于创建产品的接口，由子类决定生产什么产品</strong></p>
</blockquote>
<h3 id="具体代码-📄-1"><a href="#具体代码-📄-1" class="headerlink" title="具体代码 📄"></a>具体代码 📄</h3><blockquote>
<p>避免篇幅过长，完整代码及单元测试结果点击查看 <a href="https://github.com/lvgocc/java-design-patterns/tree/main/factory">https://github.com/lvgocc/java-design-patterns/tree/main/factory</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 图形类接口</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/10/8 21:33</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Graphical</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 图形描述</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">description</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 圆形</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/10/8 21:55</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circular</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Graphical</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">description</span><span class="hljs-params">()</span> </span>&#123;<br>        LOGGER.info(<span class="hljs-string">&quot;circular&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 抽象工厂</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/10/8 23:16</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractGraphicalFactory</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建一个图形</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 具体图形</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Graphical <span class="hljs-title">creat</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 圆形工厂</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/10/8 23:27</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircularFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractGraphicalFactory</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将创建复杂的圆形过程封装到工厂里。</span><br><span class="hljs-comment">     * 1. 选定圆形位置；</span><br><span class="hljs-comment">     * 2. 指定圆形半径；</span><br><span class="hljs-comment">     * 3. 设置绘制图形所用的画笔；</span><br><span class="hljs-comment">     * 4. 选择图形的颜色；</span><br><span class="hljs-comment">     * 5. 。。。。。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 一个复杂的圆形</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Graphical <span class="hljs-title">creat</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Circular();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="使用时机-1"><a href="#使用时机-1" class="headerlink" title="使用时机"></a>使用时机</h3><p>　　其实这里我们通过与上面的简单工厂模式比较就可以看出，工厂方法模式适合在<u><strong>对象可能存在新增的情况，而且数量不定。创建对象过程复杂，使用频繁</strong></u>的场景。</p>
<h3 id="JDK中的工厂设计模式示例"><a href="#JDK中的工厂设计模式示例" class="headerlink" title="JDK中的工厂设计模式示例"></a>JDK中的工厂设计模式示例</h3><blockquote>
<p>案例来源：<a href="https://www.journaldev.com/1392/factory-design-pattern-in-java">https://www.journaldev.com/1392/factory-design-pattern-in-java</a></p>
</blockquote>
<ol>
<li>java.util.Calendar，ResourceBundle和NumberFormat<code>getInstance()</code>方法使用Factory模式。</li>
<li><code>valueOf()</code> 包装器类（例如Boolean，Integer等）中的方法。</li>
</ol>
<h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>　　当我们所要创建的<u>对象个数较少且不会在新增</u>，<u>创建过程较复杂</u>，<u>使用较频繁</u> 可以通过简单工厂模式将创建对象。如不满足以上 3 种情况，建议直接 new。</p>
<p>　　<strong>当我们所需要创建的对象使用频繁，创建过程较复杂，可能增加对象个数时，这无疑选择使用工厂方法模式。</strong></p>
<p>当我们试图用上面的3个原则去选择使用工厂模式的时候应该要思考几个问题。如</p>
<ol>
<li><p>对象个数很少，创建不复杂。（new 关键字）</p>
</li>
<li><p>创建过程虽然复杂，但是很少使用。（建造者模式）</p>
</li>
<li><p>使用虽然很频繁，但只有1个对象就满足了需要。（单例模式）</p>
</li>
</ol>
<p>等等诸如以上对象与使用使机的权衡都需要我们自己去仔细的设计和衡量，设计模式只提供了一种思想，你可以将一些思想整合使用，也可以使用一个方法来解决你的所有问题。</p>
<p>以上的几个问题，分别可以考虑单例模式和后面要讲到的建造者模式来实现，并不一定非要用工厂模式，活学活用才是我们的宗旨。</p>
<blockquote>
<p><em>千万不要搞骚操作，为了用设计模式而用，否则岂不是 new 个 String 对象也要工厂来创建？😢</em></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>和 lvgo 一起学设计模式（五）创建型之建造者模式</title>
    <url>//post/lvgo-design-patterns-build.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/10/17/8NsSJTuzyraGeOV.png" alt="build"></p>
<h1 id="建造者模式-🔨"><a href="#建造者模式-🔨" class="headerlink" title="建造者模式 🔨"></a>建造者模式 🔨</h1><blockquote>
<p>指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示</p>
</blockquote>
<p>根据建造者模式的定义，我们可以先简单的了解一下建造者模式要解决的问题，它是指将一个复杂对象的构建与它的表示分离，这句话的意思是指一个对象的构建过程与表示不再绝对。即一个构建过程对应多个结果，这取决于客户端如果指挥构建者进行对象的构建。这里的构建者就是我们接下来要讲的建造者模式内容。</p>
<h2 id="理解程序中的建造-🗯"><a href="#理解程序中的建造-🗯" class="headerlink" title="理解程序中的建造 🗯"></a>理解程序中的建造 🗯</h2><p>对于建造这个词语没什么好说的，在软件程序中建造是什么呢？我相信看到下面这个例子你应该就已经掌握了什么是建造者模式，当然这还不够，让我们慢慢来。</p>
<h3 id="JDK-中的-StringBuilder"><a href="#JDK-中的-StringBuilder" class="headerlink" title="JDK 中的 StringBuilder"></a>JDK 中的 StringBuilder</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringBuilderTest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>        stringBuilder.append(<span class="hljs-number">1</span>).append(<span class="hljs-string">&quot;个张三，和&quot;</span>).append(<span class="hljs-number">4</span>).append(<span class="hljs-string">&quot;个李四&quot;</span>);<br>        System.out.println(stringBuilder.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">1个张三，和4个李四<br>Process finished with exit code 0<br></code></pre></td></tr></table></figure>

<p>上面的例子是妇孺皆知的 JDK 中提供的一个为了解决复杂 String 对象的 String 对象生成器。它还有个孪生姐夫<code>StringBuffer</code>用在并发环境下。</p>
<h3 id="Netty-中的-ServerBootstrap"><a href="#Netty-中的-ServerBootstrap" class="headerlink" title="Netty 中的 ServerBootstrap"></a>Netty 中的 ServerBootstrap</h3><p>再比如这个，netty 的启动器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>bootstrap.group(parentGroup, childGroup)<br>        .channel(NioServerSocketChannel.class)<br>        .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>        .childHandler(<span class="hljs-keyword">new</span> NettyProtobufChannelInitializer());<br><br><span class="hljs-keyword">try</span> &#123;<br>    ChannelFuture sync = bootstrap.bind(<span class="hljs-number">2333</span>).sync();<br>    sync.channel().closeFuture().sync();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过建造者 <code>ServerBootstrap</code> 来完成一个启动器的构建，同一个构造过程，却有着千差万别的结果。</p>
<h3 id="lvgo-的-Slient-并发任务处理器"><a href="#lvgo-的-Slient-并发任务处理器" class="headerlink" title="lvgo 的 Slient 并发任务处理器"></a>lvgo 的 Slient 并发任务处理器</h3><p>如果建造者被我们自己应用的话，我个人将它使用到了程序插拔配置上了，就像 netty 的启动器一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> TaskHandler&lt;String&gt;(testData) &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000L</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        log.info(<span class="hljs-string">&quot;第&quot;</span> + s + <span class="hljs-string">&quot;个任务&quot;</span> + Thread.currentThread());<br>    &#125;<br>&#125;.sync(<span class="hljs-keyword">false</span>).overRun(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;我所有的任务执行结束了&quot;</span>);<br>&#125;).execute(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>

<p>上面我写的这个组件已发布到 maven 仓库，源码仓库：<a href="https://github.com/lvgocc/silent">https://github.com/lvgocc/silent</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.lvgo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>silent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>通过上面的几个例子我们大概知道什么是建造者模式了，它可以通过同一个构造过程来创建出不同的表示对象，比如</p>
<ul>
<li>StringBuilder 通过不同的参数传入 append 方法，得到结果是不一样的；</li>
<li>ServerBootstrap 的不同参数设置，启动出来的 netty 服务端有着不同作用；</li>
<li>TaskHandler 通过指定不同的参数，可以使任务的执行效果产生不同的变化；</li>
</ul>
<h2 id="建造者模式类图-📌"><a href="#建造者模式类图-📌" class="headerlink" title="建造者模式类图 📌"></a>建造者模式类图 📌</h2><blockquote>
<p>注：在 GOF 的原著中对建造模式的理解与本篇差别较大。所以类图看起来会和很多资料中有所差异，望读者知悉。</p>
</blockquote>
<p><img src="https://i.loli.net/2020/10/17/Aqzo6p4f1FPlasD.png" alt="build-UML"></p>
<p>GOF 中定义的建造者类图</p>
<p><img src="https://i.loli.net/2020/10/17/jVEaygYQd7rOscR.png" alt="gof-build-UML"></p>
<p>这里说明一下，GOF 的建造者模式中体现的是将要构建的对象、构建者、具体构建者、指挥者4部分独立开来，可以做很好的水平扩展。而 lvgo 将建造者的抽象类与具体的构建者合成一个，通过参数的方式将具体的构建者体现出来。将指挥者的角色延迟到了客户端，直接由客户端 client 来代替 Director 的工作。</p>
<h2 id="代码-📄"><a href="#代码-📄" class="headerlink" title="代码 📄"></a>代码 📄</h2><blockquote>
<p>避免篇幅过长，完整代码及单元测试结果点击查看 <a href="https://github.com/lvgocc/java-design-patterns/tree/main/build">https://github.com/lvgocc/java-design-patterns/tree/main/build</a></p>
</blockquote>
<p>为了能够更好的去理解 lvgo 与 GOF 中类图的差异，这里准备了两种写法，以诠释上面的说明。</p>
<p><strong>GOF 类图的实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> PlayerRole playerRole = <span class="hljs-keyword">new</span> PlayerRole();<br><br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHairColor</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setShape</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSkinColour</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">PlayerRole <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> playerRole;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Director</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Builder builder;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Director</span><span class="hljs-params">(Builder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.builder = builder;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PlayerRole <span class="hljs-title">construct</span><span class="hljs-params">()</span> </span>&#123;<br>        builder.setHairColor();<br>        builder.setShape();<br>        builder.setSkinColour();<br>        <span class="hljs-keyword">return</span> builder.build();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PlayerRole <span class="hljs-title">construct2</span><span class="hljs-params">()</span> </span>&#123;<br>        builder.setHairColor();<br>        <span class="hljs-keyword">return</span> builder.build();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PlayerRole <span class="hljs-title">construct3</span><span class="hljs-params">()</span> </span>&#123;<br>        builder.setSkinColour();<br>        <span class="hljs-keyword">return</span> builder.build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlayerRoleBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Builder</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setHairColor</span><span class="hljs-params">()</span> </span>&#123;<br>        playerRole.setHairColor(<span class="hljs-string">&quot;褐色&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setShape</span><span class="hljs-params">()</span> </span>&#123;<br>        playerRole.setShape(<span class="hljs-string">&quot;健硕&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setSkinColour</span><span class="hljs-params">()</span> </span>&#123;<br>        playerRole.setSkinColour(<span class="hljs-string">&quot;古铜色&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlayerRole</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String hairColor;<br>    <span class="hljs-keyword">private</span> String shape;<br>    <span class="hljs-keyword">private</span> String skinColour;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>    Builder playerRoleBuilder = <span class="hljs-keyword">new</span> PlayerRoleBuilder();<br>    Director playerRoleBuildDirector = <span class="hljs-keyword">new</span> Director(playerRoleBuilder);<br>    PlayerRole construct = playerRoleBuildDirector.construct();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">construct = PlayerRole&#123;hairColor=<span class="hljs-string">&#x27;褐色&#x27;</span>, shape=<span class="hljs-string">&#x27;健硕&#x27;</span>, skinColour=<span class="hljs-string">&#x27;古铜色&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>

<p>个人觉得这种写法稍为复杂，不过他的水平扩展性和隔离性都比较好。</p>
<p><strong>lvgo 整理的写法如下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlayerRole</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String hairColor;<br>    <span class="hljs-keyword">private</span> String shape;<br>    <span class="hljs-keyword">private</span> String skinColour;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlayerRoleBuilder</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PlayerRole playerRole = <span class="hljs-keyword">new</span> PlayerRole();<br><br>    <span class="hljs-function">PlayerRoleBuilder <span class="hljs-title">hairColor</span><span class="hljs-params">(String color)</span> </span>&#123;<br>        playerRole.setHairColor(color);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function">PlayerRoleBuilder <span class="hljs-title">shape</span><span class="hljs-params">(String shape)</span> </span>&#123;<br>        playerRole.setShape(shape);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function">PlayerRoleBuilder <span class="hljs-title">skinColour</span><span class="hljs-params">(String skinColour)</span> </span>&#123;<br>        playerRole.setSkinColour(skinColour);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function">PlayerRole <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> playerRole;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    PlayerRoleBuilder playerRoleBuilder = <span class="hljs-keyword">new</span> PlayerRoleBuilder();<br>    playerRoleBuilder.hairColor(<span class="hljs-string">&quot;红色&quot;</span>).shape(<span class="hljs-string">&quot;健硕&quot;</span>).skinColour(<span class="hljs-string">&quot;古铜色&quot;</span>);<br>    PlayerRole build = playerRoleBuilder.build();<br>    System.out.println(<span class="hljs-string">&quot;build = &quot;</span> + build);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">build = PlayerRole&#123;hairColor=<span class="hljs-string">&#x27;红色&#x27;</span>, shape=<span class="hljs-string">&#x27;健硕&#x27;</span>, skinColour=<span class="hljs-string">&#x27;古铜色&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="总结-🐱‍💻"><a href="#总结-🐱‍💻" class="headerlink" title="总结 🐱‍💻"></a>总结 🐱‍💻</h2><p><strong>相同的资源，不同的结果</strong>是我对建造者模式创建对象的理解。就像建造我们的人生，提供了相同的世界，相同的空气，每个个体的表现均不同。</p>
<p>通过使用建造者模式，我们可以更加灵活的去处理一个构建过程复杂的对象。将它的构建过程与表示分离开。例如如果你正在为<strong>一长串的 set 方法</strong>苦恼的时候可以考虑一下建造者模式。它使代码更整洁，可读性更好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">xxx.setA();<br>xxx.setB();<br>xxx.setC();<br>xxx.setD();<br>xxx.setE();<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">xxx.A().B().C().D().E().build();<br></code></pre></td></tr></table></figure>
<p>当你想要给一个对象组装一个特有的结果的时候，不妨试试 GOF 的思路，很不错的。</p>
<p><strong>缺点：</strong></p>
<p>建造者模式因为需要维护一个单独的建造者类，同时要为每个属性单独维护一个方法，当类中有属性调整的时候，要一起调整对应建造者中的方法，这也是随它的优势而带来的一些副作用。<strong>但如果有需要它的地方尽管去用。没有什么比混沌的代码更糟糕的事情了。</strong></p>
<h2 id="案例应用"><a href="#案例应用" class="headerlink" title="案例应用"></a>案例应用</h2><p>这里为了应读者要求，想有对应的案例可以参考，不然不清楚设计模式到底在什么地方用。</p>
<ol>
<li>餐饮系统有23道素材、18道荤菜，老板今天推出 8 种 2素 1 荤套餐，你如何实现？</li>
<li>试想一下在我的世界（mc）中，提供了各种不同的道具，相同的道具组合，你做出来的房子和我做出来的房子看起来不那么一样。</li>
<li>在塔防类游戏中，同一个射手，每次攒钱给他升级，最终有的变成了单体攻击高的神射手，有的变成散射群里攻击低的散箭手。</li>
</ol>
<h2 id="返璞归真"><a href="#返璞归真" class="headerlink" title="返璞归真"></a>返璞归真</h2><p>我认为学习设计模式的过程就像拿到一台游戏机，玩到最后，我都会拆开看看里面是什么，而早已不关心游戏好不好玩了。</p>
<p>知识也是一样，知其然而知其所以然。</p>
<p><strong>我们为了学会使用某种东西看他的操作手册就可以了；</strong></p>
<p><strong>我们如果想要学会修某种东西就需要看他的设计手册；</strong></p>
<p><strong>当我们想要创造某种东西，你就需要掌握很多很多设计手册，将他们的经验进行吸收、消化、提炼。才能有更好的结果。</strong></p>
<p><em>当然，如果你只想会用，有一份差不多的操作指南也就够了。</em></p>
<p>抱歉这一篇说了一些题外话。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>和 lvgo 一起学设计模式（八）结构型之桥接模式</title>
    <url>//post/lvgo-design-patterns-bridge.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/10/29/YIpkj5QDBHb7ytN.png" alt="timg"></p>
<h1 id="科普闲聊"><a href="#科普闲聊" class="headerlink" title="科普闲聊"></a>科普闲聊</h1><blockquote>
<p>复杂度守恒定律由Larry Tesler于1984年提出，也称泰斯勒定律（Tesler’s Law）。复杂度守恒定律（Law of conservation of complexity）由Larry Tesler于1984年提出，也称泰斯勒定律（Tesler’s Law）。<br>根据复杂度守恒定律，每个应用程序都具有其内在的、无法简化的复杂度。无论在产品开发环节还是在用户与产品的交互环节，这一固有的复杂度都无法依照我们的意愿去除，只能设法调整、平衡。</p>
</blockquote>
<p>这一观点主要被应用在交互设计领域。我们不得不面对的问题是，该由谁来为这一固有的复杂度埋单。打个比方，应该由软件开发工程师花费额外的时间来使软件变得更加简单好用，还是应该让用户自己去解决软件使用中可能存在的问题？</p>
<p>以上出自百度百科：<a href="https://baike.baidu.com/item/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AE%88%E6%81%92%E5%AE%9A%E5%BE%8B/7508660?fr=aladdin">复杂度守恒定律 - 百度百科</a></p>
<hr>
<p>如上所述，复杂度守恒定律是一个规避不掉的东西，最早的时候我接触到这个词是发出的一个提问，当时有各种大佬出来解答，大家感兴趣可以去看看。</p>
<p> <a href="https://bbs.csdn.net/topics/392308895">到底什么是RPC?远程调用有什么好处?</a></p>
<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">迷惑不解,不知是何.<br>我了解了一下dubbo框架,很多的术语搞得是更加模糊不清.<br>顺便提一点,<br>为什么深奥的东西就是被人向往的?<br>将复杂的东西弄成粗浅易懂的这不是更好吗?<br><br>2018-01-15 09:04:03<br></code></pre></td></tr></table></figure>

<p>但我一直以为，技术的东西，本就不复杂。让它变得复杂的是我那迫切想要得到结果的心。</p>
<p>学习从来都没有捷径，你只是想要速成。学的快慢是一个问题，学与不学是另一个问题，听懂掌声。</p>
<hr>
<h1 id="学习时间"><a href="#学习时间" class="headerlink" title="学习时间"></a>学习时间</h1><h2 id="2020年10月的某一天午饭后"><a href="#2020年10月的某一天午饭后" class="headerlink" title="2020年10月的某一天午饭后"></a>2020年10月的某一天午饭后</h2><p>“桥接模式？，那是个啥” 心中突然蹦出这么一个想法。我心血来潮，打开 Google ，输入 <code>桥接模式</code> ，回车走你，等了半天。</p>
<p><img src="https://i.loli.net/2020/10/26/dJ7BuUjW9RcpQiE.png" alt="google-error.png"></p>
<p>这丝毫没有影响到我的情绪<del>（艹）</del>，随即我快速的切换搜索引擎视图忘掉刚刚发生的这一切。又是一记回车敲出，这次，它出现了</p>
<p><img src="https://i.loli.net/2020/10/26/uZGN4z3ckbvI72T.png" alt="baidu-bridge.png"></p>
<p>不知道是我手不行了，还是键盘要坏了，总之模式两字没带上，出来个桥梁，想着都差不多（呸，差不多个鬼）就看看吧，顺便学习了一下桥梁的专业释义（我就是这样东西越看越多，越看越杂的！龇牙咧嘴中！）。</p>
<p>不行，得回过神来，继续找<code>桥梁模式</code>去。这怎么都一样啊，<strong>抽象化</strong>、<strong>实现化</strong>、<strong>脱耦</strong>看不懂啊，然后就是那个到处都是，其实出自菜鸟教程的图形案例。</p>
<p><img src="https://i.loli.net/2020/10/26/vcIRdKGbMN4teTD.png" alt="runoob-bridge.png"></p>
<blockquote>
<p>图片来源：<a href="https://www.runoob.com/w3cnote/bridge-pattern2.html">https://www.runoob.com/w3cnote/bridge-pattern2.html</a></p>
</blockquote>
<p>先看看问题吧，一个图形有2种形状（圆形、矩形）和2种颜色（红色、蓝色）的时候怎么去用类表示，我啥也不说，那肯定继承啊，我这 <strong>封装、继承、多态老扎实了</strong>。</p>
<p>心里念着”首先有一个<strong>图形</strong>的基类，然后开始继承走起 <strong>红色的圆形</strong>、 <strong>红色的矩形</strong>、 <strong>蓝色的圆形</strong>、<strong>蓝色的矩形</strong>。“ 没毛病，一个抽象类，四个实现类，搞定。</p>
<p><img src="https://i.loli.net/2020/10/28/qcKwM42eOFBg6Vu.png" alt="bridge.png"></p>
<p>代码写完，测一手。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shape</span><span class="hljs-params">()</span></span>&#123;<br>    Shape blueCircle = <span class="hljs-keyword">new</span> BlueCircle();<br>    Shape blueRectangle = <span class="hljs-keyword">new</span> BlueRectangle();<br>    Shape redCircle = <span class="hljs-keyword">new</span> RedCircle();<br>    Shape redRectangle = <span class="hljs-keyword">new</span> RedRectangle();<br><br>    blueCircle.create();<br>    blueRectangle.create();<br>    redCircle.create();<br>    redRectangle.create();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs reStructuredText">蓝色の圆形<br>蓝色の长方形<br>红色の圆形<br>红色の长方形<br></code></pre></td></tr></table></figure>

<p>感觉还可以，这时坐在我边上的大哥说了句，如果再加一种形状呢？</p>
<p>我：“卧槽，你啥时候来的，想要偷窥我学习？”</p>
<p>大哥：“先回答问题，别转移话题” </p>
<p>我：“再加两个类不就行了”， <strong>RedTriangle</strong>、<strong>BlueTriangle</strong>，</p>
<p>大哥：“也还行，如果再这基础上再加一种绿颜色呢？” </p>
<p>我：“额。。。再加三个类 <strong>GreenCircle</strong>、 <strong>GreenRectangle</strong>、<strong>GreenTriangle</strong>。。。（开始声音微弱）”</p>
<p>大哥：“再加一个椭圆呢” </p>
<p>“emm… 我刀呢！”</p>
<p>“老弟别激动，大哥帮你看看”</p>
<h2 id="大哥帮忙诊断代码"><a href="#大哥帮忙诊断代码" class="headerlink" title="大哥帮忙诊断代码"></a>大哥帮忙诊断代码</h2><p>大哥：“你这个是 <strong>乱用继承</strong> 导致的类爆炸晚期啊，要是不拔除对这种继承的理解，基本是废了啊”</p>
<p>我：“大哥我还不想放弃，救救我，咳…咳（一口老血咳出）”</p>
<p>大哥：“那你说说看，你都是什么时候用的继承？”</p>
<p>我：“多个类有共同特征的时候，会抽象出来特征，然后使用继承来扩展”</p>
<p>大哥：“嗯，看来你还有救，那你看你现在抽象出来的东西对吗？”</p>
<p>我小声嘀咕：“很多图形，抽象出来个图形，没问题啊”</p>
<p>大哥：“那颜色呢？颜色和图形是什么关系？”</p>
<p>我：“emm….，什么什么关系啊？大哥，给点提示吧”</p>
<p>大哥：“UML中的聚合组合我没教你么？”</p>
<p>我：“这个真没有”</p>
<p>大哥：“那这个地方我再教你一次，记着点奥。咳咳！”</p>
<p><img src="https://i.loli.net/2020/10/27/RQfH3ho9Zg7TJmG.png" alt="uml"></p>
<p>大哥：“这个就是组合和聚合的意思，同时他们与主体之间的关联关系的表达。”</p>
<p>大哥：“现在在看你的 <strong>类爆炸</strong> 知道怎么医治了么？”</p>
<p>我：“我应该把颜色也抽象出来，然后使用聚合与图形进行关联！对不对！”</p>
<p>大哥：“还不赖嘛，你继续看吧，我忙我的去了”</p>
<h2 id="重构代码"><a href="#重构代码" class="headerlink" title="重构代码"></a>重构代码</h2><p>领悟了大哥的意思之后，我对代码进行了重构。</p>
<p>仍然将图形类抽象出来，同时将颜色作为一个接口引入，因为图形的形状和颜色本来就是两个不同的维度，所以它现在的类图应该是这个样子的。</p>
<p><img src="https://i.loli.net/2020/10/27/DUeGhk2pIcoKdwW.png" alt="bridge1.png"></p>
<p>有了类图，很快我就重构好了代码，测试一下。</p>
<blockquote>
<p>完整代码关注公众号回复：“源码” 获取</p>
</blockquote>
<p><img src="https://i.loli.net/2020/10/27/EPTuQae6DofyFSG.png" alt="bridge-test.png"></p>
<p>当我要新增一种图形或者一个颜色时，只需要增加一个类就可以了。真香。</p>
<h1 id="bridge-桥梁（接）模式"><a href="#bridge-桥梁（接）模式" class="headerlink" title="bridge 桥梁（接）模式"></a>bridge 桥梁（接）模式</h1><blockquote>
<p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
</blockquote>
<h2 id="把这绕口的东西看清楚"><a href="#把这绕口的东西看清楚" class="headerlink" title="把这绕口的东西看清楚"></a>把这绕口的东西看清楚</h2><p>将抽象部分与它的实现部分分离，使他们都可以独立地变化。这句话我不知道别人能不能读的懂，就我而言，刚看到这句话实在是没有搞清楚在表达什么，我猜想其中的原因，一个是因为设计模式是搞建筑的人提出来了，另一个原因是老外写的软件设计模式。翻译成中文为了达到统一的标准，所以很多知识变得晦涩难懂。</p>
<p><em>这里在顺带提一下所谓的统一的标准，就像开放平台的接口一样。他为了有更好的扩展性，定义了统一的对外接口，以后无论哪方想要对接，都需要适应我的标准，而不是给每个人都定制化一个接口。所以知识的传播也一样，要以一定的官方标准来定义和传播，不然可能传着传着就出现了歧义。这也就是复杂度守恒定律的根本，它本身其实真的并不复杂。以上个人见解，可以无视。</em></p>
<h2 id="在看抽象化、实现化、脱。脱。脱你妹啊脱，解耦。"><a href="#在看抽象化、实现化、脱。脱。脱你妹啊脱，解耦。" class="headerlink" title="在看抽象化、实现化、脱。脱。脱你妹啊脱，解耦。"></a>在看抽象化、实现化、脱。脱。脱你妹啊脱，解耦。</h2><p>因为之前有大哥的帮忙，所以很容易就理解了<code>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</code>这句话。</p>
<p>就拿我刚刚学的图形的那个案例。</p>
<ul>
<li>抽象部分就是图形的形状+颜色，图形它一定是有形状和颜色的。存在自身上的两个不同的维度变化</li>
<li>实现部分就是具体的形状和颜色。形状和颜色一定有具体的体现。要么圆形红色，要么方形透明。而形状又是图形本身的一部分，所以可以跟在主体后通过继承进行变化。颜色可以独立出去进行单独的扩展。</li>
</ul>
<p>独立的变化就是讲到抽象部分和实现部分的两个实现</p>
<ul>
<li>抽象部分的一个变化就是通过一个矩形类继承图形抽象类。同时完善一个构造函数，这是对抽象部分的矫正或者完备。</li>
<li>实现部分的变化遵循了<strong>里式替换</strong>与抽象部分的关联又根据<strong>依赖倒置</strong>原则设计。所以实现部分可以在自己的接口定义范畴能进行自由变化，同时又可以与抽象部分进行关联<strong>（桥接）</strong></li>
</ul>
<p>我试着把晦涩的东西简化一下</p>
<p><strong>一个对象的多个维度状态独立变化时，将其通过类组合的方式进行关联，使其每个维度自由变化，降低与主体的耦合。</strong></p>
<h2 id="桥接模式类图-📌"><a href="#桥接模式类图-📌" class="headerlink" title="桥接模式类图 📌"></a>桥接模式类图 📌</h2><p><img src="https://i.loli.net/2020/10/27/eQgjH6wkB2pSLfO.png" alt="bridge2.png"></p>
<h2 id="代码-📄"><a href="#代码-📄" class="headerlink" title="代码 📄"></a>代码 📄</h2><blockquote>
<p>完整代码关注公众号回复：“源码” 获取</p>
</blockquote>
<p><img src="https://i.loli.net/2020/10/27/iXWcetHJUxyBFNT.png" alt="bridge-code.png"></p>
<h2 id="总结-🐱‍💻"><a href="#总结-🐱‍💻" class="headerlink" title="总结 🐱‍💻"></a>总结 🐱‍💻</h2><p>哎呀，这个桥接模式我是万万没想到它会是这个样子。同样又是学完不知道在哪用的一种模式，但这就是我放弃学习的理由？那可真是太可笑了。</p>
<ul>
<li>当一个对象内存在多个维度多种状态时，可以使用桥接模式解耦，以防新增维度状态时导致 <strong>类爆炸</strong></li>
<li>维度的体现可以延迟到使用阶段，比如上述例子，颜色被分离出去，当需要具体对象时，在通过 set 方法对维度赋值（回复源码，获取全部源码和文章原稿）</li>
</ul>
<p>桥接模式的好处大家都看在眼里，记在心里。用了桥接模式首先解决的就是因为乱用继承导致的类爆炸问题，同时无论之后怎么扩展类，都只需要在对应维度维护新的实现就可以了，降低了对象间的耦合。</p>
<p>不好的地方，整个设计模式的缺点全都包含这一条： <strong>增加了系统的复杂性，对系统设计的理解多了一层内容。维护的类变多了。</strong> 这更能体现出一劳永逸的感觉，先吃苦，后舒坦。其实对于桥接模式还有一点，就是需要你能正确的去划分出一个对象的多维度状态，不然又成了“手里拿个锤子，看什么都像钉子”的感觉了。</p>
<h1 id="打工人的早高峰"><a href="#打工人的早高峰" class="headerlink" title="打工人的早高峰"></a>打工人的早高峰</h1><p>今天的公交车一点都不挤！就是下车的时候鸡蛋不知道咋回事碎了！还好是鸡蛋碎了，听懂掌声。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>和 lvgo 一起学设计模式（六）结构型之代理模式</title>
    <url>//post/lvgo-design-patterns-proxy.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/10/22/5l9eIS7tXdofFAE.png" alt="代理模式"></p>
<h1 id="设计模式的学习问题⁉❔"><a href="#设计模式的学习问题⁉❔" class="headerlink" title="设计模式的学习问题⁉❔"></a>设计模式的学习问题⁉❔</h1><p>我一直都在想如何学会一个新东西，和掌握一个旧东西🤔，有很多前辈给过一些建议和意见📑，（当然不是直接给我，都是看大佬的文章或者书籍当中。）先去用，再去学。嗯，我想是的，这样肯定是个很正常的学习过程。但是对于一些你暂时无法使用的东西，你如何去掌握它呢？我认为应该抛开表象去了解本质，通过本质的类比去掌握那些暂时无法使用的东西。设计模式就是这种情况，在平常的开发中，常用的设计模式就那么几种，其它的那些没有机会去接触，干学，如何才能掌握呢？🗃</p>
<p>我从小就是一个好为人师的家伙🤓，然而自己学习却一直都不怎么样😢。人太实在，也不懂的包装，我只知道我学习这么差的能学会的东西，讲给别人应该差不哪去。😊</p>
<p>在学习算法的时候，学到一个特别巧妙而且很好用的解题思路或者说逻辑思维<code>”分而治之“</code>，还有之前和网友讨论的一个叫做<code>”复杂度守恒定律“</code>的东西。这两个东西放在一起，可以说是很”矛盾“⚔🛡了。</p>
<p>说了这么多我想说的就是，设计模式这个知识点，真的很简单又很难。简单是因为每种设计模式的定义拿出来都能看的懂，难是难在如何，何时的应用。而我希望我写的这个设计模式系列是去应用化的，就是单纯的把设计模式的思想记录下来。我所理解的设计模式就该如此。</p>
<p>GOF的<strong>《设计模式.可复用面向对象软件的基础》</strong>通过一个应用案例的实现，串起了23种设计模式，我想在系列更新完之后也更新一个应用，将 23 种设计模式尽可能的应用到一个应用案例中去，而不是每个设计模式都涉及具体的应用，因为我觉得这可能会带的人们更关注应用的实现，而不是设计模式的应用，这是我的一些想法。</p>
<p><strong>不要纠结每种模式的具体实现，把它们抽象出来，你能够清楚的描述每种模式是为了解决什么问题而存在的时候，就已经掌握它了，就可以把它用在任何当你需要的时候。而不是问什么时候需要它，这可能有点绕，不过它是真的。不要问我设计模式可以解决哪些问题，把问题给我，我告诉你用什么设计模式可以解决它！</strong></p>
<p><em>我发现我更适合写一些畅谈型的文章🤣</em></p>
<h1 id="代理模式-👥"><a href="#代理模式-👥" class="headerlink" title="代理模式 👥"></a>代理模式 👥</h1><blockquote>
<p>为某对象提供一种代理以控制对该<strong>对象的访问</strong>。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</p>
</blockquote>
<p>代理模式是为了解决<strong>对象的访问控制</strong>，特别是当你的目标对象不可改变的时候。效果更佳明显。</p>
<p>先来几段对话，简单感受一下这个“代理”</p>
<ul>
<li>“这 google 好慢啊，搞个代理”</li>
<li>“您好，请问明年3月-12月有档期吗？” ”和我经纪人联系“</li>
<li>“我要告你” “好啊，有什么问题跟我的律师说吧”</li>
<li>“哦？是海大富海公公” “这是皇上口谕” “啊？（急忙下跪）“</li>
<li>“您好，这里是 12345 市长热线”</li>
</ul>
<p><strong>“控制一个实际的对象访问，同时可以达到一定的目的”</strong></p>
<h2 id="生活中的比喻"><a href="#生活中的比喻" class="headerlink" title="生活中的比喻"></a>生活中的比喻</h2><p>希望可以用生活中的一些例子能让我更好的去表达和梳理代理模式</p>
<h3 id="明星-amp-经纪人"><a href="#明星-amp-经纪人" class="headerlink" title="明星&amp;经纪人"></a>明星&amp;经纪人</h3><p>比如经纪人，他代理了明星（主体），负责主体功能以外的事情，主体可以进行商演，但在商演以前或以后的事情，都不需要主体去关系，全部都由经纪人去处理。</p>
<h3 id="公园门-amp-门禁"><a href="#公园门-amp-门禁" class="headerlink" title="公园门&amp;门禁"></a>公园门&amp;门禁</h3><p>一个公园的门禁，通过门禁系统，代理了公园的入口，公园入口只负责放人进入公园，不关心什么时候什么情况，来人就表示可以进入。门禁系统则负责什么时候，什么情况可以进。</p>
<p>通过使用代理模式，可以让我们的业务代码结构更加完整清晰，而将一些控制和辅助型的逻辑处理交给代理类，这其中体现的就是单一职责原则与迪米特法则。</p>
<p>上面的两个例子，我所想要表达的意思就是说明代理模式是为了<strong>控制一个实际对象的访问</strong>而存在的一种模式。不知道我说清了没有。</p>
<h2 id="程序中的例子"><a href="#程序中的例子" class="headerlink" title="程序中的例子"></a>程序中的例子</h2><h3 id="mybats-的数据访问接口"><a href="#mybats-的数据访问接口" class="headerlink" title="mybats 的数据访问接口"></a>mybats 的数据访问接口</h3><p>在代理模式中我们最常用到的应该就是 ORM 框架中的应用了，我们熟知的 mybatis 对<strong>数据库的访问控制</strong>就是使用了代理模式，通过一个接口的定义，来代理了数据库的访问操作。</p>
<p>在 mybatis 的代理模式处理思想如果翻译成白话：”你将你要执行的 SQL 告诉我在哪（mapper 映射，statement space），语句写好（xml）剩下的你都不用管“，这里的 mapper 接口即代理了数据库的访问工作。</p>
<p><strong>甚至 #{} ${} 占位符，也是一种代理模式的体现，不一定非要有完整的接口，具体的实现类，代理类才是代理模式。</strong>可能这理解起来会让你觉得有点强词夺理。</p>
<h2 id="代理模式类图-📌"><a href="#代理模式类图-📌" class="headerlink" title="代理模式类图 📌"></a>代理模式类图 📌</h2><p><img src="https://i.loli.net/2020/10/22/ziGBmy81YFw7kts.png" alt="prxy-UML"></p>
<h2 id="代码-📄"><a href="#代码-📄" class="headerlink" title="代码 📄"></a>代码 📄</h2><blockquote>
<p>完整代码获取关注公众号：星尘的一个朋友 回复 “源码”</p>
</blockquote>
<p>为了在深入的理解一下代理模式，我选择使用 mybatis 的代理模式实现原理伪代码。以及挖掘一下JDK动态代理的一些细节内容，当然我不会去写源码的东西（毕竟道理大家都懂，不可能凭空 new 出来一个接口的实例，这当中定有蹊跷，我相信你在任何一篇博文中都能看到这部分内容，当然也欢迎加我微信（lvgocc）进群讨论）</p>
<p><strong>mybatis的核心代理模式伪代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户接口</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/10/21 22:51</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 用户id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">selectByUserId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">UserMapper o = (UserMapper) Proxy.newProxyInstance(<br>        UserMapper.class.getClassLoader(),<br>        <span class="hljs-keyword">new</span> Class[]&#123;UserMapper.class&#125;,<br>        (proxy, method, arg) -&gt; &#123;<br>            <span class="hljs-comment">// 这里会执行具体的连接数据库执行 SQL 的操作 感兴趣可以查看 mybatis 源码继续了解。</span><br>            <br>            <span class="hljs-comment">// 打印参数</span><br>             logger.info(<span class="hljs-string">&quot;statement position: &#123;&#125;, args: &#123;&#125;&quot;</span>, method.getDeclaringClass().getCanonicalName() + <span class="hljs-string">&quot;#&quot;</span> + method.getName(), Arrays.toString(arg));<br>             <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;用户id：&quot;</span> + arg[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;公众号：星尘的一个朋友，加群一起学习设计模式&quot;</span>;<br>        &#125;);<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs reStructuredText">14:25:43.966 [main] INFO io.github.lvgocc.App - Hello World!<br>14:25:44.251 [main] INFO io.github.lvgocc.App - statement position: io.github.lvgocc.proxy.UserMapper#selectByUserId, args: [2333]<br>14:25:44.258 [main] INFO io.github.lvgocc.App - 查询结果：用户id：2333公众号：星尘的一个朋友，加群一起学习设计模式<br></code></pre></td></tr></table></figure>

<p>mybatis 使用动态代理，让一个接口去代理了真实的数据库对象，当你需要的时候，再去建立连接、访问数据库、执行SQL、返回结果。如果之前有了解过 mybatis 的代理模式，这里应该不难理解。</p>
<p><strong>下面再看一个简单的例子，当然用图说明可能会更容易</strong></p>
<p><img src="https://i.loli.net/2020/10/22/MpN1wxuCjrBH96t.png" alt="大洋彼岸的服务器"></p>
<blockquote>
<p>请忽略图中示意具体内容，只是借图表达代理的意义，控制对象的访问。</p>
</blockquote>
<h2 id="总结一下-🐱‍💻"><a href="#总结一下-🐱‍💻" class="headerlink" title="总结一下 🐱‍💻"></a>总结一下 🐱‍💻</h2><p>代理模式为了解决对象的访问控制而存在。</p>
<ul>
<li>当你想要抢一张<code>回家的车票</code>，你选择了<code>候补</code>，他选择了<code>加速</code>.此时 12306 或是 第三方 成了你的购票代理人。</li>
<li>当你来到一个<code>陌生的小区</code>，需要刷<code>门禁</code>卡才能进入。此时<code>门禁</code>成了<code>小区</code>的代理。</li>
</ul>
<p>通过上面的总结，我知道</p>
<ol>
<li>当我选择了候补，我和购票<strong>解耦了</strong>✔，不需要等它的结果，等通知就行。但中间多了一个候补，<strong>链路更长</strong>❌了。</li>
<li>我进门要刷卡，<strong>维护的对象多了</strong>❌，虽然<strong>系统变得复杂</strong>❌了，但小区<strong>更安全</strong>✔了，保护了小区。</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>和 lvgo 一起学设计模式（十一）结构型之享元模式</title>
    <url>//post/lvgo-design-patterns-flyweight.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/11/12/CKNbypcrJwdgflx.png" alt="flyweight-title"></p>
<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><blockquote>
<p>运用共享技术来有效地支持大量细粒度对象的复用。</p>
</blockquote>
<p>这个设计模式在 GOF 的书中是用 flyweight 这个词来定义这种模式的，然后翻译成中文就叫 享元 了，讲真挺不自在，首先这个词是一个自造词（享元）</p>
<p><img src="https://i.loli.net/2020/11/12/b8iZeYslH47DO6a.png" alt="flyweight-search.png"></p>
<p>再者就是这个词语我认为用轻量化的解释更合适，不过现在被翻译成享元肯定是有他的原因的，至于为什么翻译享元已经不重要了，这都不会影响我们学习的对不对！</p>
<h2 id="如何理解"><a href="#如何理解" class="headerlink" title="如何理解"></a>如何理解</h2><p>我们先一起来理解一下这个词的意思，然后再说这个模式解决的问题，希望我的解释能帮你快速的了解这个设计模式的意图。</p>
<p>我是这样理解的。享元，共享单元。什么意思呢，将一些资源共享，以减少一些不必要的资源消耗。我接着举几个例子说明一下；为了代入感更强，我就拿游戏举例了。</p>
<p><strong>声明：以下内容只为学习类比使用，并不代表游戏设计方案，游戏如何设计实现，我未参与，也未研究，感兴趣的可自行了解。</strong></p>
<h3 id="1-我的世界"><a href="#1-我的世界" class="headerlink" title="1. 我的世界"></a>1. 我的世界</h3><p><img src="https://i.loli.net/2020/11/12/qOtZ4YdgxePj1Iy.jpg" alt="mc"></p>
<h4 id="游戏地图"><a href="#游戏地图" class="headerlink" title="游戏地图"></a>游戏地图</h4><p>我们都知道我的世界是一个自由度超高的沙盒游戏。进到游戏之后我们应该会看到一个画面，就是地图在不断的渲染。这里可能以前玩的时候大家都没有注意过，只是觉得游戏好大，但是不怎么卡。不卡的原因有很多。我们今天要说的就是如何通过享元模式来减少资源负担。</p>
<p>假如我的世界地图中每个单位格子的内容大小为1kb，粗略估计一个画面内格子的数量为1,000,000，此时加载地图需要 1GB 的内存，如果每个格子2kb则 2GB。如果一个单元格内容所用的贴画是 10kb 呢。目前来看 10G 内存也都能接受，可这款游戏放在当年的话，估计不会有人玩了。</p>
<h4 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h4><p>其实这个方案非常的正常，也非常的简单。首先我们可以这样做，事先将需要用到的格子贴画统计好，然后一次加载到内存中，记录一下内存的地址，需要用的时候，直接取出来渲染就好了。他们的样子都差不多，只是摆放的位置不同。还有一种方式呢，就是我用一个先去我的 <strong>资源库</strong> 找，找不到就创建一个放到资源库中，如果能够找到，就直接返回。这两种方式都可以。第一种方式将压力放在了启动过程，第二种的方式将压力放在第一次渲染的过程。而一般情况下，游戏的开发都是用第一种方式，也就是我们所说的“过图”，”地图加载“。这个时候去做的，因为一次卡顿加载完和你走着走着卡一下当然第一种更容易接受。</p>
<h3 id="2-英雄联盟"><a href="#2-英雄联盟" class="headerlink" title="2.英雄联盟"></a>2.英雄联盟</h3><p><img src="https://i.loli.net/2020/11/12/Wxw5741lX6ThejY.jpg" alt="lol"></p>
<p>英雄联盟这款游戏大家应该并不陌生，S10 刚刚结束（10月31日全球总决赛），SN来年再战，加油。</p>
<h4 id="“兵线”"><a href="#“兵线”" class="headerlink" title="“兵线”"></a>“兵线”</h4><p>游戏中一共有 3 路兵线，每次出现几只我不清楚，8只好了。 3路乘以2（双方）然后在乘以8，这应该是48个对象。而且他们还包含各自的动作，比如魔法兵吐得“口水“，炮车喝奶茶吐的“珍珠”等等，如果是你在开发兵线系统的时候，内存爆炸了，比如有的玩家搞怪，不杀小兵，积攒了很多小兵，然后他卡了，说你游戏垃圾。你该如何去做呢。</p>
<p>其实我们分析下来的话，这里只会出现三种不同的兵种，步兵、魔法兵、炮车。然后再分为红蓝两方。在加上两个子弹。是不是就只有这8个对象呢，至于他们的轨迹，那些是每个对象的<strong>“外部状态”</strong></p>
<h2 id="如何构成"><a href="#如何构成" class="headerlink" title="如何构成"></a>如何构成</h2><p>知道了这种设计模式思路，就要继续了解一下享元模式具体的构成角色都有哪些了。比如以英雄联盟的兵线为例吧。</p>
<p><strong>客户端</strong></p>
<p>首先有一个客户端，负责获取对象，然后渲染，这里我们通过#get、#draw(x,y)来表示获取和画来代替这步动作，（x，y）表示渲染出来的对象坐标。</p>
<p><strong>享元工厂</strong></p>
<p>然后还有一个为我们提供小兵的统一接口，这里使用的就是我们前面学习的工厂方法，小兵工厂。这里顺便复习一下之前的工厂和抽象工厂两个设计模式。如果我通过一个工厂来实现小兵对象的创建，那么就是一个工厂模式，但是我现在想在应用的时候，在灵活一些，我们可以从小兵身上抽取特征，比如步兵、魔法兵、炮车、这是小兵类别，但我们有两个不同的作战方，红方和蓝方，所以此时可以使用抽象工厂模式来生产小兵，红方小兵工厂生产出来的都是红方的步兵、魔法兵、炮车。蓝方生产出来的就是蓝方的步兵、魔法兵、炮车。</p>
<p><strong>享元对象</strong></p>
<p>有了工厂之后，我们就要有具体的共享对象了，共享对象就是我们上面所说的那 8 个。</p>
<p>下面这个类图顺便复习了一下 <strong>抽象工厂模式</strong>。</p>
<p><img src="https://i.loli.net/2020/11/12/dKDUbQ9sJRvFmTA.png" alt="flyweight-bingxian"></p>
<h2 id="享元模式类图-📌"><a href="#享元模式类图-📌" class="headerlink" title="享元模式类图 📌"></a>享元模式类图 📌</h2><p><img src="https://i.loli.net/2020/11/12/YgS7J51GWuwZPBX.png" alt="flyweight.png"></p>
<h2 id="代码-📃"><a href="#代码-📃" class="headerlink" title="代码 📃"></a>代码 📃</h2><p>下面就使用 <strong>享元模式</strong> 来模拟一下英雄联盟的兵线的开发。</p>
<p><img src="https://i.loli.net/2020/11/12/stDkSmh83HpK1TV.png" alt="flyweight-coder.png"></p>
<p><img src="https://i.loli.net/2020/11/12/Yrh3FlIOuH5jREd.png" alt="flyweight-test.png"></p>
<blockquote>
<p>关注回复 “源码” 获取享元模式创建LOL兵线代码。</p>
</blockquote>
<h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><ol>
<li>通过享元模式可以让我们用更小的空间来构造一个更大对象。这也是利用了池技术来实现的。</li>
<li>使用享元模式可以有效的缓解内存使用的问题。</li>
<li>你会发现，当你有外部状态的时候（具体体现在红蓝两方在创建小兵对象的时候，需要指定颜色），享元模式会变得稍显复杂。</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>和 lvgo 一起学设计模式（十七）行为型之备忘录模式</title>
    <url>//post/lvgo-design-patterns-memento.html</url>
    <content><![CDATA[<h1 id="备忘录（Memento）模式"><a href="#备忘录（Memento）模式" class="headerlink" title="备忘录（Memento）模式"></a>备忘录（Memento）模式</h1><blockquote>
<p>在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</p>
</blockquote>
<p>还记得那些年你的游戏存档吗？</p>
<p><strong>Don’t Starve</strong></p>
<p><img src="https://i.loli.net/2020/11/28/uWjlqrXoOhPLIxY.jpg" alt="Don&#39;t Starve.jpg"></p>
<p><strong>unascribed-game1</strong></p>
<p><img src="https://i.loli.net/2020/11/28/18vxNgFbsJpASw6.jpg" alt="unascribed-game.jpg"></p>
<p><strong>unascribed-game2</strong></p>
<p><img src="https://i.loli.net/2020/11/28/Dl5H9G82FkpO4P1.jpg" alt="unascribed-game2.jpg"></p>
<h2 id="自己实现一个简易版的游戏存档功能"><a href="#自己实现一个简易版的游戏存档功能" class="headerlink" title="自己实现一个简易版的游戏存档功能"></a>自己实现一个简易版的游戏存档功能</h2><p>今天写一个游戏存档功能练习一下编码基本功。</p>
<p><strong>需求分析</strong></p>
<ol>
<li>需要有个管理存档的角色，那么多个存档总要有人来管啊，想存档或者读档需要它说了算。</li>
<li>还需要有个具体的存档对象，方便我们管理呀。</li>
</ol>
<p><strong>需求设计</strong></p>
<ol>
<li>存档对象的管理角色 Caretaker 管理存档对象</li>
<li>存档对象 Memento 具体的存档对象</li>
<li>存档的创建者 Originator 管理“存档”这件事，创建恢复存档。</li>
</ol>
<h2 id="代码-📃"><a href="#代码-📃" class="headerlink" title="代码 📃"></a>代码 📃</h2><blockquote>
<p>完整源码关注回复“源码获取”</p>
</blockquote>
<p><img src="https://i.loli.net/2020/11/28/ODChyStnGzM47Lo.png" alt="memento-source"></p>
<p>测试结果</p>
<p><img src="https://i.loli.net/2020/11/28/57jB1tPbwWDsdJR.png" alt="memento-test"></p>
<p><strong>展示存档列表</strong></p>
<p><img src="https://i.loli.net/2020/11/28/9SrAQZD465qW1zl.png" alt="memento-list-test"></p>
<h2 id="备忘录模式类图-📌"><a href="#备忘录模式类图-📌" class="headerlink" title="备忘录模式类图 📌"></a>备忘录模式类图 📌</h2><p><img src="https://i.loli.net/2020/11/28/hHtJlIPN9OTw4KL.png" alt="memento-UML1"></p>
<p>上面的代码是以这种类图方式实现的，不过这在 Java 中显然有可以优化的地方。即将 Caretaker 角色优化掉。优化后的类图</p>
<p><img src="https://i.loli.net/2020/11/28/GNXw8MnRPskxbSh.png" alt="memento-UML2"></p>
<blockquote>
<p>两个写法的完整源码关注回复“源码获取”，优化版代码在 optimization 目录中</p>
</blockquote>
<h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>由于备忘录模式使用这种代码构建的方式在 Java 中并不多，这要得益于 Java 的 <code>Serializable</code> 接口，可以使用序列化来完成备份的操作。所以只是简单的使用一个游戏存档案例记录一下这个知识点，配合学习理解的最好的再就应该是文档编辑功能中的 <code>ctrl+z</code>了。</p>
<p>备忘录模式可以使我们对一个对象的状态进行保存，在需要的时候快速恢复。不得不说的就是备忘录模式如果保存的大量的对象时，内存的占用还是需要关注一下的。在备忘录模式中保存对象的时候，可以配合原型模式来一起使用。</p>
<p>最后，这个模式在 Java 中应该不太香，原因上面也说了。所以<strong>我对这个设计模式仅作为了解</strong>，真正要使用它的话我还是会尽可能的考虑使用 <code>Serializable</code>。</p>
<p><strong>优点：</strong>无侵入备份/恢复对象状态（<strong>在 Java 里不是很香</strong>）。</p>
<p><strong>缺点：</strong>GOF 中的写法在 Java 中<strong>不香</strong>，同时使用这种模式需考虑内存占用问题。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>和 lvgo 一起学设计模式（十三）行为型之策略模式</title>
    <url>//post/lvgo-design-patterns-strategy.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/11/22/EbcfqsQpOhvYCad.png" alt="strategy-title.png"></p>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略模式最早的时候是在马老师的坦克大战看的，讲的很干，也挺清楚。现在回想起来更是记忆犹新。</p>
<p>说到策略模式，最应该关注的应该就是策略这个词语了吧。这个词我直接贴一段百度的翻译，大家看一下</p>
<p><img src="https://i.loli.net/2020/11/21/nYyQ4dELalKpr25.png" alt="image-20201121172440172"></p>
<p>提取和设计模式相关的两个含义</p>
<ol>
<li>可以实现目标的方案集合</li>
<li>根据不同情况选择不同的策略</li>
</ol>
<p>然后我们再看看标准的策略模式定义</p>
<blockquote>
<p>定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</p>
</blockquote>
<p>有了这个基本的清晰概念再学起来就很轻松了。</p>
<h2 id="策略模式类图-📌"><a href="#策略模式类图-📌" class="headerlink" title="策略模式类图 📌"></a>策略模式类图 📌</h2><p><img src="https://i.loli.net/2020/11/21/xRjFyEgXSmHnidp.png" alt="strategy-uml.png"></p>
<p>定义了一个策略接口，然后将每种不同的策略实现同一个接口。这样各个策略之间就可以进行切换。在使用的过程中，可以将策略当成参数传到具体的方法中执行（这里要用函数接口），或者在客户端调用之前就将指定好具体的策略。</p>
<h2 id="站点的主题切换-🎨"><a href="#站点的主题切换-🎨" class="headerlink" title="站点的主题切换 🎨"></a>站点的主题切换 🎨</h2><p>相信大家都使用过可以切换主题的站点，这次我也是尝试使用策略模式来实现这个功能。</p>
<p><strong>需求：</strong></p>
<ol>
<li>用户可以根据自己的喜欢自行选择预设的 3 个主题配色</li>
</ol>
<p><strong>3 个主题配色：</strong></p>
<ol>
<li><strong>七彩斑斓的黑</strong><ul>
<li>背景色：backgroundColor 黑色</li>
<li>字体颜色：fontColor 灰色</li>
</ul>
</li>
<li><strong>五颜六色的黑</strong><ul>
<li>背景色：backgroundColor 黑灰色</li>
<li>字体颜色：fontColor 白色</li>
</ul>
</li>
<li><strong>绚烂多彩的黑</strong><ul>
<li>背景色：backgroundColor 灰黑色</li>
<li>字体颜色：fontColor 黑色</li>
</ul>
</li>
</ol>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Theme 主题接口</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 欢迎跟我一起学习，微信（lvgocc）公众号：星尘的一个朋友</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@blog</span> <span class="hljs-doctag">@see</span> http://lvgo.org</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CSDN</span> <span class="hljs-doctag">@see</span> https://blog.csdn.net/sinat_34344123</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/11/21</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Theme</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Context</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 欢迎跟我一起学习，微信（lvgocc）公众号：星尘的一个朋友</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@blog</span> <span class="hljs-doctag">@see</span> http://lvgo.org</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CSDN</span> <span class="hljs-doctag">@see</span> https://blog.csdn.net/sinat_34344123</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/11/21</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Theme theme;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Theme <span class="hljs-title">getTheme</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> theme;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTheme</span><span class="hljs-params">(Theme theme)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.theme = theme;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        theme.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ThemeTest</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 欢迎跟我一起学习，微信（lvgocc）公众号：星尘的一个朋友</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@blog</span> <span class="hljs-doctag">@see</span> http://lvgo.org</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CSDN</span> <span class="hljs-doctag">@see</span> https://blog.csdn.net/sinat_34344123</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/11/21</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThemeTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        Context context = <span class="hljs-keyword">new</span> Context();<br>        System.out.println(<span class="hljs-string">&quot;七彩斑斓的黑&quot;</span>);<br>        context.setTheme(<span class="hljs-keyword">new</span> ColorfulBlack());<br>        context.show();<br><br>        System.out.println(<span class="hljs-string">&quot;五颜六色的黑&quot;</span>);<br>        context.setTheme(<span class="hljs-keyword">new</span> MotleyBlack());<br>        context.show();<br><br>        System.out.println(<span class="hljs-string">&quot;绚烂多彩的黑&quot;</span>);<br>        context.setTheme(<span class="hljs-keyword">new</span> SplendidBlack());<br>        context.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br>七彩斑斓的黑<br>- 背景色：backgroundColor 黑色<br>- 字体颜色：fontColor 灰色<br><br>五颜六色的黑<br>- 背景色：backgroundColor 黑灰色<br>- 字体颜色：fontColor 白色<br><br>绚烂多彩的黑<br>- 背景色：backgroundColor 灰黑色<br>- 字体颜色：fontColor 黑色<br><br></code></pre></td></tr></table></figure>

<p>其实要说这个策略模式的实现，它本身就是这么一个非常简单的写法。只是可以通过更多的思想融入可以使其变得更加灵活好用，同时也会变得复杂起来。这里一起看看一个经典的策略模式的实现，就是 JDK 中的比较器。在 JDK 中就是不同的类型有不同的比较算法，这也是符合了策略模式的思想。我再把策略模式的定义拿过来看一看</p>
<blockquote>
<p>定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</p>
</blockquote>
<p>JDK 为每种不同的数据类型定义了一系列的算法，并将每个算法封装起来，使他们可以通过 Comparator 接口进行相互替换，对于客户端来讲，尽管调用比较方法就可以了，即使算法发生了改变（替换其他算法）也不会影响到客户端的使用。</p>
<h2 id="JDK-比较器"><a href="#JDK-比较器" class="headerlink" title="JDK 比较器"></a>JDK 比较器</h2><p>JDK 中的比较实现有两种，一种是直接通过实现 Compareable 接口，定义其他对象与自己的顺序（比较）。而另一种就是通过使用策略模式来实现的比较器 Comparator 接口。接下来就一起看看 JDK 是怎么运用策略模式设计的比较器。</p>
<p>首先是策略模式中的第一个关键的定义，定义一系列算法。根据开闭原则，这里定义了一个接口，然后将具体的一系列算法实现延迟到子类当中去。</p>
<p>比较器 - 策略接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">T</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>一系列算法 - 具体策略</p>
<p>String 的比较算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER<br>                                     = <span class="hljs-keyword">new</span> CaseInsensitiveComparator();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CaseInsensitiveComparator</span></span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-comment">// use serialVersionUID from JDK 1.2.2 for interoperability</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">8575799808933029326L</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n1 = s1.length();<br>        <span class="hljs-keyword">int</span> n2 = s2.length();<br>        <span class="hljs-keyword">int</span> min = Math.min(n1, n2);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; min; i++) &#123;<br>            <span class="hljs-keyword">char</span> c1 = s1.charAt(i);<br>            <span class="hljs-keyword">char</span> c2 = s2.charAt(i);<br>            <span class="hljs-keyword">if</span> (c1 != c2) &#123;<br>                c1 = Character.toUpperCase(c1);<br>                c2 = Character.toUpperCase(c2);<br>                <span class="hljs-keyword">if</span> (c1 != c2) &#123;<br>                    c1 = Character.toLowerCase(c1);<br>                    c2 = Character.toLowerCase(c2);<br>                    <span class="hljs-keyword">if</span> (c1 != c2) &#123;<br>                        <span class="hljs-comment">// No overflow because of numeric promotion</span><br>                        <span class="hljs-keyword">return</span> c1 - c2;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n1 - n2;<br>    &#125;<br><br>    <span class="hljs-comment">/** Replaces the de-serialized object. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> CASE_INSENSITIVE_ORDER; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果对象本身支持比较，即实现了 Comparable 接口的对象，可以使用 Comparator 提供的下面这个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T extends Comparable&lt;? <span class="hljs-keyword">super</span> T&gt;&gt; <span class="hljs-function">Comparator&lt;T&gt; <span class="hljs-title">naturalOrder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (Comparator&lt;T&gt;) Comparators.NaturalOrderComparator.INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中 Comparators 这个类是专门为 Comparator 接口创建比较算法使用的默认类，是一个同包访问权限的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Package private supporting class for &#123;<span class="hljs-doctag">@link</span> Comparator&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comparators</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Comparators</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(<span class="hljs-string">&quot;no instances&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Compares &#123;<span class="hljs-doctag">@link</span> Comparable&#125; objects in natural order.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> Comparable</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NaturalOrderComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Object</span>&gt;&gt; </span>&#123;<br>        INSTANCE;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Comparable&lt;Object&gt; c1, Comparable&lt;Object&gt; c2)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> c1.compareTo(c2);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Comparator&lt;Comparable&lt;Object&gt;&gt; reversed() &#123;<br>            <span class="hljs-keyword">return</span> Comparator.reverseOrder();<br>        &#125;<br>    &#125;<br>    ....<br>    省略部分代码<br>    ....<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其实对于比较这种算法，更多的是由使用者自己来决定谁大谁小，JDK 仅提供了一些基本的比较策略。比如如下几种比较策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">  <span class="hljs-comment">// 常规比较</span><br>  <span class="hljs-keyword">static</span> &lt;T extends Comparable&lt;? <span class="hljs-keyword">super</span> T&gt;&gt; <span class="hljs-function">Comparator&lt;T&gt; <span class="hljs-title">naturalOrder</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> NaturalOrderComparator.INSTANCE;<br>   &#125;<br><span class="hljs-comment">// 空值小于非空</span><br>   <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Comparator&lt;T&gt; <span class="hljs-title">nullsFirst</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; var0)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NullComparator(<span class="hljs-keyword">true</span>, var0);<br>   &#125;<br><span class="hljs-comment">// 空值大于非空</span><br>   <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Comparator&lt;T&gt; <span class="hljs-title">nullsLast</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; var0)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NullComparator(<span class="hljs-keyword">false</span>, var0);<br>   &#125;<br><span class="hljs-comment">// 等等，如果还想了解可以自行查看 java/util/Comparator.java</span><br></code></pre></td></tr></table></figure>

<p><strong>注意：两个空值比较只是提供了当两个元素为空时的比较策略，当两个比较元素都不为空时需使用调用者提供的比较算法</strong></p>
<p>下面我们一起看下如何使用 JDK 的比较器来达到策略模式定义的第二点<code>它们可以相互替换，且算法的改变不会影响使用算法的客户。</code></p>
<h3 id="‘你’-大还是-‘好’-大"><a href="#‘你’-大还是-‘好’-大" class="headerlink" title="‘你’ 大还是 ‘好’ 大"></a>‘你’ 大还是 ‘好’ 大</h3><p>我们就拿 ‘<strong>你</strong>‘ 和 ’<strong>好</strong>’ 这两个汉字来尝试一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestJDKComparator</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String you = <span class="hljs-string">&quot;你&quot;</span>;<br>        String fine = <span class="hljs-string">&quot;好&quot;</span>;<br>        <span class="hljs-comment">// String 的比较器</span><br>        <span class="hljs-keyword">int</span> ctic = you.compareToIgnoreCase(fine);<br>        System.out.println(<span class="hljs-string">&quot;compareToIgnoreCase:&quot;</span> + ctic);<br><br>        <span class="hljs-comment">// JDK 提供的默认比较器</span><br>        Comparator&lt;String&gt; comparator = Comparator.naturalOrder();<br>        <span class="hljs-keyword">int</span> compare = comparator.compare(you, fine);<br>        System.out.println(<span class="hljs-string">&quot;naturalOrder = &quot;</span> + compare);<br><br>        <span class="hljs-comment">// 自定义比较器1</span><br>        Comparator&lt;String&gt; stringComparator1 = Comparator.nullsFirst((o1, o2) -&gt; &#123;<br>            <span class="hljs-keyword">byte</span>[] bytes1 = o1.getBytes();<br>            <span class="hljs-keyword">byte</span>[] bytes2 = o2.getBytes();<br>            <span class="hljs-keyword">return</span> bytes1.length - bytes2.length;<br><br>        &#125;);<br>        <span class="hljs-keyword">int</span> compare1 = stringComparator1.compare(you, fine);<br>        System.out.println(<span class="hljs-string">&quot;nullsFirst&amp;customComparator1 = &quot;</span> + compare1);<br><br>        <span class="hljs-comment">// 自定义比较器2</span><br>        Comparator&lt;String&gt; stringComparator2 = Comparator.nullsFirst((o1, o2) -&gt; &#123;<br>            <span class="hljs-keyword">int</span> length1 = o1.length();<br>            <span class="hljs-keyword">int</span> length2 = o2.length();<br>            <span class="hljs-keyword">int</span> min = Math.min(length1, length2);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; min; i++) &#123;<br>                <span class="hljs-keyword">char</span> o1Char = o1.charAt(i);<br>                <span class="hljs-keyword">char</span> o2Char = o2.charAt(i);<br>                <span class="hljs-keyword">if</span> (o1Char != o2Char) &#123;<br>                    <span class="hljs-keyword">return</span> o2Char - o1Char;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> length2 - length1;<br>        &#125;);<br>        <span class="hljs-keyword">int</span> compare2 = stringComparator2.compare(you, fine);<br>        System.out.println(<span class="hljs-string">&quot;nullsFirst&amp;customComparator2 = &quot;</span> + compare2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">compareToIgnoreCase:-<span class="hljs-number">2589</span><br>naturalOrder = -<span class="hljs-number">2589</span><br>nullsFirst&amp;customComparator1 = <span class="hljs-number">0</span><br>nullsFirst&amp;customComparator2 = <span class="hljs-number">2589</span><br></code></pre></td></tr></table></figure>

<hr>
<p>在 JDK 的比较器中有一个方法，可以让我们学习。就是 naturalOrder() 返回来的这个比较器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 常规比较</span><br><span class="hljs-keyword">static</span> &lt;T extends Comparable&lt;? <span class="hljs-keyword">super</span> T&gt;&gt; <span class="hljs-function">Comparator&lt;T&gt; <span class="hljs-title">naturalOrder</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">return</span> NaturalOrderComparator.INSTANCE;<br> &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NaturalOrderComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Object</span>&gt;&gt; </span>&#123;<br>    INSTANCE;<br><br>    <span class="hljs-comment">// 实现比较器定义的抽象方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Comparable&lt;Object&gt; c1, Comparable&lt;Object&gt; c2)</span> </span>&#123;<br>        <span class="hljs-comment">// 使用参数自己的“策略”</span><br>        <span class="hljs-keyword">return</span> c1.compareTo(c2);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Comparator&lt;Comparable&lt;Object&gt;&gt; reversed() &#123;<br>        <span class="hljs-keyword">return</span> Comparator.reverseOrder();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个比较器里有一个参数限制，而这个参数限制的就是必须是 Comarable 的实现类，同时是这个实现类的子类。其实，这个参数就是一个策略模式的“策略接口”，传入的参数就是具体的策略。因为这个传入的参数必须要实现 compareTo 这个方法，也就是实现 Comarable 接口的抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(T var1)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/11/22/6BejY1tkK3MaUZJ.png" alt="strategy-comparator.png"></p>
<p>在 JDK 中更灵活的使用比较器就是使用匿名类的写法</p>
<p><img src="https://i.loli.net/2020/11/22/AOCGdnXKmxrYFVJ.png" alt="image-20201122223734626"></p>
<h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>其实抛开这个模式本身，我们在一些逻辑实现的时候也会使用这种写法，最简单的就是对一个接口方法的实现。使得他们可以在不同的情况下进行不同的切换。所以，在我们系统中，如果可能出现一些相同的操作，但是却会有很多不同的实现的时候，就是在使用这种“策略模式”来实现。每个具体的实现算法不同，但是他们的操作是相同。使用开闭原则来控制算法的入口，具体的实现延迟到子类。但当我们的具体算法变多的时候，使用起来可能会有一些副作用，所以这个时候可以考虑使用工厂模式来辅助策略模式变得更好用。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>和 lvgo 一起学设计模式（十九）行为型命令之模式</title>
    <url>//post/lvgo-design-patterns-command.html</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/img_convert/4b0c6fc7d3e8ee4f4a942c404366a274.png#pic_center" alt="土方令"></p>
<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><blockquote>
<p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天一大早就来了图书馆🏫，刚坐下来就迫不及待的开始看命令模式的相关资料📚。不过这个模式跟我之前的理解出入特别大。</p>
<p>最开始的时候，我以为的命令模式就是<code>函数回调</code>。但后来发现并不是，但他们两个确实是有关系，这一切的答案都藏在 GOF 的设计模式一书中。</p>
<h2 id="开始学习"><a href="#开始学习" class="headerlink" title="开始学习"></a>开始学习</h2><p>在软件设计模式之始 GOF 的原著中，命令模式的讲解还是在他们开发的那个编辑工具中，其用来讲解的案例就是我们日常编辑使用的编辑工具中，在工具栏有很多个功能按钮，或者菜单按钮。 就比如编辑工具中的一个 <code>新增文件</code> 的按钮🆕吧。GOF 要表达的意思就是，这个 <code>新增文件</code> 对系统本身来讲就是给使用者提供的一个命令，我们在用的过程中可以给编辑器发送不同的命令，但是这个 <code>新增文件</code> 的操作并不是在这个按钮上实现的，同时对于我们发送命令的人来说，也不知道具体这个 <code>新增文件</code> 这个动作是由谁来执行、怎么执行，这对我们来讲完全是透明的。</p>
<p>我们先不讨论这样做的好处，先看下这里面要说的几个角色</p>
<ol>
<li>客户端应用</li>
<li><code>新增文件</code>按钮（调用新增文件操作命令）</li>
<li>操作命令</li>
<li>操作接收（负责具体的操作执行）</li>
</ol>
<p>我试着按照这个结构写了一下这个代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        FileReceiver fileReceiver = <span class="hljs-keyword">new</span> FileReceiver();<br>        AddFileCommand addFileCommand = <span class="hljs-keyword">new</span> AddFileCommand(fileReceiver);<br>        Invoker invoker = <span class="hljs-keyword">new</span> Invoker();<br>        invoker.setCommand(addFileCommand);<br>        invoker.executeCommand();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>客户端应用 <code>Client</code></li>
<li><code>新增文件</code>按钮（调用新增文件操作）<code>Invoker</code></li>
<li>操作命令 <code>AddFileCommand</code></li>
<li>操作接收者 <code>FileReceiver</code></li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">新增文件<br></code></pre></td></tr></table></figure>

<h2 id="关于-‘命令’-的疑惑-🤔"><a href="#关于-‘命令’-的疑惑-🤔" class="headerlink" title="关于 ‘命令’ 的疑惑 🤔"></a>关于 ‘命令’ 的疑惑 🤔</h2><p>按照上面的方式实现下来，我有一种感觉，有种脱裤子放屁的感觉，我直接调用 FileReceiver 不香吗</p>
<p>非要这样</p>
<p><img src="https://i.loli.net/2020/11/28/oqEZfATCtK2UuQk.png" alt="command.png"></p>
<p>我以为，使用者利用按钮直接调用对应的操作不就行了吗？就像我下面这样中间非要放一个命令对象（将具体的请求包装成了这个对象）？</p>
<p><img src="https://i.loli.net/2020/11/28/SiylpQUYxGRAb91.png" alt="command-no-command"></p>
<h2 id="解惑-‘命令’-🤪"><a href="#解惑-‘命令’-🤪" class="headerlink" title="解惑 ‘命令’ 🤪"></a>解惑 ‘命令’ 🤪</h2><p>不过不久我就找到了答案💡</p>
<p>首先看下命令模式要解决的问题❔：<u>对请求排队、下载或记录请求日志，以及支持可撤消的操作。</u></p>
<p>然后我们开始思考🤔如果没有中间这个 “命令” 角色，那这些功能做在哪里？只能做在接收者，也就是逻辑具体的实现里面，那这是不是违背了一个设计原则，叫做 <code>单一职责原则</code> ？而且对这种 ”辅助型“ 的功能变多会导致逻辑实现类<strong>变得越来越”肿胀“</strong>，没错，就是”肿胀“！</p>
<p>并且这也使得调用者和实现者之间通过这个“命令”进行解耦，然后我们使用依赖倒置原则，将“命令”提取出来一个抽象类，这使得扩展请求也变得容易了。而且对于高层模块来说，自己完全不需要关心调用的时候具体的请求内容和实现内容，通过“命令”来完成自己的操作，比如点一个按钮、遥控器下的按键（从这里还可以看出，多个命令可以对应一个接受者，比如数字键的换台）、去餐厅点菜。这样一看，命令模式还真是符合这种设计思路的命名啊。</p>
<h2 id="命令模式类图-📌"><a href="#命令模式类图-📌" class="headerlink" title="命令模式类图 📌"></a>命令模式类图 📌</h2><p><img src="https://i.loli.net/2020/11/28/8HJOtxMFsq6PjoE.png" alt="command-UML"></p>
<p>主要结构</p>
<ol>
<li>调用者，也是暴露给客户端的对象 <code>Invoker</code></li>
<li>命令接口，<code>Command</code>（满足依赖倒置原则，便于扩展）</li>
<li>具体的命令，这里要包含谁来接受这个命令的接受者对象 <code>ConcreteCommand</code></li>
<li>命令的接收者，这里没有列实现类是因为任何类都可以是接收者 <code>Receiver</code></li>
</ol>
<h2 id="代码-📃"><a href="#代码-📃" class="headerlink" title="代码 📃"></a>代码 📃</h2><p>命令模式这篇使用的是通用框架写了一个实现，在这基础上事实上我们可以做很多扩展，比如再 <code>Invoker</code> 类中将 command 换成 <code>List&lt;Command&gt;</code> 来实现请求的排队、撤销等操作。</p>
<p><img src="https://i.loli.net/2020/12/03/ZE2fTd4FHQYhxeo.png" alt="image-20201128142121299"></p>
<h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p><strong>适用场景：</strong></p>
<ol>
<li>需要记录请求记录；</li>
<li>请求可以进行排队处理；</li>
<li>请求可以进行撤销、重做；</li>
<li>具体接收者来决定请求是否执行（关于这一点，如果请求不是封装成一个对象的话，判断起来是比较困难的）</li>
</ol>
<p>不过这种模式并不是一个常用的思想，一定是当你想要对请求做一些事情的时候才考虑，具体的事情就上面提到的 4 点，不然的话使用这种模式真的就是我上面说的，“脱裤子放屁了”。</p>
<p>最后再来一句话来总结一下命令模式，“张三，把门关一下”。这里我就是 Invoker，“把门关一下“ 就是 command （命令），“张三” 是 receiver （接收者）。更多时候，我们实际开发中，”把门关一下“ 都是定义好的，”我“直接选就行了，就像遥控器上的按键一样。但切记这个模式的使用时机，别做”恶心“人的事！</p>
<p>如果哪里有问题或者有疑问，欢迎加我微信（lvgocc）讨论，或者直接进群交流！天凉了🥶🥶，进群一起取暖也好啊😁，等你~</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>和 lvgo 一起学设计模式（十二）结构型之组合模式</title>
    <url>//post/lvgo-design-patterns-composite.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/11/18/X5GxW3w6OH9pijR.png" alt="composite-title.png"></p>
<h1 id="聊聊自己理想的“知识”"><a href="#聊聊自己理想的“知识”" class="headerlink" title="聊聊自己理想的“知识”"></a>聊聊自己理想的“知识”</h1><h2 id="知识该怎么分享"><a href="#知识该怎么分享" class="headerlink" title="知识该怎么分享"></a>知识该怎么分享</h2><p>周末的时候去了图书馆，去计算机技术区域想找一些书看，于是翻到了一本《零基础读懂云计算》，我发现我和作者的心态非常相似，他所谈及的就是因为“云计算”被太多太多的人去层层定义，结果导致人们对“云计算”这个词语已经开始有了一些丢失本质的理解了。他站在了“云计算”的本身出发，去掉了对它的层层包装，让读者真正的明白了什么是“云计算”（通过自己的思考），而不是将“云计算”给你定义一个什么什么高大上的名词来让你觉得很神奇的一种姿态来讲，字里行间也流露着他书名的意图。至少我看了之后，可以拨开很多营销或应用谈及的“云计算”虚伪的面纱，如果某人给我说哪个应用是怎么怎么利用“云计算”来完成的某个什么什么业务的时候，我也知道该怎么去追问他然后去判断到底他是不是应用了“云计算”。</p>
<p>我写下的，记录的这个设计模式系列文章《和 lvgo 一起学习设计模式》也是这个初衷。我希望能把每个设计模式也当成一个单纯的“套路”记录下来，然后希望自己以后复习和现在正在阅读的你都能自己去思考其中具体的内容。而不是走马观花或<strong>强行应用某种模式</strong>写一个案例来对自己甚至是正在阅读的你来一个“<strong>洗脑式</strong>”学习。</p>
<p>想要掌握一个知识，一门技术，一定要有自己的理解在其中，保持着怀疑的态度可以学到更多。因为你想知道的更多，随着你知道的越多，你不知道的就越多。<strong>但要注意这个过程是一个体系的深入，而不是发散，不然你会发现自己“虚胖”。</strong></p>
<p><img src="https://i.loli.net/2020/11/18/cUJtwMWhu84FZxV.gif" alt="timg.gif"></p>
<h2 id="知识该怎么学习"><a href="#知识该怎么学习" class="headerlink" title="知识该怎么学习"></a>知识该怎么学习</h2><p>网络中的知识多如牛毛，很多内容大多都是每篇文章作者自己的理解写出来的，还有一些利用“原型模式“写出来的，无关怎么写的，作为读者的我们都应该具备一些内容虚实辨别能力，多去抽象的理解，抛开层层包装，看其本质。而不是”双兔傍地走，安能辨我是雌雄“。举个不恰当就像你怎么辨别一个人是男人还是女人，无关他穿什么衣服，是否化妆，是否整容，是不是长发，等等等等这些外在的包装。（如果是分辨正常人，一定有一个非常准确的办法，我不说你也知道）</p>
<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><blockquote>
<p>将对象组合成树形结构以表示“部分 -整体”的层次结构。组合使得用户对单个对象和组合对象的使用具有一致性</p>
</blockquote>
<p>今天要学习的东西有点意思，因为我看到了很多有意思的内容，也在这里记录分享给现在正在阅读的你。</p>
<p>被拉来图书馆，电脑马上扛不住了，搞快。</p>
<p><img src="https://i.loli.net/2020/11/14/sMd83J2oN79yTFt.png" alt="image-20201114112656175"></p>
<h2 id="如何理解"><a href="#如何理解" class="headerlink" title="如何理解"></a>如何理解</h2><p>上面的定义是 <strong>Gang Of Four 在《可复用面向对象软件的基础》</strong>中对组合模式的意图阐述的内容。</p>
<p>不兜圈子，我先说下我是怎么理解这个设计模式的：<strong>把对象以树形结构放在一起，想要用的时候，操作组合（抽象）对象和操作任意一个对象是一样一样的。</strong> </p>
<p>在学习组合模式之前，我认为它就是把多个对象组装放在一起变成一个更大的对象，这就是我对组合模式最初的理解。但当我自己亲手使用组合模式来编写一段代码的时候我发现，实际情况和我所理解的还是有所差别的。当然这其中的差别只是在于具体的实现上，如果你对组合模式的理解停留在 A + B = C，我觉得这也是正确的。不过还有一个关键的内容，就是 <strong>操作组合对象和操作任意一个对象是一样一样的</strong>。</p>
<p>在这过程中，我问了身边的几个小伙伴，大家都说了组合模式是一个树结构。这也说明了 A + B = C 的形式体现是以树结构形式体现的，后来又在攀谈中聊到了具体的应用，比如：应用的菜单、组织架构，还有 <strong>pom</strong>（这里的 pom 要站在maven角度来看，而不是站在 xml 这种树结构来看）。</p>
<h3 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h3><p>上面的内容说到了 <strong>组合</strong> 模式的一个关键的定义内容，就是它的表现形式是以树形结构来呈现的，这里还想在墨迹一点东西就是组合模式只是利用了树结构这种形式的结构。</p>
<h3 id="一致的访问"><a href="#一致的访问" class="headerlink" title="一致的访问"></a>一致的访问</h3><p>至于后半段的定义，<code>对单个对象和组合对象的使用具有一致性</code> 理解成对树形结构当中的根节点、子节点、叶节点的访问方式都是一样的。</p>
<p><strong>放一张图</strong></p>
<p><img src="https://i.loli.net/2020/11/18/ix4bmnCvVeZt1WB.png" alt="composite-tree.png"></p>
<blockquote>
<p>图片来源 <a href="http://c.biancheng.net/view/1373.html">http://c.biancheng.net/view/1373.html</a></p>
</blockquote>
<h2 id="组合模式类图-📌"><a href="#组合模式类图-📌" class="headerlink" title="组合模式类图 📌"></a>组合模式类图 📌</h2><p><img src="https://i.loli.net/2020/11/18/IBSMYHvNkALojDb.png" alt="composite-UML.png"></p>
<h2 id="让我们一起利用它做点事"><a href="#让我们一起利用它做点事" class="headerlink" title="让我们一起利用它做点事"></a>让我们一起利用它做点事</h2><blockquote>
<p>这个案例的想法来自<code>傅哥</code>火遍全网的《重学设计模式》中组合模式的案例</p>
</blockquote>
<p>现在有一个需求，新注册的用户要进行关键信息的填写，性别、年龄。然后在首页根据用户信息进行一些商品的推送。拿到这个需求的时候是不是想着一顿 if else 猛如虎的操作来完成呢？当然我一开始也是这样想的哦，但谁知道产品经理哪天头皮发痒再给我来一个职业、地区、消费能力。。。为了满足产品未来的欲望，我想到了这个。</p>
<p><img src="https://i.loli.net/2020/11/18/PRYgzetrOd1uB9p.png" alt="composite-code"></p>
<p>通过代码实现以上结构后，</p>
<blockquote>
<p>篇幅原因完整代码关注回复“<strong>源码</strong>”获取</p>
</blockquote>
<p><img src="https://i.loli.net/2020/11/18/o7aBkLicKZWnz6G.png" alt="composite-code1.png"></p>
<p>核心代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 决策</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> user 用户信息</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 决策结果</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> DecisionComponent <span class="hljs-title">decision</span><span class="hljs-params">(User user)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (judge(user)) &#123;<br>           logger.info(<span class="hljs-string">&quot;进入 &#123;&#125; 决策分支&quot;</span>, getName());<br>           <span class="hljs-keyword">for</span> (DecisionComponent decisionComponent : decisionComponents) &#123;<br>               <span class="hljs-keyword">if</span> (decisionComponent.judge(user)) &#123;<br>                   <span class="hljs-keyword">return</span> decisionComponent.decision(user);<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>



<p>输入参数：男性、35岁</p>
<p>输出结果：</p>
<p><img src="https://i.loli.net/2020/11/18/ZRQotEphMvnbeL8.png" alt="composite-test-result.png"></p>
<h2 id="还有个内容要知道"><a href="#还有个内容要知道" class="headerlink" title="还有个内容要知道"></a>还有个内容要知道</h2><p><strong>透明方式和已知（安全）方式</strong></p>
<p>关于组合模式除了树形结构、一致的访问，还有一个就是它具体的呈现方式，这个呈现方式指的是对于 <strong>客户端</strong> 也就是高层模块，呈现方式有两种</p>
<ul>
<li>透明的，高层模块不需要去区分是子节点还是叶子节点，一样的去使用，但是对于叶子节点，某些功能可能会失效或出现一些特殊的情况</li>
<li>已知（安全）的，需要高层模块自己对子节点或是叶子节点的使用进行选择。</li>
</ul>
<p>对于透明和已知再通过一个 UML 类图和上面的类图对比加以说明</p>
<p><strong>透明的组合模式类图</strong></p>
<p><img src="https://i.loli.net/2020/11/18/IBSMYHvNkALojDb.png" alt="composite-UML.png"></p>
<p>透明的组合模式希望各个节点（子节点、叶节点）行为与抽象节点一致，这样即高层模块无需关心是否是子节点还是叶节点，方法一样的使用，但是对于子节点，因为其没有继续的分支，所以一些方法是没有具体的实现的，这就导致这些“空方法”高层模块是不知情的，所以称为透明的。</p>
<p><strong>已知的组合模式类图</strong></p>
<p><img src="https://i.loli.net/2020/11/18/Sy2Ed9eG6LOlbZz.png" alt="composite-safe-UML"></p>
<p>这个已知的名字是我起的，书上大多说的是安全方式。要表达的意思就是高层模块需要知道自己调用的节点是子节点还是叶子节点。</p>
<h2 id="发现身边的组合模式-📚"><a href="#发现身边的组合模式-📚" class="headerlink" title="发现身边的组合模式 📚"></a>发现身边的组合模式 📚</h2><p>相信大家都用过 maven 来管理多模块项目，maven的结构主要分为三类，继承、聚合、依赖，以下这些命令在 root 模块执行的时候，就可以将整个项目完成对应的操作，当你在单个模块中使用的时候，他也只会影响单个模块或该模块以下的模块。</p>
<p><img src="https://i.loli.net/2020/11/18/J67uzqmg8YcAPUd.png" alt="maven-lifecycle.png"></p>
<h1 id="再墨迹一点"><a href="#再墨迹一点" class="headerlink" title="再墨迹一点"></a>再墨迹一点</h1><p><em>设计模式这东西，我最早的理解就是武功秘籍，一招一式都是固定的。丢了一招半式可能就没用了，就像《武状元苏乞儿》中“星爷”饰演的苏乞儿最后来与赵无极那里，降龙十八掌少一掌都打不赢。而后又有无名的无名剑法、张三丰的太极剑法，万变不离其宗、无招胜有招。武学的真正奥义实为融会贯通，设计模式其便是技术这片江湖的一本绝世武功秘籍，幸运的是现在的武功秘籍人手一本。</em></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>和 lvgo 一起学设计模式（十五）行为型之观察者模式</title>
    <url>//post/lvgo-design-patterns-observer.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/11/24/NYiKTrU5G2BnkEs.png" alt="observer-title.png"></p>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><blockquote>
<p>多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</p>
</blockquote>
<p>提到观察者，就一定有“被观察者”。</p>
<p>被观察者发生改变时，通知给每个观察者，这就是观察者模式。放到生活中的例子就是</p>
<ul>
<li>天气预报的短信通知，在很早以前，我们的天气预报服务可以通过短信的信息订阅。在这个业务场景中，天气预报就是被观察者，每个付费的用户就是观察者，当有最新的天气预报的消息时，会以短信的形式通知给曾经付过费订阅的用户。如果不订阅是不会收到的。</li>
<li>你现在在使用的通讯软件中的’群聊’功能，这个相对较为复杂一点，可以抽象的理解一下，用一个人去理解，群里的每个人都是被观察者，每个人都是观察者。当一个人发出消息的时候，所有在群里的人都会收到消息也包括自己。反之，不在群里的人则收不到。</li>
<li>还记得小区单元门口一个一个小盒子吗？有的小盒子里是有当天的报纸的。甚至里面的报纸内容可能是不相同的，这里就涉及到了多个被观察者和观察之间的关系，这个小盒子能收到自己订阅的报社报纸，当然你可以同时订阅多个，这样你就可以收到多个报社送过来的报纸了。</li>
</ul>
<p>对于上面的例子，天气预报需要用户自己付费订阅、群聊需要先进群、在家看报需要联系报社订阅报纸。这里就能看出来。这种关系是一个一对多的关系。被观察者是同一个，而观察者却可以是很多个不同的对象。还有就是观察者需要自己主动的去找被观察者“提前”说明好，“一旦有消息，请通知我一声”。所有这里可以抽象出来几个角色和动作。</p>
<ol>
<li>被观察者（1个）</li>
<li>观察者（n个）</li>
<li>被观察者负责管理观察者对象</li>
<li>观察者自己负责被观察者给予的通知内容</li>
</ol>
<h2 id="观察者模式类图-📌"><a href="#观察者模式类图-📌" class="headerlink" title="观察者模式类图 📌"></a>观察者模式类图 📌</h2><p><img src="https://i.loli.net/2020/11/24/ybnYo1RH5wNC9Gk.png" alt="observer-UML.png"></p>
<ol>
<li>被观察者（Observable）</li>
<li>观察者（Observer）</li>
<li>被观察者负责管理观察者对象(Observable.obs)</li>
<li>观察者自己负责被观察者给予的通知内容(Observer.update)</li>
</ol>
<p>如果对 JDK 熟悉的同学可能早已看穿，这个类图画的其实就是 JDK 提供的观察者框架，我们可以用它轻松的实现一个订阅通知功能。而这一功能在 JDK 1.0 的版本就已经存在了。</p>
<h2 id="代码-📃"><a href="#代码-📃" class="headerlink" title="代码 📃"></a>代码 📃</h2><p>JDK 源码，篇幅原因只保留了核心代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util;<br><span class="hljs-comment">// 观察者</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Observable var1, Object var2)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>JDK 源码，篇幅原因只保留了核心代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util;<br><span class="hljs-comment">// 被观察者</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observable</span> </span>&#123;<br>	<span class="hljs-comment">// 管理观察者对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Vector&lt;Observer&gt; obs = <span class="hljs-keyword">new</span> Vector();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(Observer var1)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.obs.contains(var1)) &#123;<br>            <span class="hljs-keyword">this</span>.obs.addElement(var1);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 通知给订阅的观察者</span><br> 	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">(Object var1)</span> </span>&#123;<br>        Object[] var2 = <span class="hljs-keyword">this</span>.obs.toArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var3 = var2.length - <span class="hljs-number">1</span>; var3 &gt;= <span class="hljs-number">0</span>; --var3) &#123;<br>            ((Observer)var2[var3]).update(<span class="hljs-keyword">this</span>, var1);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>自己实现部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Observable</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setChanged</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.setChanged();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Observable o, Object arg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是 consumer1 我收到了&quot;</span> + o + <span class="hljs-string">&quot;的通知，通知内容：&quot;</span> + arg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Observable o, Object arg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是 consumer2 我收到了&quot;</span> + o + <span class="hljs-string">&quot;的通知，通知内容：&quot;</span> + arg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Observable o, Object arg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是 consumer3 我收到了&quot;</span> + o + <span class="hljs-string">&quot;的通知，通知内容：&quot;</span> + arg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试，定义了 2 个被观察者（生产者），3 个观察者（消费者）来分别使用12生产者来发布消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">jdkOb</span><span class="hljs-params">()</span> </span>&#123;<br>    Producer producer1 = <span class="hljs-keyword">new</span> Producer();<br>    producer1.setChanged();<br>    Producer producer2 = <span class="hljs-keyword">new</span> Producer();<br>    producer2.setChanged();<br>    Consumer1 consumer1 = <span class="hljs-keyword">new</span> Consumer1();<br>    Consumer2 consumer2 = <span class="hljs-keyword">new</span> Consumer2();<br>    Consumer3 consumer3 = <span class="hljs-keyword">new</span> Consumer3();<br><br>    producer1.addObserver(consumer1);<br>    producer1.addObserver(consumer2);<br>    producer1.addObserver(consumer3);<br>    producer2.addObserver(consumer1);<br>    producer2.addObserver(consumer2);<br>    producer2.addObserver(consumer3);<br><br>    producer1.notifyObservers(<span class="hljs-string">&quot;我是生产者1，我现在给你们通知一条消息，收到赶紧去消费掉&quot;</span>);<br>    producer2.notifyObservers(<span class="hljs-string">&quot;我是生产者2，我现在给你们通知一条消息，收到赶紧去消费掉&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">我是 consumer3 我收到了Producer@57cd70的通知，通知内容：我是生产者1，我现在给你们通知一条消息，收到赶紧去消费掉<br>我是 consumer2 我收到了Producer@57cd70的通知，通知内容：我是生产者1，我现在给你们通知一条消息，收到赶紧去消费掉<br>我是 consumer1 我收到了Producer@57cd70的通知，通知内容：我是生产者1，我现在给你们通知一条消息，收到赶紧去消费掉<br><br>我是 consumer3 我收到了Producer@1a7504c的通知，通知内容：我是生产者2，我现在给你们通知一条消息，收到赶紧去消费掉<br>我是 consumer2 我收到了Producer@1a7504c的通知，通知内容：我是生产者2，我现在给你们通知一条消息，收到赶紧去消费掉<br>我是 consumer1 我收到了Producer@1a7504c的通知，通知内容：我是生产者2，我现在给你们通知一条消息，收到赶紧去消费掉<br></code></pre></td></tr></table></figure>



<h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>使用观察者模式需要注意的几个点</p>
<ol>
<li>观察者数量，如果一个被观察者被很多观察者观察（订阅）时，在通知时的时间将会变得漫长；</li>
<li>不能出现被观察者和观察者之间存在循环观察情况，否则系统会直接崩溃；</li>
</ol>
<p>观察者模式的代码虽然很简单，但是它所创造的价值却远不止这些。相信你同我一样，通过观察者模式联想到了消息通知、binlog订阅、注册中心等技术组件。其核心内容也只是在此简单的不能再简单的思想上去做更多更复杂的功能迭代。</p>
<p>万变不离其宗。在复杂的系统，在复杂的功能，都能找到其根本所在。知识，亦是如此。</p>
<p>当然，你也可以尝试在现有的代码中进行一些修改，比如通知的情况改为有新的观察者加入时？通知的数据变得更丰富一些？异步通知？等等等等。</p>
<p>如果你有更好的点子可以关注并分享给我们（欢迎加群）！</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>和 lvgo 一起学设计模式（十八）行为型之迭代器模式</title>
    <url>//post/lvgo-design-patterns-iterator.html</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/img_convert/ef7aed4c24f3d2f219e4ea4451a2e3c9.png#pic_center" alt="海尔"></p>
<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><blockquote>
<p>提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p>
</blockquote>
<p>在看迭代器模式之前，我觉得应该来研究一段代码开开胃先。</p>
<h2 id="Java-中的-List-集合遍历"><a href="#Java-中的-List-集合遍历" class="headerlink" title="Java 中的 List 集合遍历"></a>Java 中的 List 集合遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Appetizer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;String&gt; strings = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>            strings.add(<span class="hljs-string">&quot;第&quot;</span> + i + <span class="hljs-string">&quot;个元素&quot;</span>);<br>        &#125;<br>        Iterator&lt;String&gt; iterator = strings.iterator();<br>        <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>         	iterator.next();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码很简单，我们在日常开发中可能也是经常使用到。有的人可能会说了，啊不对，我用的都是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strings.size(); i++)<br></code></pre></td></tr></table></figure>

<p>还有的朋友说了，我直接用增强<code>for</code>循环啊</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(String s : Strings)<br></code></pre></td></tr></table></figure>

<p>是的，没错。在日常开发中，或多或少的人会用以上两种方式来进行一个列表的遍历。那这两者有什么区别呢？让我们通过编译出来的 <code>class</code>  文件来一探究竟吧。</p>
<p>这里使用三种不同的写法来遍历一个 list</p>
<p><strong>java 源码文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 使用迭代器遍历</span><br>Iterator&lt;String&gt; iterator = strings.iterator();<br><span class="hljs-keyword">while</span>(iterator.hasNext())<br>	iterator.next()<br><br><span class="hljs-comment">// 2. jdk 8 提供的 lambda 写法</span><br>strings.forEach(System.out::println);<br><br><span class="hljs-comment">// 3. 增强 for 循环写法</span><br><span class="hljs-keyword">for</span> (String string : strings) &#123;<br>    System.out.println(string);<br>&#125;<br><br><span class="hljs-comment">// 4. 下标遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strings.size(); i++) &#123;<br>    System.out.println(strings.get(i));<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>class 反编译的 java 文件内容</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 使用迭代器遍历</span><br>Iterator&lt;String&gt; iterator = strings.iterator();<br><span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>    iterator.next();<br>&#125;<br><br><span class="hljs-comment">// 2. jdk 8 提供的 lambda 写法</span><br>var10001 = System.out;<br>strings.forEach(var10001::println);<br>Iterator var3 = strings.iterator();<br><br><span class="hljs-comment">// 3. 增强 for 循环写法</span><br><span class="hljs-keyword">while</span>(var3.hasNext()) &#123;<br>    String string = (String)var3.next();<br>    System.out.println(string);<br>&#125;<br><br><span class="hljs-comment">// 4. 下标遍历</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strings.size(); ++i) &#123;<br>    System.out.println((String)strings.get(i));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第一种和第三种可以算为同一种，所以就只剩下三种迭代方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 增强 for 循环（迭代器）</span><br><span class="hljs-keyword">for</span>(String s : Strings)<br><span class="hljs-comment">// 2. JDK8 的 forEach 方法</span><br>Strings.forEach()<br><span class="hljs-comment">// 3. 下标遍历</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strings.size(); i++)<br></code></pre></td></tr></table></figure>

<p>接下来我们用数据来看一下这几种方式的表现情况</p>
<p><strong>第一次</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">测试方法：iterator<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">21</span><br>-----------------------------<br>测试方法：forEach<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">132</span><br>-----------------------------<br>测试方法：增强 <span class="hljs-keyword">for</span> 循环<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">18</span><br>-----------------------------<br>测试方法：下标遍历<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">1</span><br>-----------------------------<br></code></pre></td></tr></table></figure>

<p><strong>第二次</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">测试方法：iterator<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">17</span><br>-----------------------------<br>测试方法：forEach<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">123</span><br>-----------------------------<br>测试方法：增强 <span class="hljs-keyword">for</span> 循环<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">12</span><br>-----------------------------<br>测试方法：下标遍历<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">3</span><br>-----------------------------<br></code></pre></td></tr></table></figure>

<p><strong>第三次</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">测试方法：iterator<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">18</span><br>-----------------------------<br>测试方法：forEach<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">119</span><br>-----------------------------<br>测试方法：增强 <span class="hljs-keyword">for</span> 循环<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">14</span><br>-----------------------------<br>测试方法：下标遍历<br>测试数据量：<span class="hljs-number">1000000</span><br>花费时长（ms）：<span class="hljs-number">2</span><br>-----------------------------<br></code></pre></td></tr></table></figure>

<p>为了更直观的展示，我整理了一张统计图</p>
<p><img src="https://i.loli.net/2020/11/28/VR5IWpXJtTPgKAB.png" alt="10万-1250万数据量4种方式遍历list统计图"></p>
<p>通过数据也证实了 迭代器 和 增强 for 循环的写法效果相同。</p>
<h2 id="List-集合到底该如何遍历"><a href="#List-集合到底该如何遍历" class="headerlink" title="List 集合到底该如何遍历"></a>List 集合到底该如何遍历</h2><p>其实乍一看数据，应该用下标遍历这种方式啊，当然，正常是这样的，这是因数组的下标索引决定的它的访问时间复杂度O(1)，同时 JDK 也为 <code>ArrayList</code> 增加了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RandomAccess</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>标记。标记其为随机访问集合。</p>
<p><img src="https://i.loli.net/2020/11/28/XqV1x3iUp5YCQjk.png" alt="run-faster-than"></p>
<p>Java 官方给出的遍历说明：根据经验，下标要比迭代器更快。</p>
<p>当然，根据我们对数据的测试表现情况来看，当你的数据量低于30w时，这个时间差基本是没有任何影响的，我想，这一切应该得益于当下处理器的计算能力以及内存更高的数据交互速度吧。所以你用以上的 4 种方式都是没有问题的。但是如果你遍历的数据量大于100w时，一定要使用下标遍历了。</p>
<p>关于 List 集合的遍历，我们就讨论这么多，更主要的是我们要讨论一下上面提到的一个东西，“迭代器”</p>
<blockquote>
<p>文末关注回复“源码”获取本文测试使用代码及图表数据</p>
</blockquote>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>我通过上面的开胃菜知道，迭代器是用来遍历集合的，或者说它是用来遍历的。</p>
<p>这个时候我们就想了，那刚刚的列表不用这个迭代器速度反而更快，用它还慢还麻烦，为什么要用它呢？</p>
<p>我们可以想象一下，如果此时的数据结构不是数组，而是链表、是树、是图呢？</p>
<p>集合本身的目的是存取，目的明确，但如果我们在集合本身增加了遍历操作的话，我们可以看看下图。</p>
<p><img src="iterator-collection.png" alt="iterator-collection.png"></p>
<blockquote>
<p>图片来源：<a href="https://refactoringguru.cn/design-patterns/iterator">https://refactoringguru.cn/design-patterns/iterator</a></p>
</blockquote>
<p>假如对于一个链表，我们开始想要以 DFS 方式遍历，写好了一个算法在集合类中，后面发现有需要 BFS 方式遍历这个集合，以目前这种方式，就只能去修改集合类，再加一个方法。如果哪天发现这两个都不合适，又要加一个呢，慢慢的，集合本身的存取目的开始变得不明确，这其实是因为违反了<code>单一职责</code>原则。</p>
<p>致使遍历访问的问题需要被单独解决。于是迭代器就出现了，它要解决的问题就是用来遍历集合，同时它并不需要去关注具体要遍历的集合是什么样的数据结构。这里我们可以回想一下刚刚测试遍历列表的操作，迭代器在迭代的时候，它知道遍历的具体的数据结构是什么吗？不知道，对于一个迭代器来讲，它只需要关注如何将集合的数据完整无缺的取出来就好了。</p>
<p>这样，迭代器的概念就捋清了，再看看迭代器模式的定义</p>
<blockquote>
<p>提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p>
</blockquote>
<p>接下来我们就看看 JDK 中是怎么样用这个迭代器模式来设计集合遍历程序的。go！</p>
<h2 id="迭代器模式类图-📌"><a href="#迭代器模式类图-📌" class="headerlink" title="迭代器模式类图 📌"></a>迭代器模式类图 📌</h2><p><img src="https://i.loli.net/2020/11/28/4doaxqQrbWgUhvM.png" alt="iterator-JDK-UML"></p>
<p>下面是根据 JDK 的类直接生成的 UML 类图</p>
<blockquote>
<p>注意：并非全部类生成的 UML 类图，这里去掉了一些无关类。</p>
</blockquote>
<p><img src="https://i.loli.net/2020/11/28/LSbEmXAoFpGnN8U.png" alt="iterator-idea-UML.png"></p>
<h2 id="代码-📃"><a href="#代码-📃" class="headerlink" title="代码 📃"></a>代码 📃</h2><p>因为迭代器模式是围绕 JDK 的 iterator 来学习的，所以这里具体的迭代器模式的实现代码就没有自己实现，不过这里学习了 JDK 的代码。我就简单记录一下 JDK 的实现思路。</p>
<ol>
<li>定义一个可被迭代的约束类，表示其子类可以被迭代器迭代，这里用的是 <code>Iterable</code>接口。</li>
<li>定义迭代器接口，其子类为具体的迭代器实现。这里说的是<code>Iterator</code> 接口。</li>
<li>可被遍历的集合实现<code>Iterable</code> 接口，比如 <code>ArrayList</code>。</li>
<li>具体迭代器的实现<code>Iterator</code>接口，JDK 使用的 ArrayList 的内部类 Itr 来实现的这个接口。</li>
<li>迭代器中的提供一个顺序访问的规则，然后通过顺位标识调用集合的“get”方法。</li>
</ol>
<p>为了直观表示这个”get”方法，我贴几个迭代器的 next() 实现关键部分代码。</p>
<p><strong>ArrayList</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-comment">// 这里的 elementData[i] 就是我上面说的 “get” 方法</span><br>    <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>LinkedList</strong>(使用的是 AbstractList 的迭代器)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 这里的 get 就是我上面说的 “get” 方法</span><br>    E next = get(i);<br>    <span class="hljs-keyword">return</span> next;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>HashSet/HashMap</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 这里的 nextNode() 就是我上面说的 “get” 方法</span><br>    <span class="hljs-keyword">return</span> nextNode().key;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">nextNode</span><span class="hljs-params">()</span> </span>&#123;<br>    Node&lt;K,V&gt;[] t;<br>    Node&lt;K,V&gt; e = next;<br>    <span class="hljs-keyword">if</span> ((next = (current = e).next) == <span class="hljs-keyword">null</span> &amp;&amp; (t = table) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-keyword">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> e;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>以上内容可以配合 JDK 源码了解，下面列一些涉及类或方法位置</p>
<ol>
<li><code>Iterable.java</code></li>
<li><code>Iterator.java</code></li>
<li><code>ArrayList.java</code></li>
<li><code>java/util/ArrayList.java:846</code> （jdk8）</li>
</ol>
<h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><ol>
<li>迭代器模式主要解决的问题就是集合的遍历与集合访问要进行合理的划分职责，这满足了<strong>单一职责</strong>原则。集合类本身专注集合的存取，迭代器专注集合的遍历。</li>
<li>同时迭代器在实现的过程中不需要关注待遍历集合的数据结构，因为它会使用目标集合的“get”方法来按序读取集合元素。所以这使得了同一个迭代器可以遍历不同的集合，同样的同一个集合也可以用不同的迭代器来进行遍历。</li>
<li>因为有了迭代器接口和可被迭代的集合接口两个接口的设计方式可以在集合或迭代器的扩展上提供很好的支持，这也满足了<strong>开闭原则。</strong></li>
<li><strong>这个模式基本不会使用。除非你有自己的数据结构和对他们的遍历规则时。</strong></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>和 lvgo 一起学设计模式（十六）行为型责任链模式之模式</title>
    <url>//post/lvgo-design-patterns-chain-of-responsibility.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/11/28/25fjXDYo4VriF9l.png" alt="chain-of-responsibility.png"></p>
<blockquote>
<p>图片来源：<a href="https://refactoringguru.cn/design-patterns/chain-of-responsibility">https://refactoringguru.cn/design-patterns/chain-of-responsibility</a></p>
</blockquote>
<h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><blockquote>
<p>把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</p>
</blockquote>
<p>通过上面的图其实也能看个差不多了，在这幅图中水桶就是整个链路中被传递的对象。它可以在链路上的任意一个节点被消费，如果你觉得剩的水可以继续给下一个节点用，你甚至可以将它继续传递下去。这样设计的好处就行定义中说的那样，去除对象将的耦合。</p>
<p>假设这个业务场景需要请求的对象是存在联系的，比如具有一定顺序去消费同一个对象，又比如他们消费对象的方法相同，具体逻辑略有差异。此时如果这个水桶对象的传递不通过责任链这种模式，看看会有什么问题。</p>
<p><img src="https://i.loli.net/2020/11/28/UuO5PtAK6Xwvx1q.png" alt="chain-of-responsibility-none"></p>
<p>王二需要分为4个时刻与4个不同的对象进行交互，这无疑增加了系统的复杂性。并且这里其中任意一个请求目标发生变化，王二都必须要跟着调整。再比如下面这个生活中的例子。</p>
<p>王二因为一些原因不能上班，需要和领导请假，卑微的王二在单位的职位级别比较低，需要多级领导审批，甚至同事都是一个坎，让我们看看没有责任链模式介入时王二的请假过程。</p>
<p><img src="https://i.loli.net/2020/11/28/f2Vca1v5tFpGPhn.png" alt="chain-of-responsibility-wanger"></p>
<p><strong>王二卒。</strong></p>
<p>王二这件事被同事张三知道后，张三决定为了纪念王二的悲催经历。他决定向领导提出一个流程调整方案，具体的意见如下；</p>
<ol>
<li>请假时每个人的动作相同，均为审批。至于审批是同意或拒绝由审批者自己决定。</li>
<li>对请假流程中涉及的人员使用链式传递。不得跨越（即每个人必须都需要经过处理后才能继续传递）。</li>
</ol>
<h2 id="责任链模式类图-📌"><a href="#责任链模式类图-📌" class="headerlink" title="责任链模式类图 📌"></a>责任链模式类图 📌</h2><p><img src="https://i.loli.net/2020/11/28/VwsODFXe7ISup6c.png" alt="chain-of-responsibility-UML.png"></p>
<h2 id="张三请假-📃"><a href="#张三请假-📃" class="headerlink" title="张三请假 📃"></a>张三请假 📃</h2><p>张三使用责任链模式请假流程示意图</p>
<p><img src="https://i.loli.net/2020/11/28/QKCPk5Ixmpir7to.png" alt="chain-of-responsibility-zhangsan"></p>
<p>抽象处理类，各个环节处理时统一标准。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractHandler</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> AbstractHandler next;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractHandler <span class="hljs-title">getNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(AbstractHandler next)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(String request)</span> </span>&#123;<br>        conCreteHandle(request);<br>        <span class="hljs-keyword">if</span> (getNext() == <span class="hljs-keyword">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;流程结束&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            getNext().handle(request);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">conCreteHandle</span><span class="hljs-params">(String request)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QingJia</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractHandler</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">conCreteHandle</span><span class="hljs-params">(String request)</span> </span>&#123;<br>        System.out.println(request);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractHandlerTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>&#123;<br>        AbstractHandler qingJia = <span class="hljs-keyword">new</span> QingJia();<br>        AbstractHandler renShi = <span class="hljs-keyword">new</span> RenShi();<br>        AbstractHandler shangjiLingdao = <span class="hljs-keyword">new</span> ShangjiLingdao();<br>        AbstractHandler tongShi = <span class="hljs-keyword">new</span> TongShi();<br>        AbstractHandler zuZhang = <span class="hljs-keyword">new</span> ZuZhang();<br><br>        qingJia.setNext(tongShi);<br>        tongShi.setNext(zuZhang);<br>        zuZhang.setNext(shangjiLingdao);<br>        shangjiLingdao.setNext(renShi);<br><br>        qingJia.handle(<span class="hljs-string">&quot;张三请假&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试张三请假</p>
<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">张三请假<br>同事审批：同意<br>组长审批：同意<br>上级领导审批：同意<br>人事审批：同意<br>流程结束<br></code></pre></td></tr></table></figure>

<blockquote>
<p>完整代码文末关注，回复 “源码” 获取。</p>
</blockquote>
<h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>使用责任链模式可以使原本的对象间耦合度降低。各个模块间功能更加具体专注。同时链上的处理也可以更加灵活，可以通过处理请求的时候进行判断来过滤自己关注的内容来处理，或者在生成链的时候将无关节点去掉。</p>
<p>同时可以配合创建型模式中的工厂模式，来封装链的维护，这样在链上节点发生变化时（算法实现发生改变、新增或删除）对于高层模块是没有感知的。扩展起来非常的方便。或使用建造者模式来更加灵活地创建这条“责任链”，以达到客户端的自定义目的。总之，责任链模式在处理链式问题是个利器。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>和 lvgo 一起学设计模式（十四）行为型之模板方法模式</title>
    <url>//post/lvgo-design-patterns-template-method.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/11/24/65JlOrxysH82ivQ.png" alt="template-method-title.png"></p>
<h1 id="冲啊！"><a href="#冲啊！" class="headerlink" title="冲啊！"></a>冲啊！</h1><p>最近经常看《四驱兄弟》，脑子已经被“冲啊”洗掉了。</p>
<p>“冲啊，就让我们一路领先到底吧！”，“冲啊，看我的胜利冲锋！”，“冲啊！先驱音速！”，“去吧！三角箭！”，“冲啊！疾速斧头！”，“冲啊！二郎丸特别号！”，“冲啊！”</p>
<p>终于来到了设计模式的“人性”部分，行为型模式，为什么说行为型模式是“人性”部分呢，因为行为型模式当中的 11 种设计模式对理解都非常的友好啊。所以接下来的内容可能让我学起来说不定更有趣些。</p>
<h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><blockquote>
<p>定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p>
</blockquote>
<h2 id="如何理解"><a href="#如何理解" class="headerlink" title="如何理解"></a>如何理解</h2><p>定义一个操作中的算法骨架，说白了这不就是一个步骤约束吗？在看第二段，将算法的一些步骤延迟到子类中，意思就是步骤里的一部分留给你了，具体怎么做看你（子类）自己了。使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤，这句就更好理解了，有了步骤的约束，你负责执行具体的步骤，说白了，步骤只要执行就可以，不管你怎么做，所以也就有了不改变结构的情况下可以重新定义特定的步骤，这里的特定指的就是约束步骤里留给你的那部分步骤。</p>
<ul>
<li><p>比如我们经常写 PPT 的小伙伴知道，在 PPT 中，点击新增一页 PPT ，创建出来的页面，大部分的布局格式都是已经设置好的，我们只需要去填充里面的内容就可以了。</p>
</li>
<li><p>再比如经常写需求说明书的时候，会和同事要一份“模板”，这也是一种模板方法模式的体现。</p>
</li>
<li><p>还有如果你使用过 maven 创建过项目，那这个你一定不陌生</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/11/24/1mWL2Nnue5A3yrF.png" alt="template-method-maven.png"></p>
<h2 id="重新定义"><a href="#重新定义" class="headerlink" title="重新定义"></a>重新定义</h2><p>模板方法模式就是：提供一个具体的步骤，1,2,3,4，现在1,2,4都写好了，步骤3的实现由具体的执行者说了算，只要步骤符合要求，随你发挥。</p>
<h2 id="模板方法模式类图-📌"><a href="#模板方法模式类图-📌" class="headerlink" title="模板方法模式类图 📌"></a>模板方法模式类图 📌</h2><p><img src="https://i.loli.net/2020/11/24/RsQzpH46XNZTWcd.png" alt="template-method"></p>
<p>看类图就是抽象和子类的样子，而实际模板方法模式就是利用了”抽象”。是一个完全遵守开闭原则的设计模式。可以这么说，搞懂了模板方法模式，开闭原则基本就通了。</p>
<p><strong>注意：模板方法模式中与我们平时继承抽象类有一个关键性的区别，就是入口方法，正常抽象类继承是不需要有这个所谓的入口方法，可以通过入口方法来确定算法的执行顺序，即算法骨架。</strong></p>
<h2 id="我怎么用模板方法模式📃"><a href="#我怎么用模板方法模式📃" class="headerlink" title="我怎么用模板方法模式📃"></a>我怎么用模板方法模式📃</h2><p>模板方法模式可以说是非常简单的一种设计模式了，虽然简单，但它的作用却很大。比如我们经常使用的lock 锁，它的实现就利用了 AQS ，而 AQS 就是使用 <strong>模板方法模式</strong> 维护的一个锁框架，通过它可以快速的开发出一个锁。这步可以结合 AQS 的代码来看一看。</p>
<p>第一步：通过 Lock 接口来约束一个锁所需要的几个关键方法（其实这也可以说是一种模板，只是约束力很小）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MutexLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync = <span class="hljs-keyword">new</span> Sync();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.release(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sync.newCondition();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>核心代码</strong></p>
<p>第二步：具体的锁实现，这个类的约束力比较强，因为我们想偷懒，借助 AQS 来实现一个锁，所以就要按照它所提供的模板要求来完成对应步骤的代码逻辑，也就是上面提到的（使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。）这些需要我们去写的步骤就是 AQS 留给我们的 “特殊步骤”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, arg)) &#123;<br>                setExclusiveOwnerThread(Thread.currentThread());<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">1</span>, arg)) &#123;<br>                setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function">Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConditionObject();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>关于 AQS 留给我们的 “特殊步骤”可以在源码中看到</p>
<p>我们自己定一个锁，然后调用 acquire 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MutexLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync = <span class="hljs-keyword">new</span> Sync();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>之后 AQS 按照它的模板继续执行，在需要的时候（特殊步骤）会调用我们自己提供的方法，锁具体的实现要自行实现，模板类 AQS 不提供具体实现。</p>
<p><img src="https://i.loli.net/2020/11/24/ruJo4M3l1SF9ILO.png" alt="template-method-AQS1.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">      <span class="hljs-comment">// 重写 AQS 的特殊步骤，如果不写会抛出上述异常</span><br><span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>          <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, arg)) &#123;<br>              setExclusiveOwnerThread(Thread.currentThread());<br>              <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>          &#125;<br>      &#125;<br></code></pre></td></tr></table></figure>

<p>通过一个图来理解这个过程</p>
<p><img src="https://i.loli.net/2020/11/24/Vl3LZn1STyj8MbU.png" alt="template-method-AQS2.png"></p>
<p>其中“<strong>特殊步骤</strong>”就是 AQS 模板留给我们要实现的地方。</p>
<p>最后，测试一下我们自己写的锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MutexLockTest</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> f = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Lock lock = <span class="hljs-keyword">new</span> MutexLock();<br>        <span class="hljs-keyword">int</span> threadCount = Runtime.getRuntime().availableProcessors();<br>        CountDownLatch signal = <span class="hljs-keyword">new</span> CountDownLatch(threadCount);<br>        <span class="hljs-keyword">int</span> loop = <span class="hljs-number">100000</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadCount; i++) &#123;<br>            Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (l &lt; loop) &#123;<br>                    lock.lock();<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        f++;<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        lock.unlock();<br>                    &#125;<br>                    l++;<br>                &#125;<br>                signal.countDown();<br>            &#125;);<br>            thread.start();<br>        &#125;<br>        signal.await();<br>        Assertions.assertEquals(threadCount * loop, f);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<p><img src="https://i.loli.net/2020/11/24/bXn3FYOSryAseka.png" alt="template-method-test.png"></p>
<p>这里建议大家配合源码学习，同时也能学习一些与锁实现上的一些相关知识，如果有不清楚或觉得有疑问的地方，欢迎加我微信一起讨论（lvgocc）</p>
<h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>通过模版模式可以将一些我们想要约束的执行步骤固定下来，同时对于步骤中重复的内容可以进行抽象，这样就可以简化很多子类的操作，也避免了一些不必要的冗余代码产生。</p>
<p>使用模板方法模式可以非常简单的来约束一段逻辑的执行要求。在做程序扩展限制时，非常有用。定义好具体的逻辑流程抽象类，将公共部分代码写在抽象类中，然后将其中需要使用者自行实现的方法定义为抽象方法，这样当他继承这个类的时候，只需要将对应的抽象方法实现就好了，不需要关系其具体的执行顺序。</p>
<p>但同样的，这样会使<strong>执行顺序对使用者完全透明</strong>，如果抽象的方法较为复杂时，对于一个初次使用该逻辑的人来说，出现 bug 可能会使他很“难受”，因为他需要搞清楚整个抽象类中每个方法的执行顺序才能更好的去解决问题。这一点，<strong>增加了系统的复杂性</strong>。不过，设计模式的复杂性，是不可避免的。<strong>在功能复用、提高生产力上来说，这点复杂性的代价，还是能够接受的。</strong></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>和 lvgo 一起学设计模式（十）结构型之外观模式</title>
    <url>//post/lvgo-design-patterns-facade.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/11/02/EhWVb7JoP3mCi9j.png" alt="facade"></p>
<p>今天用5分23秒，搞懂外观模式，计时~开始！</p>
<h1 id="书生的家书"><a href="#书生的家书" class="headerlink" title="书生的家书"></a>书生的家书</h1><p>从前，有一个书生，去到很远的地方读书。离开家里久了，难免会思念家乡，于是他便带着书童收拾好行囊，来到城门口登记 —— 接收包裹检查 —— 赶路 ——  到家。几次折腾之后，书生的成绩下滑了，身体也吃不消了，家里觉得这也不是一个长期的办法，于是商量出来一个办法：想家的时候，他便写一封家书，叫自己的书童给他带到老父亲家里。这样一来，书童便拿着他的家书，在城门口进行登记、检查包裹、然后出了城赶路。这使得书生可以专心读书，传递家书的事情，都由书童来做。</p>
<p><img src="https://i.loli.net/2020/11/01/wIdcHjVJ6P5fK8S.png" alt="facade"></p>
<p>书生再也不用为了每次登记检查包裹赶路这些事情费心了，可以<strong>专心的学习做好自己的事情</strong>了。即使哪一天不需要登记了，书生也不需要管，只需要努力学习和想家的时候写好家书送给书童就可以了。</p>
<p><img src="https://i.loli.net/2020/11/01/GvzmfKdp8UrjDeP.png" alt="facade1"></p>
<p>书生为了使自己能够更好的学习，更加专注于自己的 “业务”，将一些复杂的过程交给了书童去处理。至于书童要经历什么，书生并不关心，他只关心你给我提供传递书信的 “服务”，我给你 ”信“，你再回给我 ”信“。</p>
<p>这让我想到了汽车加油，好多人他们只知道没有了去加油站加油就好了，但是并没有多少人清楚石油石化业的艰辛历程。扯远了，回来说我们的问题。</p>
<p>对于书童这种行为，慢慢的演变成了现在的<strong>邮局</strong>。</p>
<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><blockquote>
<p>为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</p>
</blockquote>
<h2 id="SLFJ"><a href="#SLFJ" class="headerlink" title="SLFJ"></a>SLFJ</h2><p><strong>第一个想到的外观模式具体的应用.</strong></p>
<p>在我学习外观模式之前，我一直在想的事情就是我哪里用到了这个设计模式，脑子里第一个蹦出来的就是 SL4J 这个日志 api 框架，他就是一个日志门面。主要的核心思想就是外观模式，他所负责的，就是书童干的事。提供你一个方法，你把参数给他，他给你返回一个记录日志的对象，至于这中间的复杂过程，你不需要知道。</p>
<p>赠送一个用不到的知识点：log4j、logback、sl4j 都是出自同一个作者，这也是为什么 logback 天然支持 sl4j 真香的原因之一。</p>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>我想，基本上知道编程的人，应该都知道什么是 <strong>MVC</strong> ，<strong>model</strong> 、<strong>view</strong> 、<strong>control</strong> 。但大家仔细研究过这三者的关系吗？当然今天不是主要来介绍 <strong>MVC</strong> 的，而是通过 <strong>MVC</strong> 来认识外观模式。其中 <strong>V</strong> 就是书生，<strong>C</strong> 就是书童， <strong>M</strong> 就是具体的送信执行过程。<strong>书生</strong>（客户端 view）永远都不需要知道 <strong>书童</strong>（服务端 control）是如何把<strong>信送</strong>（服务端 model 业务实现）<strong>过去和拿回来</strong>的。</p>
<p><img src="https://i.loli.net/2020/11/01/bUaKr8cfMwG5LX4.png" alt="facade2"></p>
<h2 id="外观模式类图-📌"><a href="#外观模式类图-📌" class="headerlink" title="外观模式类图 📌"></a>外观模式类图 📌</h2><p><img src="https://i.loli.net/2020/11/02/O4ebA9Ma3noDVR6.png" alt="facade3.png"></p>
<h2 id="代码-📃"><a href="#代码-📃" class="headerlink" title="代码 📃"></a>代码 📃</h2><blockquote>
<p>回复“源码”获取书童送信全部代码</p>
</blockquote>
<p>我们通过代码在看一下书童是如何帮助书生完成送信的，<del>看看他路上有没有偷懒</del> 。</p>
<p><img src="https://i.loli.net/2020/11/02/F8Iv1RbrgnxSlKw.png" alt="shutongsongxin.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 书生送信 - 书生</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 欢迎跟我一起学习，公众号搜索：星尘的一个朋友</span><br><span class="hljs-comment"> * 也可以加我微信（lvgocc）拉你进群</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgorice@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@blog</span> <span class="hljs-doctag">@see</span> http://lvgo.org</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@CSDN</span> <span class="hljs-doctag">@see</span> https://blog.csdn.net/sinat_34344123</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/11/2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShuSheng</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ShuSheng.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        LOGGER.info(<span class="hljs-string">&quot;书生写好信给了书童&quot;</span>);<br>        ShuTong shuTong = <span class="hljs-keyword">new</span> ShuTong();<br>        shuTong.songXin();<br>        LOGGER.info(<span class="hljs-string">&quot;书童拿回了信给了书生&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/11/02/Lmv8Uq7wo4pNWQx.png" alt="shutongsongxin1.png"></p>
<p>我们通过代码可以看出，整个过程书生也没有参与送信的具体过程，这些全部都由书童（外观角色）来完成，这其中设计了 2 个子系统，城门和老父亲。</p>
<h2 id="总结-📚"><a href="#总结-📚" class="headerlink" title="总结 📚"></a>总结 📚</h2><p>迪米特法则又叫作最少知识原则 LOD/LKP ，1987 年美国东北大学👨‍🎓（Northeastern University）的一个名为迪米特（Demeter）的研究项目….(更多内容关注公众号点击“设计模式”专题序章查看)；</p>
<p>外观模式是一个遵循了迪米特法则的一种设计模式。书生只知道送信找书童，但他不需要知道还要登记、检查等等其他的事情。</p>
<p>外观模式又称作门面模式，理解成门面感觉会更好的理解是不是。至少我认为更好理解一些。就像人的脸面嘛，比如有一件事叫我做，你就跟我说嘛，你也不知道我怎么想的，怎么做的，我给你反馈结果就好了。当然例子可能不是很恰当，希望我要表达的意思能让你看的清楚。</p>
<p>外观模式主要特征</p>
<ol>
<li>√ 降低了系统间的耦合度，子系统的变化不会影响高层模块的调用。</li>
<li>√ 提高了高层模块的使用理解。我只想送信，给我接口。</li>
<li>× 违背了开闭原则，其实你只要没有遵循依赖倒置，就一定会在功能增加或变更的时候违反开闭原则。如果想要不违背开闭原则，那就需要将依赖的具体的类，转成依赖抽象的类或接口。</li>
</ol>
<p><strong>外观模式的扩展</strong> ：上面的案例还可以可以使用一个接口来代替书童的位置，然后让书童来实现这个接口，后面如果想要新增一种送信的工具人实现或者继承送信的接口就可以了。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>一转眼设计模式已经学了 10 种了。时间也过去 3 周了，有些内容可能已经慢慢的开始忘记了，我偶尔也会打开之前的文章在看上一下，如果第一遍第二遍仔细的看过，那后面再看就可以很快的复习一遍。学习任何知识也是如此，如果第一遍第二遍都是走马观花的看，后面每次看都会觉得很陌生，如果前面可以仔细的看过，然后定期的复习，很多东西都可以很容易做到，只是时间的问题。当然我这种都是比较笨的学习方法，但是还是蛮有效的。也特别希望大家能够在群里一起讨论一起学习复习，因为每次交流都是一次加深印象的时刻。</p>
<p><strong>真正掌握一个知识的时候，便是你能把它教给别人的时候。</strong></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>和 lvgo 一起学设计模式（四）创建型之原型模式</title>
    <url>//post/lvgo-design-patterns-prototype.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/10/17/q62IGUFY1xmdbw4.png" alt="clone-wordpress"></p>
<h1 id="原型模式-🎭"><a href="#原型模式-🎭" class="headerlink" title="原型模式 🎭"></a>原型模式 🎭</h1><blockquote>
<p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。</p>
</blockquote>
<p><img src="https://i.loli.net/2020/10/16/waBiVhAvyOptTE3.png" alt="来源：https://refactoringguru.cn/design-patterns/prototype"></p>
<blockquote>
<p>图片来源：<a href="https://refactoringguru.cn/design-patterns/prototype">https://refactoringguru.cn/design-patterns/prototype</a></p>
</blockquote>
<h2 id="简单理解"><a href="#简单理解" class="headerlink" title="简单理解"></a>简单理解</h2><p>每年中秋节的时候，大家都会吃到自己心仪口味的样式各异的月饼，但是他是怎么生产出来的呢，我猜它应该是有一个模板，比如花边图案的月饼</p>
<p><img src="https://i.loli.net/2020/10/16/Lm9cNiTsrtSRMdl.jpg" alt="月饼模板原型"></p>
<p>他会创造出来一个月饼原型，当你想吃五仁的时候，就把里面的馅改成五仁的，当你想吃蛋黄的（自己准备鸡蛋），就把馅改成蛋黄的，这样做不仅提高了生产效率，而且还节省了一部分再创建一个月饼的时间。</p>
<p>==再比如说可恶的盗图、盗文章、盗视频的人，他们把原创内容拿回去改个名字，去掉水印，随便改改内容，就成了自己的了！？==</p>
<p><img src="https://i.loli.net/2020/10/17/koZI5pEbB8hmJHl.png" alt="clone-wordpress1"></p>
<p>上面说的两个案例的行为都是在节省了创建时间，同时达到了自己的一些目的。而这在设计模式中，就叫做<strong>原型模式</strong>，为了解决一个对象的创建而出现的一种设计模式，归类在了创建型模式中。</p>
<blockquote>
<p>注意：在行为型模式中有着与之类似的一种模式——模版方法模式，是为了制定解决一件事情中的一系列操作约束而存在的一种模式，二者的区别在于，原型模式用于对象创建，模板方法模式用于事件行为约束。</p>
</blockquote>
<h2 id="原型模式类图-📌"><a href="#原型模式类图-📌" class="headerlink" title="原型模式类图 📌"></a>原型模式类图 📌</h2><p><img src="https://i.loli.net/2020/10/16/Ct5bJAgkDiTcWsy.png" alt="prototype-UML"></p>
<h2 id="来看代码-📃"><a href="#来看代码-📃" class="headerlink" title="来看代码 📃"></a>来看代码 📃</h2><blockquote>
<p>完整代码及单元测试结果点击查看 <a href="https://github.com/lvgocc/java-design-patterns/tree/main/prototype">https://github.com/lvgocc/java-design-patterns/tree/main/prototype</a></p>
</blockquote>
<p>java 的 JDK 中，提供一个标识接口 Cloneable ，我们将需要定义成原型的类实现这个接口就可以完成复制了。</p>
<p><strong>通过 cloneable 接口实现原型模式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graphics</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String color;<br>    <span class="hljs-keyword">private</span> String shape;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graphics</span><span class="hljs-params">(String color, String shape)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.color = color;<br>        <span class="hljs-keyword">this</span>.shape = shape;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Graphics <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        <span class="hljs-keyword">return</span> (Graphics) <span class="hljs-keyword">super</span>.clone();<br>    &#125;<br>    <br>    ..... set/get/toString<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的例子中，类中的对象类型都是基本类型，如果出现引用类型的时候，就会引发一个问题“浅克隆”，这会导致我们克隆出来的类会受原型中引用的类型影响，那我们如何才能规避这个问题做到“深克隆”呢​？</p>
<h2 id="浅克隆？🎭-深克隆？🎎"><a href="#浅克隆？🎭-深克隆？🎎" class="headerlink" title="浅克隆？🎭 深克隆？🎎"></a>浅克隆？🎭 深克隆？🎎</h2><p>浅、深指的是对对象的占有权利。比如我借给你一个手机，那你只能使用这个手机里现有的东西，我如果删除了一个软件，那你自然也就没有这个软件了。假如我送给你一个手机，那你就可以随便的使用，不用担心我会做什么了，因为这个手机就是你的了。</p>
<p>那在 java 代码中，我们怎么理解浅克隆🎭 、深克隆🎎 呢？</p>
<p>实现了 cloneable 接口，可以克隆一个区别于当前对象的另外一个新的对象，但对于对象中的引用，却不能进行克隆，你随得到了他的人，但你却得不到他的心，如果想要得到他的心怎么办？拿钱砸他！非也，你只要把他的心也克隆一份就可以了。但是前提是他的心允许克隆（实现了 cloneable 接口）。</p>
<h3 id="浅克隆代码"><a href="#浅克隆代码" class="headerlink" title="浅克隆代码"></a>浅克隆代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graphics</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String color;<br>    <span class="hljs-keyword">private</span> String shape;<br>    <span class="hljs-comment">// 引用类型没有实现 cloneable 接口</span><br>    <span class="hljs-keyword">private</span> Size size;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graphics</span><span class="hljs-params">(String color, String shape, Size size)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.color = color;<br>        <span class="hljs-keyword">this</span>.shape = shape;<br>        <span class="hljs-keyword">this</span>.size = size;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Graphics <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        <span class="hljs-keyword">return</span> (Graphics) <span class="hljs-keyword">super</span>.clone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 引用类型没有实现 cloneable 接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Size</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> width;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Size</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.width = width;<br>        <span class="hljs-keyword">this</span>.height = height;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Size(&quot;</span> + width + <span class="hljs-string">&quot;, &quot;</span> + height + <span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphicsTest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">graphicsTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        Size size = <span class="hljs-keyword">new</span> Size(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        Graphics graphics = <span class="hljs-keyword">new</span> Graphics(<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;circular&quot;</span>, size);<br>        Graphics clone = graphics.clone();<br>        size.height = <span class="hljs-number">3</span>;<br>        size.width = <span class="hljs-number">5</span>;<br>        System.out.println(<span class="hljs-string">&quot;graphics = &quot;</span> + graphics);<br>        <span class="hljs-comment">// 判断两个对象是否不同</span><br>        Assertions.assertNotSame(graphics, clone);<br>        clone.setColor(<span class="hljs-string">&quot;blue&quot;</span>);<br>        clone.setShape(<span class="hljs-string">&quot;square&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;clone = &quot;</span> + clone);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意此时的引用对象 size 的值</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">graphics = Graphics[color=&#x27;red&#x27;, shape=&#x27;circular&#x27;, size=Size(5, 3)]<br>clone = Graphics[color=&#x27;blue&#x27;, shape=&#x27;square&#x27;, size=Size(5, 3)]<br></code></pre></td></tr></table></figure>



<h3 id="深克隆：引用类型也实现-Cloneable-接口"><a href="#深克隆：引用类型也实现-Cloneable-接口" class="headerlink" title="深克隆：引用类型也实现 Cloneable 接口"></a>深克隆：引用类型也实现 Cloneable 接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 引用类型实现了 cloneable 接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Size</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> width;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Size</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.width = width;<br>        <span class="hljs-keyword">this</span>.height = height;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Size <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        <span class="hljs-keyword">return</span> (Size) <span class="hljs-keyword">super</span>.clone();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Size(&quot;</span> + width + <span class="hljs-string">&quot;, &quot;</span> + height + <span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在原型类中调整 clone 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Graphics <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>    Graphics clone = (Graphics) <span class="hljs-keyword">super</span>.clone();<br>    clone.size = size.clone();<br>    <span class="hljs-keyword">return</span> clone;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphicsTest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">graphicsTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        Size size = <span class="hljs-keyword">new</span> Size(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        Graphics graphics = <span class="hljs-keyword">new</span> Graphics(<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;circular&quot;</span>, size);<br>        Graphics clone = graphics.clone();<br>        size.height = <span class="hljs-number">3</span>;<br>        size.width = <span class="hljs-number">5</span>;<br>        System.out.println(<span class="hljs-string">&quot;graphics = &quot;</span> + graphics);<br>        <span class="hljs-comment">// 判断两个对象是否不同</span><br>        Assertions.assertNotSame(graphics, clone);<br>        clone.setColor(<span class="hljs-string">&quot;blue&quot;</span>);<br>        clone.setShape(<span class="hljs-string">&quot;square&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;clone = &quot;</span> + clone);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意此时的引用对象 size 的值</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">graphics = Graphics[color=&#x27;red&#x27;, shape=&#x27;circular&#x27;, size=Size(5, 3)]<br>clone = Graphics[color=&#x27;blue&#x27;, shape=&#x27;square&#x27;, size=Size(1, 2)]<br></code></pre></td></tr></table></figure>

<p>完整代码  <a href="https://github.com/lvgocc/java-design-patterns/tree/main/prototype">https://github.com/lvgocc/java-design-patterns/tree/main/prototype</a></p>
<h2 id="原型模式自身有什么优势和问题呢？"><a href="#原型模式自身有什么优势和问题呢？" class="headerlink" title="原型模式自身有什么优势和问题呢？"></a>原型模式自身有什么优势和问题呢？</h2><p><strong>优势：</strong></p>
<ol>
<li>JDK 的 cloneable 接口是基于内存数据的直接复制，速度相较于 new 关键字创建对象更加快速；同时简化了创建过程（不会执行构造方法）。</li>
<li>通过<strong>深克隆</strong>来保存一个对象某一时刻的状态，便于还原，实现撤销操作；</li>
</ol>
<p>问题：</p>
<ol>
<li>需要为每个类重写 #clone 方法；</li>
<li>深克隆需要将每个对象都维护一个 cloneable 接口；</li>
<li>构造方法中的代码不会执行；</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当我们需要频繁使用一些类似的对象的时候，可以考虑使用原型模式来降低资源的开销，使资源得到合理的分配和使用。而对于原型模式的深克隆带来的弊端，就显得那么的不重要了。</p>
<ol>
<li>类似的对象使用频繁，考虑原型模式</li>
<li>深克隆时注意类中的引用类型是否实现了 cloneable 接口</li>
<li>注意构造函数中是否有必要代码要执行，可以考虑放到 #clone 方法中执行</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程事务死锁问题分析总结(生产问题)</title>
    <url>//post/note-production-dead-lock.html</url>
    <content><![CDATA[<h3 id="实战回顾"><a href="#实战回顾" class="headerlink" title="实战回顾"></a>实战回顾</h3><p>2018年11月28日 有两个客户在两个渠道购买了同一产品每人各买2笔<br>系统应在29日做成交处理, 成交结束后, 更新一张记录表, 记录表根据产品代码和渠道代码作为Unique.<br>成交使用已客户为维度的多线程成交.<br>// 方法名为虚拟捏造, 并非实际使用方法名<br>成交方法 chengjiao() 为独立事务;<br>chengjiao() 方法内使用多线程的嵌套事务 NESTED doChengjiao()</p>
<a id="more"></a>

<p> 伪代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 独立事务</span><br>chengjiao() &#123;<br>	<span class="hljs-comment">// 根据客户查出交易</span><br>	List&lt;Trade&gt; lists = getTradeList();<br><br>	<span class="hljs-keyword">new</span> Thread ... (list);<br>&#125;<br><br><span class="hljs-comment">// 嵌套事务</span><br>doChengjiao();<br></code></pre></td></tr></table></figure>
<p>假如数据为 渠道 001 产品 002   渠道 002 产品 002<br>那更新的记录两条线程都要取更新表里面更新 001&amp;002记录 和 002&002;<br>但是问题出在线程的执行顺序;<br>两个客户每个人在不同渠道买了一笔, 一共四笔交易记录;<br>线程A先去更新了 001 &amp; 002 这条记录<br>线程B先去更新了 002 &amp; 002 这条记录<br>之后<br>线程B又去更新 001 &amp; 002 这条记录; (问题在这已经出现)<br>线程A去更新 002 &amp; 002 这条记录;</p>
<p>后续的线程B在更新的时候, 在等待这条记录之前的UPDATE事务提交或回滚, 而在占用这条记录的线程A想要提交需要等待002 &amp; 002 这条记录提交或回滚, 而002 &amp; 002这条记录正好被B线程占用, 由此造成了互相等待, 将更新表锁住.后续交易无法进行.后经人为干预(数小时后发现), 杀掉其中一条会话, 导致该会话数据回滚, 而另一个会话因为数据库等待时间过长, 数据也没有进行提交, 最后导致4笔交易全部回滚. 如果问题出在这也就没什么. 问题是每天这几笔交易都恰巧同时执行.就一直卡死. 最后在12月3号, 4笔交易成交了. 4个工作日.问题影响…….. 客户是拒绝的… 不过好在客户大度, 没有计较. .. .. </p>
<p>至此将问题从生产日志取下, 分析, 复现, 解决,重新上线 共计 2周+, 期间对spring事务感悟颇深. 遂总结此文章.  整理, 学习. </p>
<hr>
<h1 id="Sring-事务管理"><a href="#Sring-事务管理" class="headerlink" title="Sring 事务管理"></a>Sring 事务管理</h1><h4 id="首先来看事务的四个特性"><a href="#首先来看事务的四个特性" class="headerlink" title="首先来看事务的四个特性:"></a>首先来看事务的四个特性:</h4><ol>
<li>原子性<blockquote>
<p>事务的执行将事务内所做的操作看做一个整体, 要么全部执行, 要么全部不执行.</p>
</blockquote>
</li>
<li>隔离性 (可能导致死锁)<blockquote>
<p>简单来说, 两个事务在同时进行更新时,一个事务在更新, 另一个事务需要操作时,不可能看到这条记录之前的值, 需要等到之前的事务要么执行(事务提交),要么不执行(事务回滚). 才可以继续对该记录进行操作. 这也是事务的其中一个隔离级别, 也是默认最优隔离级别  READCOMMITED 读已提交;</p>
</blockquote>
</li>
<li>一致性<blockquote>
<p>对于同处在一个事务中的数据而言. 需要保持所有的相关数据保持一致状态, 当事务执行完以后也要保持相关全部数据的正确性</p>
</blockquote>
</li>
<li>持久性<blockquote>
<p>简单来说, 事物的提交之后的数据保存到数据库中, 进行持久化处理;</p>
</blockquote>
</li>
</ol>
<h4 id="事务的4个隔离级别"><a href="#事务的4个隔离级别" class="headerlink" title="事务的4个隔离级别"></a>事务的4个隔离级别</h4><table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读操作未提交</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>读操作已提交</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>可重读</td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
</tr>
<tr>
<td>串行化</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody></table>
<h4 id="事务的7个传播机制"><a href="#事务的7个传播机制" class="headerlink" title="事务的7个传播机制"></a>事务的7个传播机制</h4><ol>
<li>REQUIRED：        如果存在一个事务，支持当前事务。如果没有事务则开启</li>
<li>SUPPORTS：        如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行</li>
<li>NOT_SUPPORTED：    总是非事务地执行，并挂起任何存在的事务(不使用事务)</li>
<li>NESTED：            如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务,  REQUIRED 属性执行</li>
<li>REQUIRES_NEW：    总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起(自己一个事务,独立事务)</li>
<li>NEVER：             总是非事务地执行，如果存在一个活动事务，则抛出异常(必须由非事务的方法调用)</li>
<li>MANDATORY：        如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常(必须由带有事务的方法来调用)</li>
</ol>
<p><strong>画重点</strong></p>
<p>spring的事务管理中, 让我们容易出现问题的几个传播约定</p>
<ol>
<li>REQUIRED </li>
<li>NESTED</li>
</ol>
<p>1是默认传播机制, 2是嵌套传播机制;<br>REQUIRED 如果你没有, 我就自己管自己, 如果有, 就用你的;<br>NESTED 如果有, 我就听你的, 如果没有, 我就按照默认的走;</p>
<p><strong>举例说明:</strong><br>fun1() 方法1 <strong>是一个带事务的方法</strong>, 我们将使用fun1()来调用, fun2(), 此时的方法2 fun2()我们在配置事务的时候 </p>
<ol>
<li>配置了一个 REQUIRED , 那么此时的fun2()支持fun1()的事务, 与fun1() 事务相同, 你是什么事务, 我就是什么事务.</li>
<li>配置了一个NESTED, 那么这个时候的fun2() 则是存在fun1()的事务之中, 而不是另起一个事务的存在. 他的提交与回滚, 与 fun1() 共存, fun1() 提交, 我就提交, fun1()回滚, 我就回滚;</li>
</ol>
<p>当fun1() 方法1 <strong>不是一个带事务的方法</strong> , 此时 REQUIRED 与 NESTED 意义相同; 都将自身新启事务. 独立提交或回滚;</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>并发机制的底层实现原理</title>
    <url>//post/java-juc-theory.html</url>
    <content><![CDATA[<h1 id="Java-并发机制的底层实现原理"><a href="#Java-并发机制的底层实现原理" class="headerlink" title="Java 并发机制的底层实现原理"></a>Java 并发机制的底层实现原理</h1><blockquote>
<p>Java 代码在编译后会变成 Java 字节码, 字节码被类加载器加载到 JVM 里, JVM 执行字节码, 最终需要转化成为汇编指令在 CPU 上执行, Java中所使用的并发机制依赖于 JVM 的实现和 CPU 的指令 . </p>
</blockquote>
<a id="more"></a>

<h2 id="volatile-的应用"><a href="#volatile-的应用" class="headerlink" title="volatile 的应用"></a>volatile 的应用</h2><p>volatile 是轻量级的 synchronize , 它可以保证变量在多线程环境的”可见性”,  “可见性”是指当一个线程修改了共享变量, 另一个线程能够读到这个修改的值. (根据缓存一致性实现) 和 禁止指令重排序, 但它不是并发安全的.</p>
<p>在多线程场景下 并发的自增</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> variable = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * variable++这样的操作不是一个原子性操作，</span><br><span class="hljs-comment"> * 它分为读、加加、写。</span><br><span class="hljs-comment"> * 以下这种情况，</span><br><span class="hljs-comment"> * 当线程1读取了variable的值，还没有修改，</span><br><span class="hljs-comment"> * 线程2也读取了，线程1修改完了，</span><br><span class="hljs-comment"> * 通知线程2将线程的缓存的variable的值无效需要重读，</span><br><span class="hljs-comment"> * 可这时它不需要读取variable，它仍执行写操作，</span><br><span class="hljs-comment"> * 然后赋值给主线程，这时数据就会出现问题。</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>



<h3 id="CPU-术语"><a href="#CPU-术语" class="headerlink" title="CPU 术语"></a>CPU 术语</h3><table>
<thead>
<tr>
<th align="center">术语</th>
<th align="center">英文</th>
<th align="left">术语描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">内存屏障</td>
<td align="center">memory barriers</td>
<td align="left">是一组处理器指令, 用于实现对内存操作的顺序限制</td>
</tr>
<tr>
<td align="center">缓冲行</td>
<td align="center">cache line</td>
<td align="left">缓存中可以分配的最小存储单位. 处理器填写缓存线时会加载整个缓存线, <br />需要使用多个主内存读周期</td>
</tr>
<tr>
<td align="center">原子操作</td>
<td align="center">atomic operations</td>
<td align="left">不可中断的一个或一系列操作</td>
</tr>
<tr>
<td align="center">缓存行填充</td>
<td align="center">cache line fill</td>
<td align="left">当处理器识别到从内存中读取操作数是可缓存的, <br />处理器读取整个缓存行到适当的缓存(L1,L2,L3的或所有)</td>
</tr>
<tr>
<td align="center">缓存命中</td>
<td align="center">cache hit</td>
<td align="left">如果进行告诉缓存行填充操作的内存地址仍然是下次处理器访问的地址时, <br />处理器从缓存中读取操作数, 而不是从内存读取</td>
</tr>
<tr>
<td align="center">写命中</td>
<td align="center">write hit</td>
<td align="left">当处理器将操作数协会到一个内存缓存的区域时, <br />它首先会检查这个缓存的内存地址是否在缓存行中, 如果存在一个有效的缓存行<br />则处理器将这个操作数写回到缓存, 而不是写回到内存, 这个操作被称为写命中</td>
</tr>
<tr>
<td align="center">写缺失</td>
<td align="center">write misses the cache</td>
<td align="left">一个有效的缓存行被写入一个不存在的内存区域.</td>
</tr>
</tbody></table>
<h3 id="volatile-的底层实现"><a href="#volatile-的底层实现" class="headerlink" title="volatile 的底层实现"></a>volatile 的底层实现</h3><p>书中作者记录了实际操作后到汇编指令阶段的代码, 可以发现使用 volatile 修饰的变量在转变成汇编指令时 , 多了一个前缀 <code>lock</code>,  关于lock指令, 在多核处理器中会引发两个事情</p>
<ol>
<li>将当前处理器缓存行的数据写回到系统内存(在这一步操作时, 会锁定这块内存的缓存区域)</li>
<li>写回内存的操作会使其他CPU里缓存了该内存地址的数据无效</li>
</ol>
<p>这样就保证了 volatile 修饰的变量的”可见性” , 缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据.</p>
<blockquote>
<p>扩展内容 : 对于 volatile 的底层实现, 在不同的硬件上实现不同, 在 intel486 和 pentium 处理器上会在总线上声明 lock# 信号, 相反在P6处理器中, 如果访问的数据已经缓存在处理器内部, 再不会声明 lock# 信号, 它会锁定这块区域的缓存.</p>
</blockquote>
<h2 id="synchronized-的应用和原理"><a href="#synchronized-的应用和原理" class="headerlink" title="synchronized 的应用和原理"></a>synchronized 的应用和原理</h2><p>synchronized 的三种使用场景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 普通方法 , 锁是当前类的实例对象</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">syncMethod</span><span class="hljs-params">()</span></span>&#123;<br><br>&#125;<br><br><span class="hljs-comment">// 静态方法, 锁是当前类的 Class 对象</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">staticSyncMethod</span><span class="hljs-params">()</span></span>&#123;<br><br>&#125;<br><br><span class="hljs-comment">// 代码块 , 锁是括号内对象</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">innerSyncMethod</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>以下摘自书中内容:</strong></p>
<p>当一个线程视图访问同步代码块时, 它首先必须得到锁. 退出或抛出异常必须释放锁, JVM基于进入和退出 Monitor 对象来实现方法同步和代码块同步.</p>
<p>代码块和方法都可以使用的 monitor enter 指令和 monitor exit 指令实现 . </p>
<p>在代码编译后, 会在同步方法或同步方法块前插入 monitor enter , 将 monitor exit 插入异常或方法结束处, 一个 monitor enter 必须有一个 monitor exit 对应.</p>
<p>每一个对象都会有一个 monitor 与其关联,  线程执行到 monitor enter 指令时, 将会尝试获得 monitor 的所有权, 即尝试获取锁, 当 monitor 被持有后, 它将处于锁定状态 . </p>
<p><strong>锁在哪里?</strong></p>
<p>synchronized 的锁是保存在 Java 对象头里面的, 那对象头里都存了什么呢?</p>
<h3 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a>Java 对象头</h3><p>Java 中每个对象都有一个对象头, 数组比较特殊, 会有单独的一块区域(ArrayLength)保存数组的长度, 需要 4个字节 32bit 的长度空间来保存, 普通对象则需要 2 个字宽来保存 对象类型数据指针, hashcode , 锁, 分代年龄 (MarkDown)</p>
<p>markdown的分布示意图</p>
<p><img src="/images/posts/java-juc-theory/20200810203529454.jpg" alt="对象头"></p>
<h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p>在JDK 1.6 对锁的获取和释放做了优化调整, 增加了 “偏向锁” 和 “轻量级锁” , 而锁一共有 4 种状态 </p>
<ul>
<li>无锁</li>
<li>偏向锁</li>
<li>轻量级锁</li>
<li>重量级锁</li>
</ul>
<p>锁只能升级不能降级, 目的是为了提高获得和释放锁的效率</p>
<h3 id="1-偏向锁"><a href="#1-偏向锁" class="headerlink" title="1. 偏向锁"></a>1. 偏向锁</h3><p>当一个线程访问同步代码块并获取到锁后, 会在对象头和栈帧(<em>栈帧</em>是一个内存区块,是一个数据集,是一个有关方法(Method)和运行期数据的数据集)中的锁记录存储锁偏向的线程ID, 以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁 , 只需要判断一下锁记录里面保存的锁偏向线程ID, 与当前线程相同即得到锁, 否则根据对象头中 MarkDown 是否设置了偏向锁标识(1) , 使用CAS将锁偏向线程ID指向当前线程, 否则使用 CAS 来竞争锁.</p>
<p>**偏向锁的撤销(释放)是在等到其他线程在做锁竞争的时候才会去做. **</p>
<p>一旦发生了锁竞争, 首先等待安全点, 将暂停持有锁的线程, 在判断该线程是否存活, 如果不活动, 直接释放, 将对象头改为无所状态.</p>
<p>如果当前线程没执行完, 还在执行, 另一个线程来尝试获取偏向锁, 此时一定是失败. 接下来会继续执行, 首先将正在进行中的线程暂停, 然后将对象头标记为不适用偏向锁, 将偏向锁撤销, 此时锁升级为轻量级锁, 恢复暂停线程.</p>
<p><strong>总结:</strong>  适用在低级锁竞争</p>
<h3 id="2-轻量级锁"><a href="#2-轻量级锁" class="headerlink" title="2. 轻量级锁"></a>2. 轻量级锁</h3><p>线程在执行到同步代码块时,  JVM首先会在当前线程的栈帧中创建用于保存锁记录的空间, 并将对象头 MarkDown 复制到锁记录中(官方称为Displaced Mark Word), 然后线程尝试使用 CAS 将对象头中的 MarkDown 替换为指向锁记录的指针, 如果成功, 获的锁. 如果失败, 使用 自旋锁 获取锁.</p>
<p><strong>轻量级锁的释放</strong></p>
<p>将复制出来的 Displaced Mark Word 替换回对象头的 MarkDown 如果成功, 锁释放成功, 如果失败, 说明当前锁存在竞争, 升级为重量级锁.</p>
<h3 id="3-重量级锁"><a href="#3-重量级锁" class="headerlink" title="3. 重量级锁"></a>3. 重量级锁</h3><p>当升级为重量级锁, 其他线程想要获取锁时, 只有被阻塞. 等待锁释放, 唤醒等待的线程, 进行新一轮的锁竞争.</p>
<h2 id="锁比较"><a href="#锁比较" class="headerlink" title="锁比较"></a>锁比较</h2><table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁解锁不需要额外的消耗,<br />和无锁状态差距纳秒级别</td>
<td>线程存在竞争会带来额外消耗</td>
<td>只有一个线程访问同步代码块</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞, 提高了性能</td>
<td>始终得不到锁的线程会自旋浪费CPU</td>
<td>追求响应速度, 代码块执行速度快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程不会自旋, 不会浪费CPU</td>
<td>线程阻塞, 响应时间慢</td>
<td>追求吞吐量, 同步代码块执行时间长</td>
</tr>
</tbody></table>
<p><strong>小结:</strong></p>
<p>除了偏向锁, JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</p>
<p>java 中的原子性通过锁和CAS来实现.</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发的两个&#39;老&#39;问题</title>
    <url>//post/java-juc-twooldproblem.html</url>
    <content><![CDATA[<h1 id="并发的两个‘老’问题"><a href="#并发的两个‘老’问题" class="headerlink" title="并发的两个‘老’问题"></a>并发的两个‘老’问题</h1><p>上一篇文章我们认识了什么是并发编程，随着并发编程而来的则是并发带来的各种问题，死锁和资源问题，那这一篇我们继续跟着作者去看一看这两个‘老‘问题。</p>
<a id="more"></a>

<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><blockquote>
<p>我理解的死锁是指 “无外界条件干预无法自行解决的一种状态”</p>
</blockquote>
<p>这种状态一旦出现会导致程序逻辑问题，资源占用问题等很严重的问题。</p>
<p>下面这段代码截自书中的代码, 演示了死锁的场景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLockDemo</span> </span>&#123;<br>    privat <span class="hljs-keyword">static</span> String A = <span class="hljs-string">&quot;A&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String B = <span class="hljs-string">&quot;B&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>              <span class="hljs-keyword">new</span> DeadLockDemo().deadLock();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deadLock</span><span class="hljs-params">()</span> </span>&#123;<br>              Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function">publicvoid <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                                  <span class="hljs-keyword">synchronized</span> (A) &#123;<br>                                          <span class="hljs-keyword">try</span> &#123; Thread.currentThread().sleep(<span class="hljs-number">2000</span>);<br>                                          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                                                    e.printStackTrace();<br>                                          &#125;<br>                                          <span class="hljs-keyword">synchronized</span> (B) &#123;<br>                                                    System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>                                          &#125;<br>                                  &#125;<br>                        &#125;<br>              &#125;);<br>              Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function">publicvoid <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                                  <span class="hljs-keyword">synchronized</span> (B) &#123;<br>                                          <span class="hljs-keyword">synchronized</span> (A) &#123;<br>                                            System.out.println(<span class="hljs-string">&quot;2&quot;</span>);<br>                                    &#125;<br>                          &#125;<br>                &#125;<br>      &#125;);<br>      t1.start();<br>      t2.start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>当出现死锁的时候, 线上的业务是可以反馈出来的, 同时我们通过线程 dump 是可以查询到具体的死锁地方.</p>
<p>当我们知道什么是死锁问题后, 那就应该在开发阶段首先去考虑并且避免这种场景</p>
<ul>
<li>避免一个线程获取多个锁</li>
<li>避免一个线程在锁内占用多个资源</li>
<li>如果可以的话尝试使用 tryLock(time) 定时锁</li>
<li>数据库锁, 加锁和解锁在一个连接, 否则可能出现解锁失败</li>
</ul>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>什么是资源，对于软件程序来说资源就是</p>
<ul>
<li>网络带宽</li>
<li>内存容量</li>
<li>cpu</li>
<li>······</li>
</ul>
<p><strong>问</strong> ：那什么情况会出现资源问题呢？</p>
<p><strong>答</strong> ：不合理的分配情况下</p>
<p>怎么做才能做到合理分配是我们在做程序设计时需要考虑的，比如软件运行的网络环境，磁盘大小，内存大小，系统的cpu能力、核心数等等</p>
<p>一般在资源分配上遵循两种任务情况来决定，1 是 IO密集型任务 2 是 CPU密集型任务。再简单一点就是你的任务是需要数据的还是需要计算的。需要数据的就是IO，需要计算的就是CPU， 根据这两种情况来指定我们的资源分配。推荐一篇文章<a href="https://blog.csdn.net/youanyyou/article/details/78990156">https://blog.csdn.net/youanyyou/article/details/78990156</a></p>
<p>合理的资源分配，可以将系统的性能发挥的更好，反之更坏。所以线程不是创建的越多越好。</p>
<p>线程池的线程复用，根据资源合理的分配线程数，都可以帮我们有效的解决资源问题。线程数的大小设置。</p>
<p><strong>建议</strong></p>
<p>CPU密集型任务，最佳线程数设置为 CPU数+1</p>
<p>IO密集型任务， 最佳线程数目 = （（线程等待时间 + 线程CPU时间）/ 线程CPU时间 ）* CPU数目 </p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>开启人生的沉淀篇章</title>
    <url>//post/precipitate.html</url>
    <content><![CDATA[<p><img src="/images/posts/precipitate/202069183809.jpg" alt="`程序`人生"></p>
<p>“做任何事, 都要有所收获. 即使是你呼吸了一口空气, 你也应该知道, 这口空气使你舒坦. —— LVGO”</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title>机遇，奇遇</title>
    <url>//post/opportunity.html</url>
    <content><![CDATA[<p><img src="/images/posts/opportunity/opportunity.jpg"></p>
<p>食用前请把诸如虚伪、嫉妒、讽刺等类似的词语从你的脑袋里面扣掉。</p>
<a id="more"></a>

<h3 id="《机遇，奇遇》"><a href="#《机遇，奇遇》" class="headerlink" title="《机遇，奇遇》"></a>《机遇，奇遇》</h3><blockquote>
<p>食用前请把诸如虚伪、嫉妒、讽刺等类似的词语从你的脑袋里面扣掉。</p>
</blockquote>
<p>幸存者偏差让我知道了死人不会说话. 活人的话你只可以信一半. 内容的虚实自己要学会辨识, 不然你终将成为这个时代的垫脚石.</p>
<p>整个社会的发展也离不开听信幸存者言论的”粉丝”, </p>
<p>我不是智者, 也不是圣人, 我也是这个社会发展中幸存者的”粉丝”, 也是这个时代的垫脚石, 在帮助这个时代发展, 但是不同的时, 我能写出这段话, 就说明我知道我是.而有很多人, 他(她)不知道.</p>
<p>可能上面说的很难让你看懂, 举几个例子可能你就很清楚了. 注意这里说的是可能. 如果你准备好了键盘, 开启了杠精模式. 那你可以随便评论一下然后×掉窗口, 去任何地方吐槽我好了.</p>
<h4 id="例一-成功者的演讲"><a href="#例一-成功者的演讲" class="headerlink" title="例一:  成功者的演讲"></a>例一:  成功者的演讲</h4><p>老干妈、朱老六、美的、联想、奥迪、腾讯…… 太多太多, 没错, 他们都是成功者, 他们是活人, 他们可以讲话. </p>
<blockquote>
<p>王健林 : “先赚他1个亿!”</p>
</blockquote>
<p>他们都不是普通人, (别杠,自己想) 如果是普通人就不会在20世纪90年代家里拿50万给他去创业, 可能这个数字有偏差, 及时缩小到10万, 在那个年代什么概念?比上21世纪现在的1千万也毫不过分.</p>
<p>杠精会说那他的父母也很厉害啊, 天赋在那呢, 等等类似的话, 这些我都不觉得有问题, 而且我认为你说的很对, 他们父母聪明有天赋, 会赚钱,  孩子成为富二代. 很合理.</p>
<p>但我认为这些都是说不通的, 只有一个事情可以说的通, 那就是这一切只能说明他家人的思想很纯粹, 很正直. 其他的可能性很小.</p>
<hr>
<p>每个成功者都喜欢把”鲜艳”的一面展示出来, 为什么不把我们想要的真实的事情说出来呢？</p>
<blockquote>
<p>“我那个时候在<strong>, 每天</strong>, 刚开始<strong>__, 后来___. 我认为_</strong>, 坚持___,其实____, 每个人____”.</p>
</blockquote>
<p>“成功者”再说这些的时候, 就像老师在教学生.</p>
<p>为什么教育都在教你对的事情? 为什么教育不去教我们错的事情? 只要不会造成不可逆的结果, 我个人拙见都是可以做的. 即使社会发展的大背景下. 人的好奇心得不到满足就会自己去尝试做一些无法想象和理解的事情. 人性就由此变得不同. </p>
<p>“成功者”都在说成功之后的事情. 我也更相信天赋异禀的旷世奇才. 但更多的我更愿意去相信人, 生来就很优秀. 你没有成功是因为你没有得到那个机会, 哪个机会? 每一个机会, 包括你眼前的这一个, 一个个机会的错失, 一个个机会”被错失”</p>
<p>你可以说这个社会不公平吗? 为什么我没有生在开国元勋的家庭? 为什么我没有被经济规划规划到?为什么改革开放没改革到我头上?为什么班长不是我?</p>
<p>你不能, 因为这是社会的发展潜移默化的过程. 这看似不公平的事情, 恰恰是公平的. 当然如果这些事放到你头上你能不能行? 我认为90%的人都是行的, 剩下的10%是自己不想做.</p>
<p>王健林给你5个亿叫你去创业你觉得你行不行? 不用想你肯定行, 因为王健林是你”爹”, 我并不是说国民老公谁都可以, 就像上面我说的, 你必须思想要可以, 你才可以, 王健林会教你先迈哪只脚, 再迈哪只脚. 最后你可以走了, 他任务就完成了. </p>
<p>那当初教王建林走路的是谁呢? 可能是他的父亲, 也有可能是祖国这个伟大的母亲, 总而言之, 王健林没有让帮助他的人们失望.</p>
<p>你出生的时候听着音乐出生, 每天听着 do ri mi fa so la si (不懂音乐, 也不想查), 你怎么跟我说你不会唱歌. 这是耳濡目染, 我小的时候跟人家扣土和泥巴, 我怎么可能会唱歌, (呵呵, 民间歌手多了去了, 自己不行就在这喷喷喷), 你们说的都对, 那么多民间歌手很厉害啊, 所以你知道这个了, 那你就知道什么是活人了. 在普通家庭100个人里面有1个人会唱歌你觉得很正常, 其他的99个正常人在你眼里被你”不知情”的情况下忽略掉.</p>
<p>人们只对光鲜亮丽的事物更关注. 这不怪你, 也不怪我.</p>
<p>说的这么多要说的只是一个事情, 就是不是你不行, 而是你没有那个机遇.不要觉得真的机会来了我行不行, 不用怀疑, 只要你的思想没问题, 机会来了, 你自然会把住, 而你也一样能行. </p>
<p>就像有的人你给了他很多机会, 他做了一阵就没有结果了, 或者做的没有预期的结果好, 那不能说他不行, 只是因为他的思想不行, 而帮助他的人, 要么”拿钱办事”, 要么他也是被别人”拿钱办事”. 你应该看得懂这句话的意思.</p>
<p>老先生看人不会看错, 那看老先人的人也一定是一位老先生.</p>
<p>最近仝卓的事情也可以说明这个事情. 他的思想不行, 被搬了上来, 结果自己就翻下去了, 还有很多像仝卓一样被搬上来的人, 但是思想跟上了, 自然也就能站稳了, 但至于怎么搬上来的, 没人关心. 可能遇到”老先生”, 也可能是百分之一的他, 不过这些都不重要了.</p>
<blockquote>
<p>奇遇是我玩的一款游戏中的一种特殊奖励, 这个东西很有意思, 做, 每个人都知道应该怎么去做, 难的是触发它.</p>
</blockquote>
<p>机遇, 奇遇.</p>
<h4 id="例二-互联网的化装舞会"><a href="#例二-互联网的化装舞会" class="headerlink" title="例二 : 互联网的化装舞会"></a>例二 : 互联网的化装舞会</h4><blockquote>
<p>化装舞会是欧美上流社会在公司年会或大型庆功会、时尚派对上的一种安排，常是需要戴面具或者伪装方可参加。</p>
</blockquote>
<p>你在互联网搜索讯息就像参加一场化妆舞会. </p>
<p><code>你好, 我是XXX</code></p>
<p><code>&lt;近日, 在xxx发现一条神龙, 究竟是怎么回事&gt;</code></p>
<p>对未知事物不要只有好奇心理, 还要保持怀疑心态, 你才能有所收获. 或避免不必要的麻烦或损失.</p>
<p>网络骗子, 新闻标题, 消息虚实. 永远都要持怀疑心态, 你才能做局外人. 否则只能成为这个时代的垫脚石. 这些人既可悲也可怜.同时也很伟大. 如果没有这群人, 这个社会就不会发展. 有人骗人, 就有人上当. 这不用怀疑.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">今天我给大家表演一个铁锅炖自己....<br><br>明天全国飞机消毒, 收好衣物, 避免外出.....<br><br>遇到点急事, 给我转<span class="hljs-number">500</span>元, 晚点我......<br><br>原来疫情源头在这里.....<br></code></pre></td></tr></table></figure>


<p>这种讯息就是很典型的污浊的信息, 你可能会说, 这谁还不知道啊. 我一看就是假的.</p>
<p>举一反三, 希望你明白的收获的更多.</p>
<p>当然说怀疑是该怀疑的怀疑, 不该怀疑的就不要乱揣测, 这中间的临界值, 就各位酌情判断了. 多些少些, 都值得.</p>
<p>化装舞会, 你要学会看清伪装的事物, 即使它就在你眼前.</p>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习笔记（一）《快速排序》</title>
    <url>//post/algorithm-quick-sort-1.html</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote>
<p>本文学习内容来自《算法图解》一书及百度百科内容</p>
</blockquote>
<p>算法是一组完成任务的指令。任何代码片段都可视为算法。  —— 摘自《算法图解》</p>
<hr>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote>
<p><a href="https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/369842?fr=aladdin&fromid=612251&fromtitle=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%B3%95">以下内容摘自百度百科</a><br>快速排序（Quicksort）是对冒泡排序的一种改进。<br>快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
</blockquote>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><blockquote>
<p>分而治之（divide and conquer， D&amp;C）一种著名的递归式问题解决方法。</p>
</blockquote>
<p><strong>这里有个问题，请读者思考一下</strong></p>
<p>假如你是一个农场主，现在你有一块土地，想要给它均匀的分成大小相同的方块。<br><img src="/images/posts/algorithm-quick-sort-1/20180518115105443.png" alt="lvgo star dust">  </p>
<p>如果要你来均匀的分开成一个个小方块你会怎么做？ 像下面这样？</p>
<p><img src="/images/posts/algorithm-quick-sort-1/20180518115307930.png" alt="lvgo star dust">  </p>
<p>显然这是愚蠢的，也是不可能的。那我们应该怎么样去做呢？<br>这里就用到了我们上面提到的<strong>D&amp;C策略</strong> ，D&amp;C策略是使用递归的，解决这个分成两个步骤：</p>
<ol>
<li>找到基准条件，这个条件，必须尽可能的简单。</li>
<li>竟可能的缩短范围找到基准，将给定条件不断缩小范围。</li>
</ol>
<hr>
<h4 id="1、我们先按照给定的宽度-640m-将长切成-640m-640m-400m-×-640m-大小的三块方块"><a href="#1、我们先按照给定的宽度-640m-将长切成-640m-640m-400m-×-640m-大小的三块方块" class="headerlink" title="1、我们先按照给定的宽度 640m 将长切成  ( 640m + 640m + 400m ) × 640m 大小的三块方块"></a>1、我们先按照给定的宽度 640m 将长切成  ( 640m + 640m + 400m ) × 640m 大小的三块方块</h4><p><img src="/images/posts/algorithm-quick-sort-1/20180518135554838.png" alt="lvgo star dust"><br>这样我们就得到了一个 400m × 640m 的小方块<br><img src="/images/posts/algorithm-quick-sort-1/20180518135906652.png" alt="lvgo star dust"></p>
<h4 id="2、再按照-400m-×-400m-分成-2-块"><a href="#2、再按照-400m-×-400m-分成-2-块" class="headerlink" title="2、再按照 400m × 400m 分成 2 块"></a>2、再按照 400m × 400m 分成 2 块</h4><p>640 m × 400 m的土地，可从中划出的最大方块为400 m × 400 m。 这样就会余下一个 400m × 240m 的一个方块。</p>
<p><img src="/images/posts/algorithm-quick-sort-1/20180518140447909.png" alt="lvgo star dust"></p>
<h4 id="3、我们在把余出的-400m-×-240m-切成-240m-×-240m-240m-×-160m"><a href="#3、我们在把余出的-400m-×-240m-切成-240m-×-240m-240m-×-160m" class="headerlink" title="3、我们在把余出的 400m × 240m 切成  240m × 240m +  240m × 160m"></a>3、我们在把余出的 400m × 240m 切成  240m × 240m +  240m × 160m</h4><p><img src="/images/posts/algorithm-quick-sort-1/20180518140807139.png" alt="lvgo star dust"></p>
<h4 id="4、以此类推"><a href="#4、以此类推" class="headerlink" title="4、以此类推"></a>4、以此类推</h4><p><img src="/images/posts/algorithm-quick-sort-1/20180518140832372.png" alt="lvgo star dust"></p>
<p><img src="/images/posts/algorithm-quick-sort-1/2018051814083991.png" alt="lvgo star dust"></p>
<p>最终我们找到了想要的小方块 80m × 80m 这样我们就把最初的  1680m × 640m 分成了 1680 个 80m × 80m 的小方块</p>
<p>以上讲述的只是一种解决问题的思路，也是D&amp;C策略的具体体现，那我们现在回顾一下解决问题的过程。</p>
<ol>
<li>我们拿到问题之后，是想要找到问题的基准条件。</li>
<li>紧接着我们把适应问题条件的范围不断的缩小。</li>
<li>在更小的范围去寻找我们想要的答案。</li>
</ol>
<p>其实我们在解决这个问题的时候，已经用到了一个算法，那就是<a href="https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E7%AE%97%E6%B3%95/9002848?fr=aladdin&fromid=1647675&fromtitle=%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">《欧几里德算法》</a>，具体大家可以查看百度百科即可</p>
<hr>
<h3 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h3><p>说了这么多，那如果是实际的问题我们该如何解决呢？</p>
<ul>
<li><strong>快速排序</strong>说的是怎么去给一个数组，或者列表进行一个有序的排列。<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果我们有这样一个数组</span><br><span class="hljs-keyword">int</span>[] ints = &#123;<span class="hljs-number">1</span>&#125;;<br><span class="hljs-comment">// 那我们说，这是不需要排序的，直接返回结果就可以</span><br>[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>


</li>
</ul>
<hr>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// 如果是有两个值呢</span><br><span class="hljs-built_in">int</span>[] <span class="hljs-built_in">int</span>s = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-comment">// 这个也很简单，只需要比较两个数值的大小即可</span><br><span class="hljs-string">[1, 2]</span><br></code></pre></td></tr></table></figure>
<hr>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// 如果是有三个值呢</span><br><span class="hljs-built_in">int</span>[] <span class="hljs-built_in">int</span>s = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-string">[?, ?, ?]</span><br><span class="hljs-comment">// 如果是有多个值呢</span><br><span class="hljs-built_in">int</span>[] <span class="hljs-built_in">int</span>s = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">23</span>, <span class="hljs-number">12</span>, <span class="hljs-number">34</span>, <span class="hljs-number">87</span>, <span class="hljs-number">45</span>, <span class="hljs-number">68</span>, <span class="hljs-number">15</span>&#125;;<br><span class="hljs-string">[?, ?, ?, ?, ?, ?, ?, ?]</span><br></code></pre></td></tr></table></figure>

<hr>
<p>同样我们使用的也是<strong>D&amp;C策略</strong>来解决这个问题，首先要找到一个基准条件。那我们说这个条件怎么去找？</p>
<p>先别急，我们来看最后一个数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] ints = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">23</span>, <span class="hljs-number">12</span>, <span class="hljs-number">34</span>, <span class="hljs-number">87</span>, <span class="hljs-number">45</span>, <span class="hljs-number">68</span>, <span class="hljs-number">15</span>&#125;;<br></code></pre></td></tr></table></figure>
<p>首先我们要做的事情很简单，找到一个基准条件，缩小我们的排序范围。无论多少个值，我们只进行两个值得比较。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> temp = <span class="hljs-built_in">int</span>s[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure>
<p>那我们说，temp 就是我们要的小范围的一个基准条件，所有的数字和这个基准条件去比较。那就变成了两个值得比较。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><br><span class="hljs-built_in">int</span>s [<span class="hljs-number">1</span>] = <span class="hljs-number">23</span>; <span class="hljs-comment">// 大于temp</span><br><span class="hljs-built_in">int</span>s [<span class="hljs-number">2</span>] = <span class="hljs-number">12</span>; <span class="hljs-comment">// 大于temp</span><br><span class="hljs-built_in">int</span>s [<span class="hljs-number">3</span>] = <span class="hljs-number">34</span>; <span class="hljs-comment">// 大于temp</span><br>...<br>...<br></code></pre></td></tr></table></figure>
<p> 比较的之后的值怎么办 ，我们把比较的值分成两组，要么大于基准值，要么小于等于基准值。大于的，我们放到基准值的右侧，小于等于的，我们放到基准值的左侧。并且，<strong>如果出现位置转换的时候，我们的基准值得位置是在跟着变动的</strong>。我们比较的顺序是从数组的第一个和数组最后一个进行比较。依次像中间靠拢。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们如果拿数组的第一个数字进行比较，那数组将会被分成两个部分</span><br><span class="hljs-comment"> * 要么大于1，要么小于等于1 </span><br><span class="hljs-comment"> * 结果数组会变成这个样子</span><br><span class="hljs-comment"> * [1, 23, 12, 34, 87, 45, 68, 15]</span><br><span class="hljs-comment"> * /</span><br></code></pre></td></tr></table></figure>
<p>看过之后你可能会有疑虑，这什么啊？怎么没有变化呢？是的，因为我们选取的基准值1，大于它的放到右侧，因为其它的数字全部大于1，所以我们放到了右侧。接下来再看。</p>
<blockquote>
<p>现在我们可以理解为，原来数组被拆成了两个数组<br>由原来的<code>[1, 23, 12, 34, 87, 45, 68, 15] </code><br>变成了现在的<code>[]</code>和<code>[23, 12, 34, 87, 45, 68, 15]</code></p>
</blockquote>
<p>其实看似没有变化，实则我们已经缩小了排序的范围，再一次我们需要对两个数组进行之前的方法进行计算<br>数组 <code>[23, 12, 34, 87, 45, 68, 15] </code>进行我们接下来的选取基准值，进行比较分开大小。因为我们的基准值选取的是23，所以 12 15 在 23 的左侧，其余的在 23 右侧，那具体的结果是什么样子的呢？</p>
<blockquote>
<p>同样的我们的数组被<code>[23]</code>分隔成了两部分<br>分成了<code>[15, 12]</code> <code>[87, 45,  68, 34]</code></p>
</blockquote>
<hr>
<p><strong>快速排序实现原理</strong><br>可能有的同学看到这里会有疑问，为什么 15 在 12 的左侧，这就是上面我们提到的比较之后改变数字位置的问题，我们开始比较的时候是 23 和 15 去比较，显然 15 比 23 小，所以它要放到 23 的左侧，那此时的 23 将会和 15 的位置互换，这样就达到了小的数字在基准值的左侧，当我们在拿基准值 23 和 左侧的数字比较的时候，23 比 12 大，保持不变，依次 23 比 34 小，此时由要进行位置互调。23 出现在了 34 的位置上，34 则在了 23 的位置上。重点来了，<strong>基准条件在做完一次基准值之后，不会再次参与后续排序。</strong></p>
<hr>
<p>此时我们又要对拆分出的数组进行比较</p>
<blockquote>
<p><code>[15, 12]</code> 用同样的基准值办法进行比较显然变成了<code>[12, 15]</code><br>而<code>[87, 45,  68, 34]</code> 则变成了 <code>[34, 45, 68, 87]</code> </p>
</blockquote>
<p>以此类推，我们的数组对应的变化如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>, <span class="hljs-number">23</span>, <span class="hljs-number">12</span>, <span class="hljs-number">34</span>, <span class="hljs-number">87</span>, <span class="hljs-number">45</span>, <span class="hljs-number">68</span>, <span class="hljs-number">15</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">23</span>, <span class="hljs-number">87</span>, <span class="hljs-number">45</span>, <span class="hljs-number">68</span>, <span class="hljs-number">34</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">23</span>, <span class="hljs-number">87</span>, <span class="hljs-number">45</span>, <span class="hljs-number">68</span>, <span class="hljs-number">34</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">23</span>, <span class="hljs-number">34</span>, <span class="hljs-number">45</span>, <span class="hljs-number">68</span>, <span class="hljs-number">87</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">23</span>, <span class="hljs-number">34</span>, <span class="hljs-number">45</span>, <span class="hljs-number">68</span>, <span class="hljs-number">87</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">23</span>, <span class="hljs-number">34</span>, <span class="hljs-number">45</span>, <span class="hljs-number">68</span>, <span class="hljs-number">87</span>]<br></code></pre></td></tr></table></figure>

<p>相信看到现在，多多少少大家已经掌握了快速排序法的原理。</p>
<ol>
<li>找到一个基准值</li>
<li>将其与数字与该基准值进行比较</li>
<li>比较成功后按大小，改变数字位置，基准值被隔离开来，用来连接数组。（这里比较抽象，需要一定的自行脑补）</li>
<li>对重新组成的数组再次进行 1 2 3 步骤</li>
</ol>
<hr>
<p>为了大家学习和调试方便，下面提供了快速排序的 java 和 python 的代码</p>
<p><strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] ints = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">23</span>, <span class="hljs-number">12</span>, <span class="hljs-number">34</span>, <span class="hljs-number">87</span>, <span class="hljs-number">45</span>, <span class="hljs-number">68</span>, <span class="hljs-number">15</span>&#125;;<br>    quickSort(ints, <span class="hljs-number">0</span>, ints.length - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] ints, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h = high;<br>    <span class="hljs-keyword">int</span> l = low;<br>    <span class="hljs-keyword">if</span> (l &lt; h) &#123;<br>        <span class="hljs-keyword">int</span> temp = ints[l];<br>        <span class="hljs-keyword">while</span> (l &lt; h) &#123;<br>            <span class="hljs-keyword">while</span> (l &lt; h &amp;&amp; ints[h] &gt; temp) &#123;<br>                h--;<br>            &#125;<br>            ints[l] = ints[h];<br>            <span class="hljs-keyword">while</span> (l &lt; h &amp;&amp; ints[l] &lt;= temp) &#123;<br>                l++;<br>            &#125;<br>            ints[h] = ints[l];<br>        &#125;<br>        ints[l] = temp;<br>        System.out.println(Arrays.toString(ints));<br>        quickSort(ints, low, h - <span class="hljs-number">1</span>);<br>        quickSort(ints, l+ <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>, <span class="hljs-number">23</span>, <span class="hljs-number">12</span>, <span class="hljs-number">34</span>, <span class="hljs-number">87</span>, <span class="hljs-number">45</span>, <span class="hljs-number">68</span>, <span class="hljs-number">15</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">23</span>, <span class="hljs-number">87</span>, <span class="hljs-number">45</span>, <span class="hljs-number">68</span>, <span class="hljs-number">34</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">23</span>, <span class="hljs-number">87</span>, <span class="hljs-number">45</span>, <span class="hljs-number">68</span>, <span class="hljs-number">34</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">23</span>, <span class="hljs-number">34</span>, <span class="hljs-number">45</span>, <span class="hljs-number">68</span>, <span class="hljs-number">87</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">23</span>, <span class="hljs-number">34</span>, <span class="hljs-number">45</span>, <span class="hljs-number">68</span>, <span class="hljs-number">87</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">23</span>, <span class="hljs-number">34</span>, <span class="hljs-number">45</span>, <span class="hljs-number">68</span>, <span class="hljs-number">87</span>]<br></code></pre></td></tr></table></figure>


<hr>
<p><strong>python</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">array</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(array) &lt; <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> array<br>    <span class="hljs-keyword">else</span>:<br>        pivot = array[<span class="hljs-number">0</span>]<br>        less = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> array[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> i &lt;= pivot]<br>        greater = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> array[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> i &gt; pivot]<br>        <span class="hljs-keyword">return</span> quickSort(less) + [pivot] + quickSort(greater)<br><br><br>print(quickSort([<span class="hljs-number">1</span>, <span class="hljs-number">23</span>, <span class="hljs-number">12</span>, <span class="hljs-number">34</span>, <span class="hljs-number">87</span>, <span class="hljs-number">45</span>, <span class="hljs-number">68</span>, <span class="hljs-number">15</span>]))<br></code></pre></td></tr></table></figure>



<p><a href="https://book.douban.com/subject/26979890/">算法图解 (豆瓣)_豆瓣读书 作者: [美] Aditya Bhargava </a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习笔记（三）《选择排序》</title>
    <url>//post/algorithm-choose-sort-1.html</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote>
<p>本文学习内容来自《算法图解》一书及百度百科内容</p>
</blockquote>
<p>算法是一组完成任务的指令。任何代码片段都可视为算法。  —— 摘自《算法图解》</p>
<hr>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote>
<p><a href="https://baike.baidu.com/item/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/9762418?fr=aladdin">以下内容摘自百度百科</a><br>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。</p>
</blockquote>
<h2 id="思路梳理"><a href="#思路梳理" class="headerlink" title="思路梳理"></a>思路梳理</h2><pre><code>    假如你现在在一家新闻媒体公司工作，今天一共有5条新闻，老板现在叫你把这5条新闻按照浏览量最多的排在前面，
你会怎么去做？</code></pre>
<table>
<thead>
<tr>
<th>新闻标题</th>
<th>浏览量</th>
</tr>
</thead>
<tbody><tr>
<td>1.<a href="http://ent.ifeng.com/a/20180522/43051233_0.shtml?_zbs_baidu_news">辣妈张嘉倪怀二胎气色好 眨眼卖萌很少女</a></td>
<td>3336</td>
</tr>
<tr>
<td>2.<a href="http://ent.ifeng.com/a/20180522/43051144_0.shtml?_zbs_baidu_news">唐嫣被问想不想变矮一点，她的回答很耿直</a></td>
<td>14564</td>
</tr>
<tr>
<td>3.<a href="http://news.sina.com.cn/s/2018-05-22/doc-ihawmaua7331989.shtml">“逃犯克星”张学友将在洛阳开唱 警方:已准备好</a></td>
<td>42214</td>
</tr>
<tr>
<td>4.<a href="http://www.autohome.com.cn/news/201805/100171639.html">燃爆禾城—浙江康润助力张学友演唱会</a></td>
<td>8322</td>
</tr>
<tr>
<td>5.<a href="http://m2.people.cn/r/MV8wXzExMDE5NjI1XzE5MzRfMTUyNjk1MDg1Nw==">王大陆为张杰打call：认识了全世界最好男人</a></td>
<td>25584</td>
</tr>
</tbody></table>
<p>一般我们会这样去实现这个需求：</p>
<ol>
<li>遍历这个5条记录。</li>
<li>找出其中浏览量最大的放在一旁，放在一个新的地方，排在最前面。</li>
<li>从这5条记录里把那一条删除。</li>
<li>重复123步骤，遍历剩下的4条。找出····</li>
</ol>
<p>选择排序是根据指定的条件（最大值或者最小值），取决你要排序的顺序，然后在指定的数组中，找到这个条件，把它从指定的数组中提取出来，放到一个新的数组里面，并把它从源数组中删除。</p>
<hr>
<p><font color="read"><strong>源数组</strong> </font>对其进行筛选，找出浏览量最大值提取出来放在 <font color="red"><strong>新数组</strong> </font> ，并在源数组中将其删除</p>
<p>源新闻中第三条新闻的阅读数最高 ： 42214  我们把它拿出来放到了新数组的第一位<br>新闻标题<font color="read">（源数组） </font>|浏览量||新闻标题<font color="red">（新数组）</font> |浏览量<br>–|–|–|–|–<br>1.<a href="http://ent.ifeng.com/a/20180522/43051233_0.shtml?_zbs_baidu_news">辣妈张嘉倪怀二胎气色好 眨眼卖萌很少女</a>|3336||1.<a href="http://news.sina.com.cn/s/2018-05-22/doc-ihawmaua7331989.shtml">“逃犯克星”张学友将在洛阳开唱 警方:已准备好</a><font color="read">↑(3)</font>|42214<br>2.<a href="http://ent.ifeng.com/a/20180522/43051144_0.shtml?_zbs_baidu_news">唐嫣被问想不想变矮一点，她的回答很耿直</a>|14564<br>4.<a href="http://www.autohome.com.cn/news/201805/100171639.html">燃爆禾城—浙江康润助力张学友演唱会</a>|8322<br>5.<a href="http://m2.people.cn/r/MV8wXzExMDE5NjI1XzE5MzRfMTUyNjk1MDg1Nw==">王大陆为张杰打call：认识了全世界最好男人</a>|25584</p>
<hr>
<p>然后是排名第二浏览量的第五条新闻 25584 ，取出后放在新数组的第二位</p>
<table>
<thead>
<tr>
<th>新闻标题<font color="read">（源数组） </font></th>
<th>浏览量</th>
<th></th>
<th>新闻标题<font color="red">（新数组）</font></th>
<th>浏览量</th>
</tr>
</thead>
<tbody><tr>
<td>1.<a href="http://ent.ifeng.com/a/20180522/43051233_0.shtml?_zbs_baidu_news">辣妈张嘉倪怀二胎气色好 眨眼卖萌很少女</a></td>
<td>3336</td>
<td></td>
<td>1.<a href="http://news.sina.com.cn/s/2018-05-22/doc-ihawmaua7331989.shtml">“逃犯克星”张学友将在洛阳开唱 警方:已准备好</a><font color="read">↑(3)</td>
<td>42214</td>
</tr>
<tr>
<td>2.<a href="http://ent.ifeng.com/a/20180522/43051144_0.shtml?_zbs_baidu_news">唐嫣被问想不想变矮一点，她的回答很耿直</a></td>
<td>14564</td>
<td></td>
<td>2.<a href="http://m2.people.cn/r/MV8wXzExMDE5NjI1XzE5MzRfMTUyNjk1MDg1Nw==">王大陆为张杰打call：认识了全世界最好男人</a><font color="read">↑(5)</td>
<td>25584</td>
</tr>
<tr>
<td>4.<a href="http://www.autohome.com.cn/news/201805/100171639.html">燃爆禾城—浙江康润助力张学友演唱会</a></td>
<td>8322</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<p>接下来的数据中，浏览量最多的新闻是第三条， 14564 我们把它拿出来放在新数组的第三位</p>
<table>
<thead>
<tr>
<th>新闻标题<font color="read">（源数组） </font></th>
<th>浏览量</th>
<th></th>
<th>新闻标题<font color="red">（新数组）</font></th>
<th>浏览量</th>
</tr>
</thead>
<tbody><tr>
<td>1.<a href="http://ent.ifeng.com/a/20180522/43051233_0.shtml?_zbs_baidu_news">辣妈张嘉倪怀二胎气色好 眨眼卖萌很少女</a></td>
<td>3336</td>
<td></td>
<td>1.<a href="http://news.sina.com.cn/s/2018-05-22/doc-ihawmaua7331989.shtml">“逃犯克星”张学友将在洛阳开唱 警方:已准备好</a><font color="read">↑(3)</td>
<td>42214</td>
</tr>
<tr>
<td>4.<a href="http://www.autohome.com.cn/news/201805/100171639.html">燃爆禾城—浙江康润助力张学友演唱会</a></td>
<td>8322</td>
<td></td>
<td>2.<a href="http://m2.people.cn/r/MV8wXzExMDE5NjI1XzE5MzRfMTUyNjk1MDg1Nw==">王大陆为张杰打call：认识了全世界最好男人</a><font color="read">↑(5)</td>
<td>25584</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>3.<a href="http://ent.ifeng.com/a/20180522/43051144_0.shtml?_zbs_baidu_news">唐嫣被问想不想变矮一点，她的回答很耿直</a><font color="read">↓(2)</td>
</tr>
</tbody></table>
<hr>
<p>然后在把接下来最高的是 8322 我们把它取出，放在新数组的第三位</p>
<table>
<thead>
<tr>
<th>新闻标题<font color="read">（源数组） </font></th>
<th>浏览量</th>
<th></th>
<th>新闻标题<font color="red">（新数组）</font></th>
<th>浏览量</th>
</tr>
</thead>
<tbody><tr>
<td>1.<a href="http://ent.ifeng.com/a/20180522/43051233_0.shtml?_zbs_baidu_news">辣妈张嘉倪怀二胎气色好 眨眼卖萌很少女</a></td>
<td>3336</td>
<td></td>
<td>1.<a href="http://news.sina.com.cn/s/2018-05-22/doc-ihawmaua7331989.shtml">“逃犯克星”张学友将在洛阳开唱 警方:已准备好</a><font color="read">↑(3)</td>
<td>42214</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>2.<a href="http://m2.people.cn/r/MV8wXzExMDE5NjI1XzE5MzRfMTUyNjk1MDg1Nw==">王大陆为张杰打call：认识了全世界最好男人</a><font color="read">↑(5)</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>3.<a href="http://ent.ifeng.com/a/20180522/43051144_0.shtml?_zbs_baidu_news">唐嫣被问想不想变矮一点，她的回答很耿直</a><font color="read">↓(2)</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>4.<a href="http://www.autohome.com.cn/news/201805/100171639.html">燃爆禾城—浙江康润助力张学友演唱会</a><font color="read">(4)</td>
</tr>
</tbody></table>
<hr>
<p>最后再把浏览量最小的第一条新闻，放在新数组的最后一位。至此完成了我们的《选择排序》</p>
<table>
<thead>
<tr>
<th>新闻标题<font color="red">（新数组）</font></th>
<th>浏览量</th>
</tr>
</thead>
<tbody><tr>
<td>1.<a href="http://news.sina.com.cn/s/2018-05-22/doc-ihawmaua7331989.shtml">“逃犯克星”张学友将在洛阳开唱 警方:已准备好</a> <font color="read">↑(3)</td>
<td>42214</td>
</tr>
<tr>
<td>2.<a href="http://m2.people.cn/r/MV8wXzExMDE5NjI1XzE5MzRfMTUyNjk1MDg1Nw==">王大陆为张杰打call：认识了全世界最好男人</a> <font color="read">↑(5)</td>
<td>25584</td>
</tr>
<tr>
<td>3.<a href="http://ent.ifeng.com/a/20180522/43051144_0.shtml?_zbs_baidu_news">唐嫣被问想不想变矮一点，她的回答很耿直</a> <font color="read">↓(2)</td>
<td>14564</td>
</tr>
<tr>
<td>4.<a href="http://www.autohome.com.cn/news/201805/100171639.html">燃爆禾城—浙江康润助力张学友演唱会</a> <font color="read">(4)</td>
<td>8322</td>
</tr>
<tr>
<td>5.<a href="http://ent.ifeng.com/a/20180522/43051233_0.shtml?_zbs_baidu_news">辣妈张嘉倪怀二胎气色好 眨眼卖萌很少女</a> <font color="read">↓(1)</td>
<td>3336</td>
</tr>
</tbody></table>
<hr>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] selectionSort(<span class="hljs-keyword">int</span>[] ints) &#123;<br>        <span class="hljs-keyword">int</span>[] newInts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ints.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = ints.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">int</span> index = findBiggest(ints);<br>            newInts[i] = ints[index];<br>            ints = remove(ints, index);<br>        &#125;<br>        <span class="hljs-keyword">return</span> newInts;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findBiggest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] ints)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> biggest = ints[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> biggestIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; ints.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (ints[i] &lt; biggest) &#123;<br>                biggest = ints[i];<br>                biggestIndex = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> biggestIndex;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] remove(<span class="hljs-keyword">int</span>[] ints, <span class="hljs-keyword">int</span> index) &#123;<br>        <span class="hljs-keyword">int</span>[] newArray = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ints.length - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (index &gt; <span class="hljs-number">0</span>) &#123;<br>            System.arraycopy(ints, <span class="hljs-number">0</span>, newArray, <span class="hljs-number">0</span>, index);<br>            System.arraycopy(ints, index + <span class="hljs-number">1</span>, newArray, index, newArray.length - index);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.arraycopy(ints, index + <span class="hljs-number">1</span>, newArray, <span class="hljs-number">0</span>, newArray.length);<br>        &#125;<br>        <span class="hljs-keyword">return</span> newArray;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] ints = &#123;<span class="hljs-number">3336</span>, <span class="hljs-number">14564</span>, <span class="hljs-number">42214</span>, <span class="hljs-number">8322</span>, <span class="hljs-number">25584</span>&#125;;<br>        ints = selectionSort(ints);<br>        System.out.println(<span class="hljs-string">&quot;ints = &quot;</span> + Arrays.toString(ints));<br>    &#125;<br><br><span class="hljs-comment">// ints = [42214, 25584, 14564, 8322, 3336]</span><br></code></pre></td></tr></table></figure>


<hr>
<p><strong>python</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findBiggest</span>(<span class="hljs-params">arry</span>):</span><br>    biggest = arry[<span class="hljs-number">0</span>]<br>    biggest_index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(arry)):<br>        <span class="hljs-keyword">if</span> arry[index] &gt; biggest:<br>            biggest = arry[index]<br>            biggest_index = index<br>    <span class="hljs-keyword">return</span> biggest_index<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">selectionSort</span>(<span class="hljs-params">arry</span>):</span><br>    resultArry = []<br>    <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(arry)):<br>        index = findBiggest(arry)<br>        resultArry.append(arry.pop(index))<br>    <span class="hljs-keyword">return</span> resultArry<br><br><br>print(<span class="hljs-string">&#x27;ints =&#x27;</span>, selectionSort([<span class="hljs-number">3336</span>, <span class="hljs-number">14564</span>, <span class="hljs-number">42214</span>, <span class="hljs-number">8322</span>, <span class="hljs-number">25584</span>]))<br><br><span class="hljs-comment"># ints = [42214, 25584, 14564, 8322, 3336]</span><br></code></pre></td></tr></table></figure>

<p>选择排序是一种灵巧的算法，但其速度不是很快。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习笔记（二）《二分查找》</title>
    <url>//post/algorithm-binary-search-1.html</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote>
<p>本文学习内容来自《算法图解》一书及百度百科内容</p>
</blockquote>
<p>算法是一组完成任务的指令。任何代码片段都可视为算法。  —— 摘自《算法图解》</p>
<hr>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><blockquote>
<p><a href="https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">以下内容摘自百度百科</a><br>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p>
</blockquote>
<h3 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h3><ol>
<li>还记得我们上学的时候，假如你想要去词典中找“算法”是什么意思，我们会怎么做？</li>
<li>上课的时候，老师叫我们把书翻到146页的时候，你是怎么翻到的呢？</li>
<li>我们以前和同学一起玩过的猜数字游戏还记得怎么玩的了吗？</li>
</ol>
<p>当我们去思考上面问题，我们是不是这样可以通过地毯式的搜索，去达到我们的目的，例如我们可以从词典的第一页开始找，总能找到“算法”；我们从书的第一页开始翻，在下课之前一定能够翻到146页；或者你给我的范围，我从最小的开始猜，“0，1，2，3，······97，98，99 。对啦！” 我总能猜到你心里想的数字。这种方式称其简单查找。</p>
<hr>
<h3 id="二分查找思路"><a href="#二分查找思路" class="headerlink" title="二分查找思路"></a>二分查找思路</h3><ol>
<li>如果我们换种思路去解决这个问题。我们把字典翻开，翻到中间，看下中间位置的拼音和我们的“suan”能不能够对应的上，如果不能，“suan”在这前面还是在这后面，我们继续的去对应的位置去翻看，最终会找到我们要找的“算法”。</li>
<li>我们把书直接翻到中间，280页，在280页之前的一侧，再翻到中间，147页。往前再翻一页，成功翻到老师指定的页数学习。</li>
<li>同学A没毛病说 ：“0~100我随便想一个数，你来猜猜看？”，同学B很执着说：“好啊，我来了啊，0”，同学A没毛病说：“不对，小了”，“1”，“不对，小了”，“2”，“不对，小了”，“3”，“不对，小了”，“4”，同学A没毛病吼道：“滚，你赢了。”同学C二分哥：“我来试试，50”，“小了”，“75”，“大了”，“62”，“小了”，“68”，“大了”，“65”，“小了”，“66”，“bingo！”；</li>
</ol>
<p>看到这估计大部分同学已经看懂了二分查找的核心实现思路了。那我们来看看具体的实现过程</p>
<h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><ul>
<li>必须采用顺序存储结构。</li>
<li>必须按关键字大小有序排列。</li>
</ul>
<blockquote>
<p>这里面大家需要注意一下，二分查找的使用是有硬性的条件约束的，必须满足条件的数据才能够使用二分查找。</p>
</blockquote>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>为了方便大家学习和调试，这里列出Java 和 python的代码给大家参考。</p>
<p><strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dichotomy</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] ints, <span class="hljs-keyword">int</span> item)</span> </span>&#123;<br>       <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">int</span> end = ints.length - <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>           <span class="hljs-keyword">int</span> mid = (start + end) &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>           <span class="hljs-keyword">int</span> guess = ints[mid];<br>           <span class="hljs-keyword">if</span> (guess == item) &#123;<br>               <span class="hljs-keyword">return</span> mid;<br>           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (guess &gt; item) &#123;<br>               end = mid - <span class="hljs-number">1</span>;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               start = mid + <span class="hljs-number">1</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p><strong>python</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dichotomy</span>(<span class="hljs-params"><span class="hljs-built_in">list</span>, item</span>):</span><br>    low = <span class="hljs-number">0</span><br>    high = <span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> low &lt;= high:<br>        mid = (low + high) // <span class="hljs-number">2</span><br>        guess = <span class="hljs-built_in">list</span>[mid]<br>        <span class="hljs-keyword">if</span> guess == item:<br>            <span class="hljs-keyword">return</span> mid<br>        <span class="hljs-keyword">elif</span> guess &gt; item:<br>            high = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            low = mid + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 PLSQL Developer 中文乱码</title>
    <url>//post/problem-plsql-garbled.html</url>
    <content><![CDATA[<h1 id="当前中文显示"><a href="#当前中文显示" class="headerlink" title="当前中文显示"></a>当前中文显示</h1><p><img src="/images/posts/problem-plsql-garbled/20190308101902235.png"></p>
<h1 id="解决后"><a href="#解决后" class="headerlink" title="解决后"></a>解决后</h1><p><img src="/images/posts/problem-plsql-garbled/20190308101925588.png"></p>
<a id="more"></a>

<h3 id="1-查询当前数据库编码集"><a href="#1-查询当前数据库编码集" class="headerlink" title="1. 查询当前数据库编码集"></a>1. 查询当前数据库编码集</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> userenv(<span class="hljs-string">&#x27;language&#x27;</span>) <span class="hljs-keyword">from</span> dual;<br></code></pre></td></tr></table></figure>
<p><img src="/images/posts/problem-plsql-garbled/20190308101212690.png"></p>
<h3 id="2-设置系统环境变量"><a href="#2-设置系统环境变量" class="headerlink" title="2. 设置系统环境变量"></a>2. 设置系统环境变量</h3><p>右击计算机选择属性<br><img src="/images/posts/problem-plsql-garbled/20190308101322676.png"><br><img src="/images/posts/problem-plsql-garbled/20190308101410401.png"></p>
<p><img src="/images/posts/problem-plsql-garbled/20190308101523374.png"></p>
<p>1 处填 : NLS_LANG<br>2 处填 : 刚刚数据库查出来的值 AMERICAN_AMERICA.ZHS16GBK<br><img src="/images/posts/problem-plsql-garbled/20190308101610281.png"></p>
<h4 id="检查当前数据库中文显示"><a href="#检查当前数据库中文显示" class="headerlink" title="检查当前数据库中文显示"></a>检查当前数据库中文显示</h4><p><img src="/images/posts/problem-plsql-garbled/20190308101849623.png"></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>（概念总结）快速了解JVM结构和工作原理</title>
    <url>//post/jvm-theory-concept.html</url>
    <content><![CDATA[<blockquote>
<p>以下内容为阅读由周志明编著的《深入理解Java虚拟机JVM高级特性与最佳实战》（第二版）自行总结记录，算不上完全解读了大神的意思，但也没有瞎写。如果写的不清楚的地方，还望能够自行阅读原著。这里写记只为巩固学习。</p>
</blockquote>
<a id="more"></a>

<h3 id="什么是Java虚拟机（JVM）？"><a href="#什么是Java虚拟机（JVM）？" class="headerlink" title="什么是Java虚拟机（JVM）？"></a>什么是Java虚拟机（JVM）？</h3><p>Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程，相当于一个普通应用程序。Java 源文件被编译成能被 Java 虚拟机执行的字节码文件。 java要在应用平台上执行，需要先安装执行虚拟机，java虚拟机屏蔽了平台操作系统的底层硬件信息，抽取整理了各平台公共的处理硬件的接口提供给开发用户使用，java开发用户只要基于JVM开发接口开发java程序而不需要关注执行平台的系统特性。<br>如果JAVA比喻火车, 那虚拟机可以理解为轨道. 它是JAVA的一个允许载体.为JAVA提供了运行环境.跨平台是因为虚拟机可以在多平台运行. 所以JAVA就可以在多平台运行.这也是JAVA的一个优点和特点. 跨平台运行.</p>
<hr>
<h3 id="JVM的结构"><a href="#JVM的结构" class="headerlink" title="JVM的结构"></a>JVM的结构</h3><p>JVM由类加载子系统，执行器引擎，本地方法库和运行时区域（内存空间）组成。这里着重说下内存空间。</p>
<p>JVM的内存空间是指：</p>
<ul>
<li>堆（线程共有）</li>
<li>方法区（线程共有）</li>
<li>虚拟机栈（线程私有）</li>
<li>本地方法栈（线程私有）</li>
<li>程序计数器（线程私有）</li>
</ul>
<p>下面简单讲一下这几个地方都是干什么的。</p>
<h4 id="堆（线程共有）"><a href="#堆（线程共有）" class="headerlink" title="堆（线程共有）"></a>堆（线程共有）</h4><p>JVM堆中主要存储的就是我们所有实例化的对象。</p>
<h4 id="方法区（线程共有）"><a href="#方法区（线程共有）" class="headerlink" title="方法区（线程共有）"></a>方法区（线程共有）</h4><p>主要存储的是虚拟机加载的类信息，常量，静态变量，常量池</p>
<h4 id="JVM栈（线程私有）"><a href="#JVM栈（线程私有）" class="headerlink" title="JVM栈（线程私有）"></a>JVM栈（线程私有）</h4><p>保存我们程序运行时调用方法分配的栈帧，包括局部变量表（所需空间实在编译期完成分配的，分配之后的大小不能改变）、操作数栈、动态链接、方法出口等。</p>
<h4 id="本地栈（线程私有）"><a href="#本地栈（线程私有）" class="headerlink" title="本地栈（线程私有）"></a>本地栈（线程私有）</h4><p>与JVM栈一样，只不过服务对象不同，JVM服务于Java方法，本地栈服务于虚拟机使用到的Native方法。</p>
<h4 id="程序计数器（线程私有）"><a href="#程序计数器（线程私有）" class="headerlink" title="程序计数器（线程私有）"></a>程序计数器（线程私有）</h4><p>这块内存比较小，它主要负责的内容就是字节码解释器工作的时候负责记录字节码的行号和位置。就比如我们程序的多线程切换，都是需要通过这个计数器来确定，所以每一个线程都有一个自己的程序计数器。</p>
<hr>
<h3 id="JVM的工作原理"><a href="#JVM的工作原理" class="headerlink" title="JVM的工作原理"></a>JVM的工作原理</h3><p>这一块内容比较好理解，可以像我这样简单的对其有个了解，具体的实现我们不做过多的说明。</p>
<p>首先Java程序经过编译，生成class格式文件，而这个class的文件就是我们虚拟机所需要的的，虚拟机通过加载class文件来运行我们的Java程序。这里还要特别说明一点。JVM不光可以运行Java程序！JVM不光可以运行Java程序！JVM不光可以运行Java程序！同样的当初设计就没想着让虚拟机只能运行Java程序，在它上面还可以运行其他语言的程序。具体我就不去搜索了，需要了解的大家可以自行学习。</p>
<hr>
<p>可能总结的不够深入，不过由于个人学习能力有限，希望可以能在以后读的更通透的时候回来继续维护修正。</p>
<p>抱着和大家共同学习的目的，记录学习总结。不足之处还希望能够指出共同进步！</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP1.1协议状态码[翻译]</title>
    <url>//post/translate-http-protocol.html</url>
    <content><![CDATA[<h1 id="阅读建议"><a href="#阅读建议" class="headerlink" title="阅读建议"></a>阅读建议</h1><ul>
<li>篇幅较长，建议收藏，可以当做手册来查询使用</li>
<li>善用目录索引，快速定位你想知道的状态码</li>
<li>点赞、关注、收藏，一键三连支持（抱拳）</li>
</ul>
<p><strong>从此妈妈再也不用担心我的 http 状态码问题了。</strong></p>
<blockquote>
<p><strong>转载请注明出处，谢谢</strong></p>
</blockquote>
<hr>
<p>节选 <strong>RFC 2616</strong>  sec 10  <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10">超文本传输协议状态码</a></p>
<p>翻译+诠释（个人见解部分）</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>Hypertext Transfer Protocol – HTTP/1.1</p>
<hr>
<h1 id="状态码定义"><a href="#状态码定义" class="headerlink" title="状态码定义"></a>状态码定义</h1><p>每个状态码的说明如下, 包括对每个响应状态的说明 </p>
<h1 id="信息类状态-1xx"><a href="#信息类状态-1xx" class="headerlink" title="信息类状态 1xx"></a>信息类状态 1xx</h1><p>此类状态码仅由 <em>状态行</em> 和可选响应头组成的<strong>临时</strong>响应, 并以空行终止。此类状态码没有必需的标题。由于HTTP / 1.0没有定义任何1xx状态代码，因此服务器必须禁止向HTTP / 1.0客户端发送1xx响应。</p>
<p>即使客户不希望收到100（继续）状态消息，也必须准备在常规响应之前接受一个或多个1xx状态响应。用户代理可能会忽略意外的1xx状态响应。</p>
<p>如果是代理必须转发1xx, 除非代理与客户端连接关闭, 或者代理自己本身生成1xx（例如，如果代理在转发请求时会添加“hope：100-Continue”字段，则无需转发相应的100（Continue）响应。）</p>
<p><strong>诠释:</strong></p>
<ol>
<li><p>状态行: 由http协议版本 状态码 状态码描述组成的一个包含在响应头中的一段字符串</p>
</li>
<li><p>1xx状态码是 HTTP/1.1协议新增的状态码, HTTP/1.0中不存在, 我们不应该向HTTP/1.0协议的客户端响应 1xx 状态码</p>
</li>
<li><p>如果是代理必须转发1xx状态码 , 除非你的代理本身就会响应1xx状态码</p>
</li>
<li><p>临时响应, 即这个状态是一个中间状态, 不是最终状态.</p>
</li>
</ol>
<hr>
<h2 id="100-Continue-继续"><a href="#100-Continue-继续" class="headerlink" title="100 Continue (继续)"></a>100 Continue (继续)</h2><p>客户应继续其请求。此临时响应用于通知客户端请求的初始部分已被接收并且尚未被服务器拒绝。客户端应该继续发送剩余的请求，或者，如果请求已经完成，则忽略该响应。请求完成后，服务器必须发送最终响应。</p>
<p>100 的目的是允许正在发送带有请求正文的请求消息的客户端确定源服务器是否愿意接受请求（基于请求标头）在客户端发送请求正文之前。在某些情况下，如果服务器在不查看正文的情况下拒绝邮件，则客户端发送正文可能是不合适的，或者效率很低。</p>
<p><strong>诠释:</strong></p>
<blockquote>
<p>期望在 14.20 章节也有描述, <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.20">https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.20</a></p>
</blockquote>
<p>100 的作用相当于敲门. “请进”, 继续发送后续内容, 无人应答(拒绝)无需在发送后续内容, 提高效率</p>
<hr>
<h2 id="101-Switching-Protocols-交换协议"><a href="#101-Switching-Protocols-交换协议" class="headerlink" title="101 Switching Protocols (交换协议)"></a>101 Switching Protocols (交换协议)</h2><p>服务器理解并愿意通过“升级消息头”字段（第14.42节）来满足客户端对在此连接上使用的应用协议进行更改的请求。服务器将在终止101响应的空行之后立即将协议切换到响应的“升级”标头字段所定义的协议。</p>
<p>仅在有利的情况下才应切换协议。例如，切换到新版本的HTTP优于旧版本，并且在传递使用此类功能的资源时，切换到实时同步协议可能是有利的。</p>
<p>升级通用标头允许客户端指定其支持的其他通信协议，并在服务器认为适合切换协议时使用。服务器必须使用101（交换协议）响应中的Upgrade标头字段来指示正在交换的协议。</p>
<p><strong>诠释:</strong></p>
<p>这个过程是由客户端主动发起升级指令, 在请求头 Upgrade 字段中标注出, 服务端响应成功后会返回 101 表示协议转换</p>
<hr>
<h1 id="响应成功-2xx"><a href="#响应成功-2xx" class="headerlink" title="响应成功 2xx"></a>响应成功 2xx</h1><p>此类状态码表示已成功接收并处理了客户的请求。</p>
<h2 id="200-ok-成功"><a href="#200-ok-成功" class="headerlink" title="200 ok (成功)"></a>200 ok (成功)</h2><p>该请求已成功。响应返回的信息取决于请求中使用的方法</p>
<p>GET 在响应中发送与请求的资源相对应的实体;</p>
<p>HEAD 与请求的资源相对应的实体头字段在响应中发送，不带任何消息正文;</p>
<p>POST 描述或包含行动结果的实体;</p>
<p>TRACE 包含最终服务器接收到的请求消息的实体.</p>
<p><strong>诠释:</strong></p>
<p>在浏览器接收到响应状态为 200 的时候, 代表服务端接收并处理了请求, 但服务端响应的内容是取决于我们所使用的请求方法, 常见的我们使用 get &amp; post 方法</p>
<p>这里扩展知识到 REST 接口规范, 可以自行前往阮一峰的一篇文章查看 <a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html">http://www.ruanyifeng.com/blog/2014/05/restful_api.html</a></p>
<hr>
<h2 id="201-Created-已创建"><a href="#201-Created-已创建" class="headerlink" title="201 Created (已创建)"></a>201 Created (已创建)</h2><p>该请求已完成，并导致创建了新资源。可以通过响应实体中返回的URI引用新创建的资源，其中最具体的URI由Location头字段给出。响应应包括一个实体，其中包含资源特征和位置的列表，用户或用户代理可以从中选择最合适的一个。实体格式由Content-Type标头字段中提供的媒体类型指定。源服务器必须在返回201状态代码之前创建资源。如果不能立即执行该操作，则服务器应以202（已接受）响应代替。</p>
<p>201响应可能包含ETag响应标头字段，该字段指示刚刚创建的所请求变量的实体标签的当前值，请参见14.19节。</p>
<p><strong>诠释:</strong></p>
<p>201响应一般用在 REST api规范中的 POST 请求响应状态码, 标识对提交的资源已保存.</p>
<p>这里提到了一个如果对资源不能够创建, 也就是在响应之前不能够完成这个动作, 这种场景可能会出现在我们的异步数据处理中, 那此时需要返回 202 状态码, 代表你接收了这次请求, 但还未完成对资源的操作.</p>
<hr>
<h2 id="202-Accepted-接受"><a href="#202-Accepted-接受" class="headerlink" title="202 Accepted (接受)"></a>202 Accepted (接受)</h2><p>该请求已被接受进行处理，但是处理尚未完成。该请求最终可能会执行，也可能不会最终执行，因为在实际进行处理时可能会不允许该请求。没有从这种异步操作中重新发送状态代码的功能。</p>
<p>202响应是有意拒绝的。其目的是允许服务器接受对其他进程的请求（也许是每天仅运行一次的面向批处理的进程），而无需用户代理与服务器的连接一直持续到该进程完成为止。随此响应返回的实体应包括请求当前状态的指示，以及指向状态监视器的指针或用户何时可以期望完成请求的一些估计。</p>
<p><strong>诠释:</strong></p>
<p>接收到了客户端的请求, 正在异步处理, 客户端可以继续进行其他操作, 意义同 201 场景返回该状态码</p>
<hr>
<h2 id="203-Non-Authoritative-Information-非权威信息"><a href="#203-Non-Authoritative-Information-非权威信息" class="headerlink" title="203 Non-Authoritative Information (非权威信息)"></a>203 Non-Authoritative Information (非权威信息)</h2><p>实体标头中返回的元信息不是原始服务器可用的权威集，而是从本地或第三方副本收集的。呈现的集合可以是原始版本的子集或超集。例如，包括有关资源的本地注释信息可能会导致原始服务器已知的元信息的超集。不需要使用此响应代码，并且仅当响应为200（确定）时才适用。</p>
<p><strong>诠释:</strong></p>
<p>仍旧适用在代理服务器, 它在获取到原始内容后, 原始服务器给他响应了200, 然后代理服务器对内容进行了修改. 再返回给客户端, 在响应状态行中就会用 203 状态码注释, 此信息非权威信息, 非原信息.</p>
<hr>
<h2 id="204-No-Content-无内容"><a href="#204-No-Content-无内容" class="headerlink" title="204 No Content (无内容)"></a>204 No Content (无内容)</h2><p>服务器已满足请求，但不需要返回实体，可能要返回更新的元信息。响应可以包括实体标题形式的新的或更新的元信息，如果存在，则应与所请求的变量相关联。</p>
<p>如果客户端是用户代理，则不应更改导致发送请求的文档视图。尽管任何新的或更新的元信息都应该应用于当前在用户代理的活动视图中的文档，但该响应主要旨在允许输入操作而不会导致更改用户代理的活动文档视图。</p>
<p>204响应必须不包含消息正文，因此始终由标头字段之后的第一个空行终止。</p>
<p><strong>诠释:</strong> </p>
<p>请求无响应报文, 这种操作相当于只需要看状态码就知道结果. 例如你对服务器的资源进行删除操作. 那服务器就不需要告诉你响应报文, 只需要告诉你删除的结果, 成功or失败, 所以这个结果可以直接通过状态码知道.</p>
<hr>
<h2 id="205-Reset-Content-重置内容"><a href="#205-Reset-Content-重置内容" class="headerlink" title="205 Reset Content (重置内容)"></a>205 Reset Content (重置内容)</h2><p>服务器已经完成了请求，并且用户代理应该重置导致请求被发送的文档视图。该响应主要旨在允许通过用户输入进行操作的输入，然后清除给出输入的形式，以便用户可以轻松地发起另一个输入操作。响应中不得包含实体。</p>
<p><strong>诠释:</strong></p>
<p>当你在一个带有表单提交的页面, 输入了表单信息, 点击了提交按钮. 服务器处理成功, 但是希望这次提交之后表单页数据重置, 即抹掉输入的信息, 保持初始状态, 那么服务端就会返回一个 205 状态码.</p>
<hr>
<h2 id="206-Partial-Content-部分内容"><a href="#206-Partial-Content-部分内容" class="headerlink" title="206 Partial Content (部分内容)"></a>206 Partial Content (部分内容)</h2><p>服务器已完成对资源的部分GET请求。该请求必须包含指示所需范围的Range标头字段（第14.35节），并且可能包含If-Range标头字段（第14.27节）以使请求成为条件请求。</p>
<p>响应必须包括以下头域：</p>
<pre><code> - Either a Content-Range header field (section 14.16) indicating
    the range included with this response, or a multipart/byteranges
    Content-Type including Content-Range fields for each part. If a
    Content-Length header field is present in the response, its
    value MUST match the actual number of OCTETs transmitted in the
    message-body.
  - Date
  - ETag and/or Content-Location, if the header would have been sent
    in a 200 response to the same request
  - Expires, Cache-Control, and/or Vary, if the field-value might
    differ from that sent in any previous response for the same
    variant</code></pre>
<p>如果206响应是使用强缓存验证器的If-Range请求的结果（请参阅第13.3.3节），则该响应不应包含其他实体标头。如果响应是使用弱验证器的If-Range请求的结果，则响应必须不包括其他实体头；这样可以避免缓存的实体与更新的标头之间的不一致。否则，响应必须包括所有对同一请求返回200（确定）响应的实体头。</p>
<p>如果ETag或Last-Modified头不完全匹配，则缓存不得将206响应与其他先前缓存的内容组合在一起，请参见13.5.4。</p>
<p>不支持Range和Content-Range头的缓存必须不缓存206（部分）响应。</p>
<p><strong>诠释:</strong></p>
<p>鄙人拙见: 断点续传</p>
<p>参考 <a href="https://www.cnblogs.com/simonbaker/p/5190675.html">https://www.cnblogs.com/simonbaker/p/5190675.html</a></p>
<hr>
<h1 id="Redirection-3xx-重定向"><a href="#Redirection-3xx-重定向" class="headerlink" title="Redirection 3xx 重定向"></a>Redirection 3xx 重定向</h1><p>此类状态码表示用户代理需要采取进一步的措施才能满足请求。当且仅当第二个请求中使用的方法是GET或HEAD时，才可以由用户代理执行所需的操作，而无需与用户进行交互。客户端应该检测到无限重定向循环，因为这样的循环会为每个重定向生成网络流量。</p>
<pre><code>注意：本规范的先前版本建议使用,最多五个重定向。内容开发人员应注意
  可能会有客户实施这样的固定局限性。</code></pre>
<p><strong>诠释:</strong></p>
<p>使用300作为响应码时, 一般在 get或head请求时, 才可以, 因为这两部分都属于资源访问, 而这部分资源在代理服务器不能够解决是, 推荐客户到目标资源地址访问, 但要由客户端检测,是不是<strong>无限重定向.</strong></p>
<hr>
<h2 id="300-Multiple-Choices"><a href="#300-Multiple-Choices" class="headerlink" title="300 Multiple Choices"></a>300 Multiple Choices</h2><p>所请求的资源与一组表示中的任何一个相对应，每个都有自己的特定位置，并且提供了代理驱动的协商信息（第12节），以便用户（或用户代理）可以选择首选的表示并重定向其请求到该位置。</p>
<p>除非它是HEAD请求，否则响应应包括一个实体，其中包含资源特征和位置的列表，用户或用户代理可以从中选择最合适的一个。实体格式由“内容类型”标头字段中提供的媒体类型指定。取决于格式和功能</p>
<p>用户代理，可以自动执行最合适的选择。但是，该规范没有为这种自动选择定义任何标准。</p>
<p>如果服务器具有首选的表示形式，则应在“位置”字段中包含该表示形式的特定URI；用户代理可以使用“位置”字段值进行自动重定向。除非另有说明，否则此响应是可缓存的。</p>
<p><strong>诠释:</strong> </p>
<p>我没找到, 但是找到了类似的资源, 或者找到了很多资源, 打开开发者工具, 点击下面链接, 观察响应状态</p>
<p><a href="https://www.w3.org/Style/Examples/007/figures.ht">https://www.w3.org/Style/Examples/007/figures.ht</a></p>
<hr>
<h2 id="301-Moved-Permanently-永久移动"><a href="#301-Moved-Permanently-永久移动" class="headerlink" title="301 Moved Permanently (永久移动)"></a>301 Moved Permanently (永久移动)</h2><p>所请求的资源已被分配了一个新的永久URI，以后对该资源的任何引用都应使用返回的URI之一。具有链接编辑功能的客户端应该在可能的情况下自动将对Request-URI的引用重新链接到服务器返回的一个或多个新引用。除非另有说明，否则此响应是可缓存的。</p>
<p>新的永久URI应该由响应中的Location字段给出。除非请求方法是HEAD，否则响应的实体应该包含简短的超文本注释，并带有指向新URI的超链接。</p>
<p>如果接收到响应GET或HEAD以外的请求的301状态代码，则用户代理不得自动重定向该请求，除非用户可以确认，因为这可能会更改发出该请求的条件。</p>
<pre><code>  注意：在之后自动重定向POST请求时
  收到301状态代码，一些现有的HTTP / 1.0用户代理
  会错误地将其更改为GET请求。</code></pre>
<p><strong>诠释:</strong></p>
<p>资源在其他位置 Location 字段给出.</p>
<hr>
<h2 id="302-Found-找到"><a href="#302-Found-找到" class="headerlink" title="302 Found (找到)"></a>302 Found (找到)</h2><p>所请求的资源临时位于其他URI下。由于重定向有时可能会更改，因此客户端应继续将Request-URI用于将来的请求。仅当由Cache-Control或Expires标头字段指示时，此响应才可缓存。</p>
<p>临时URI应该由响应中的Location字段给出。除非请求方法是HEAD，否则响应的实体应该包含简短的超文本注释，并带有指向新URI的超链接。</p>
<p>如果响应GET或HEAD以外的请求而收到302状态码，则用户代理不得自动重定向请求，除非用户可以确认，因为这可能会更改发出请求的条件。</p>
<pre><code>  注意：RFC 1945和RFC 2068指定不允许客户端
  更改重定向请求的方法。但是，大多数
  现有的用户代理实现将302视为303
  响应，无论位置字段值如何执行GET
  原始请求方法。状态码303和307具有
  为希望明确指出哪个服务器添加了
  期望客户有种反应。</code></pre>
<p><strong>诠释:</strong></p>
<p>同 301 .客户端会使用Location中给出的URL，重新发送新的HTTP request     </p>
<hr>
<h2 id="303-See-Other-查看其它"><a href="#303-See-Other-查看其它" class="headerlink" title="303 See Other (查看其它)"></a>303 See Other (查看其它)</h2><p>可以在不同的URI下找到对请求的响应，并且应该使用该资源上的GET方法来检索。存在此方法主要是为了允许POST激活的脚本的输出将用户代理重定向到所选资源。新URI不能替代原始请求的资源。303响应一定不能被缓存，但是对第二个（重定向的）请求的响应可能是可缓存的。</p>
<p>响应中的Location字段应提供不同的URI。除非请求方法是HEAD，否则响应的实体应该包含简短的超文本注释，并带有指向新URI的超链接。</p>
<blockquote>
<p>注意：许多HTTP / 1.1之前的用户代理不了解303状态。当需要考虑与此类客户端的互操作性时，因为大多数用户代理都会做出反应，所以可以改用302状态代码，02响应，如此处针对303所述。</p>
</blockquote>
<p><strong>诠释:</strong></p>
<p>同 302</p>
<hr>
<h2 id="304-Not-Modified-无改变"><a href="#304-Not-Modified-无改变" class="headerlink" title="304 Not Modified (无改变)"></a>304 Not Modified (无改变)</h2><p>如果客户端已经执行了有条件的GET请求，并且允许访问，但是文档没有被修改，则服务器应该以该状态码响应。304响应必须不包含消息正文，因此始终由标头字段之后的第一个空行终止。</p>
<p>响应必须包括以下头域：</p>
<pre><code>  -日期，除非第14.18.1节要求省略</code></pre>
<p>如果无时钟源服务器遵守这些规则，并且代理和客户端将自己的日期添加到没有响应的任何响应中（如[RFC 2068]第14.19节所指定的），缓存将正常运行。</p>
<pre><code>  -ETag和/或Content-Location（如果标头已发送）
    在对同一请求的200条回复中
  -如果字段值可能会过期，缓存控制和/或变化
    与先前的任何回复中发送的相同
    变体</code></pre>
<p>如果条件GET使用了强缓存验证器（请参阅第13.3.3节），则响应不应包含其他实体头。否则（即，条件GET使用弱验证器），响应中不得包含其他实体标头；这样可以避免缓存的实体与更新的标头之间的不一致。</p>
<p>如果304响应指示当前未缓存的实体，则缓存必须忽略该响应，并在没有条件的情况下重复该请求。</p>
<p>如果缓存使用接收到的304响应来更新缓存条目，则缓存必须更新该条目以反映响应中给定的任何新字段值。</p>
<p><strong>诠释:</strong></p>
<p>当服务器返回304状态码是即表示资源服务器未发生改变, 要求客户端使用缓存资源.</p>
<hr>
<h2 id="305-Use-Proxy-使用代理"><a href="#305-Use-Proxy-使用代理" class="headerlink" title="305 Use Proxy (使用代理)"></a>305 Use Proxy (使用代理)</h2><p>所请求的资源必须通过位置字段给出的代理来访问。位置字段提供代理的URI。预计收件人将通过代理重复此单个请求。305个响应必须仅由原始服务器生成。</p>
<pre><code>  注意：RFC 2068尚不清楚305是否旨在重定向
  单个请求，并且仅由原始服务器生成。不
  遵守这些限制会带来重大的安全后果。</code></pre>
<p><strong>诠释:</strong><br>你好, 有事请联系我的律师(代理服务器), 叫他来找我, 这是他的号码(location字段内容)</p>
<hr>
<h2 id="306-Unused-未使用"><a href="#306-Unused-未使用" class="headerlink" title="306 (Unused) (未使用)"></a>306 (Unused) (未使用)</h2><p>306状态代码在规范的先前版本中使用，不再使用，并且保留该代码。</p>
<hr>
<h2 id="307-Temporary-Redirect-临时重定向"><a href="#307-Temporary-Redirect-临时重定向" class="headerlink" title="307 Temporary Redirect (临时重定向)"></a>307 Temporary Redirect (临时重定向)</h2><p>所请求的资源临时位于其他URI下。由于重定向有时可能会改变，所以客户端应该继续使用Request-URI来处理以后的请求。仅当由Cache-Control或Expires标头字段指示时，此响应才可缓存。</p>
<p>临时URI应该由响应中的Location字段给出。除非请求方法是HEAD，否则响应的实体应包含简短的超文本注释，并带有指向新URI的超链接，因为许多HTTP / 1.1之前的用户代理不了解307状态。因此，注释应该包含用户在新URI上重复原始请求所必需的信息。</p>
<p>如果响应GET或HEAD以外的请求而收到307状态码，则用户代理不得自动重定向请求，除非用户可以确认，因为这可能会更改发出请求的条件。</p>
<hr>
<h1 id="Client-Error-4xx-客户端错误"><a href="#Client-Error-4xx-客户端错误" class="headerlink" title="Client Error 4xx 客户端错误"></a>Client Error 4xx 客户端错误</h1><p>状态码4xx类用于客户端似乎已出错的情况。除响应HEAD请求外，服务器应包含一个实体，该实体包含错误情况的说明，以及它是暂时还是永久的情况。这些状态代码适用于任何请求方法。用户代理应该向用户显示任何包含的实体。</p>
<p>如果客户端正在发送数据，则在服务器关闭输入连接之前，使用TCP的服务器实现应小心确保客户端确认包含响应的数据包的接收。如果关闭后客户端继续向服务器发送数据，则服务器的TCP堆栈将向客户端发送重置数据包，这可能会擦除客户端的未确认输入缓冲区，然后HTTP应用程序才能读取和解释它们。</p>
<hr>
<h2 id="400-Bad-Request-错误的请求"><a href="#400-Bad-Request-错误的请求" class="headerlink" title="400 Bad Request (错误的请求)"></a>400 Bad Request (错误的请求)</h2><p>由于语法格式错误，服务器无法理解该请求。客户不应在没有修改的情况下重复请求。</p>
<hr>
<h2 id="401-Unauthorized-未授权"><a href="#401-Unauthorized-未授权" class="headerlink" title="401 Unauthorized (未授权)"></a>401 Unauthorized (未授权)</h2><p>该请求需要用户认证。响应必须包括一个WWW-Authenticate头域（第14.47节），该头域包含适用于所请求资源的质询。客户端可以使用合适的Authorization标头字段重复请求（第14.8节））。如果请求已包含授权凭证，则401响应指示已拒绝这些凭证的授权。如果401响应包含与先前响应相同的质询，并且用户代理已经尝试了至少一次身份验证，则应该向用户提供响应中给定的实体，因为该实体可能包括相关的诊断信息。HTTP访问身份验证在“ HTTP身份验证：基本和摘要访问身份验证”</p>
<hr>
<h2 id="402-Payment-Required-需要付款"><a href="#402-Payment-Required-需要付款" class="headerlink" title="402 Payment Required (需要付款)"></a>402 Payment Required (需要付款)</h2><p>该代码保留供将来使用。</p>
<hr>
<h2 id="403-Forbidden-禁止"><a href="#403-Forbidden-禁止" class="headerlink" title="403 Forbidden (禁止)"></a>403 Forbidden (禁止)</h2><p>服务器理解了该请求，但拒绝执行该请求。授权将无济于事，不应重复该请求。如果请求方法不是HEAD，并且服务器希望公开为什么未满足请求，则应在实体中描述拒绝原因。如果服务器不希望将此信息提供给客户端，则可以改用状态代码404（未找到）。</p>
<p><strong>诠释:</strong> </p>
<p>不想让你访问资源, 比如你在做爬虫程序, 在爬取同一个网络资源时, 对应的站点就可以给你返回 403 来禁止你的资源请求. </p>
<hr>
<h2 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h2><p>服务器未找到与请求URI匹配的任何内容。没有迹象表明这种情况是暂时的还是永久的。如果服务器通过某种内部可配置的机制得知旧资源永久不可用并且没有转发地址，则应使用410（已消失）状态代码。如果服务器不希望确切显示请求被拒绝的原因，或者没有其他响应可应用时，通常使用此状态代码。</p>
<hr>
<h2 id="405-Method-Not-Allowed-方法不允许"><a href="#405-Method-Not-Allowed-方法不允许" class="headerlink" title="405 Method Not Allowed (方法不允许)"></a>405 Method Not Allowed (方法不允许)</h2><p>Request-URI所标识的资源不允许使用Request-Line中指定的方法。响应必须包括一个Allow标头，其中包含所请求资源的有效方法列表。</p>
<hr>
<h2 id="406-Not-Acceptable-不可接受"><a href="#406-Not-Acceptable-不可接受" class="headerlink" title="406 Not Acceptable (不可接受)"></a>406 Not Acceptable (不可接受)</h2><p>由请求标识的资源仅能够生成响应实体，该响应实体具有根据请求中发送的接受标头不可接受的内容特征。</p>
<p>除非它是HEAD请求，否则响应应包括一个实体，其中包含可用实体特征和位置的列表，用户或用户代理可以从中选择最合适的一个。实体格式由Content-Type标头字段中提供的媒体类型指定。根据用户代理的格式和功能，可以自动执行最合适的选择。但是，该规范没有为这种自动选择定义任何标准。</p>
<pre><code>  注意：允许HTTP / 1.1服务器返回以下响应：
  根据在
  请求。在某些情况下，这甚至可能比发送
  406回应。鼓励用户代理检查的标题
  确定是否可接受的传入响应。</code></pre>
<p>如果响应是不可接受的，则用户代理应暂时停止接收更多数据，并向用户查询有关进一步操作的决定。</p>
<hr>
<h2 id="407-Proxy-Authentication-Required-需要代理身份验证"><a href="#407-Proxy-Authentication-Required-需要代理身份验证" class="headerlink" title="407 Proxy Authentication Required (需要代理身份验证)"></a>407 Proxy Authentication Required (需要代理身份验证)</h2><p>此代码类似于401（未经授权），但表示客户端必须首先使用代理对其进行身份验证。代理务必返回一个Proxy-Authenticate头域（第14.33节），其中包含适用于所请求资源的代理的质询。客户可以用合适的代理授权头域（第14.34节）重复请求。HTTP访问身份验证在“ HTTP身份验证：基本和摘要访问身份验证”</p>
<hr>
<h2 id="408-Request-Timeout-请求超时"><a href="#408-Request-Timeout-请求超时" class="headerlink" title="408 Request Timeout (请求超时)"></a>408 Request Timeout (请求超时)</h2><p>客户端在服务器准备等待的时间内未产生请求。客户端可以在以后的任何时间重复请求而无需修改。</p>
<hr>
<h2 id="409-Conflict"><a href="#409-Conflict" class="headerlink" title="409 Conflict"></a>409 Conflict</h2><p>由于与资源的当前状态存在冲突，因此无法完成请求。仅在预期用户可能能够解决冲突并重新提交请求的情况下才允许使用此代码。响应正文应包含足够的内容</p>
<p>供用户识别冲突源的信息。理想情况下，响应实体应包括足够的信息供用户或用户代理解决问题。但是，这可能是不可能的，也不是必需的。</p>
<p>响应PUT请求最有可能发生冲突。例如，如果正在使用版本控制，并且正在PUT的实体包括对资源的更改，该更改与先前的（第三方）请求所做的更改冲突，则服务器可能会使用409响应来指示它无法完成请求。在这种情况下，响应实体可能会以响应Content-Type定义的格式包含两个版本之间差异的列表。</p>
<hr>
<h2 id="410-Gone-资源不可用"><a href="#410-Gone-资源不可用" class="headerlink" title="410 Gone (资源不可用)"></a>410 Gone (资源不可用)</h2><p>请求的资源在服务器上不再可用，并且未知转发地址。可以认为这种情况是永久的。具有链接编辑功能的客户端应在用户批准后删除对Request-URI的引用。如果服务器不知道或没有确定条件是否为永久性的条件，则应改用状态代码404（未找到）。除非另有说明，否则此响应是可缓存的。</p>
<p>410响应主要用于通过通知接收者资源有意不可用以及服务器所有者希望删除指向该资源的远程链接来辅助Web维护任务。对于限时促销服务和属于不再在服务器站点工作的个人的资源来说，这种事件很常见。不必将所有永久不可用的资源标记为“已消失”，也不必将标记保留任何时间-服务器所有者可以自行决定。</p>
<hr>
<h2 id="411-Length-Required-所需长度"><a href="#411-Length-Required-所需长度" class="headerlink" title="411 Length Required (所需长度)"></a>411 Length Required (所需长度)</h2><p>服务器拒绝接受没有定义Content-Length的请求。如果客户端在请求消息中添加了包含消息主体长度的有效Content-Length头字段，则客户端可以重复该请求。</p>
<hr>
<h2 id="412-Precondition-Failed"><a href="#412-Precondition-Failed" class="headerlink" title="412 Precondition Failed"></a>412 Precondition Failed</h2><p>在服务器上测试时，在一个或多个请求标头字段中给出的前提条件被评估为false。此响应代码允许客户端在当前资源元信息（标头字段数据）上放置先决条件，从而防止将请求的方法应用于除预定资源以外的其他资源。</p>
<hr>
<h2 id="413-Request-Entity-Too-Large"><a href="#413-Request-Entity-Too-Large" class="headerlink" title="413 Request Entity Too Large"></a>413 Request Entity Too Large</h2><p>服务器拒绝处理请求，因为请求实体大于服务器愿意或能够处理的实体。服务器可以关闭连接，以防止客户端继续请求。</p>
<p>如果条件是暂时的，则服务器应包括Retry- After标头字段以指示它是暂时的，并且客户端可以在什么时间之后重试。</p>
<hr>
<h2 id="414-Request-URI-Too-Long"><a href="#414-Request-URI-Too-Long" class="headerlink" title="414 Request-URI Too Long"></a>414 Request-URI Too Long</h2><p>服务器拒绝处理请求，因为Request-URI的长度比服务器愿意解释的时间长。仅当客户端将不正确的POST请求转换为带有长查询信息的GET请求，客户端下降到重定向的URI“黑洞”（例如，指向URI的重定向URI前缀）时，才会发生这种罕见情况后缀），或者当服务器受到客户端的攻击时，客户端试图使用固定长度的缓冲区来读取或操纵Request-URI来利用某些服务器中存在的安全漏洞。</p>
<hr>
<h2 id="415-Unsupported-Media-Type"><a href="#415-Unsupported-Media-Type" class="headerlink" title="415 Unsupported Media Type"></a>415 Unsupported Media Type</h2><p>服务器拒绝为请求提供服务，因为请求的实体的格式不受请求的方法所请求的资源支持。</p>
<hr>
<h2 id="416-Requested-Range-Not-Satisfiable"><a href="#416-Requested-Range-Not-Satisfiable" class="headerlink" title="416 Requested Range Not Satisfiable"></a>416 Requested Range Not Satisfiable</h2><p>如果请求中包含Range请求标头字段（第14.35节），并且该字段中的range-specifier值均不与所选资源的当前范围重叠，则服务器应返回带有此状态代码的响应。包含If-Range请求标头字段。（对于字节范围，这意味着所有字节范围规范值的第一个字节位置大于所选资源的当前长度。）</p>
<p>当针对字节范围请求返回此状态代码时，响应应包含指定所选择资源的当前长度的Content-Range实体标头字段（请参见14.16节 ）。此响应绝对不能使用multipart / byteranges内容类型。</p>
<hr>
<h2 id="417-Expectation-Failed"><a href="#417-Expectation-Failed" class="headerlink" title="417 Expectation Failed"></a>417 Expectation Failed</h2><p>此服务器无法满足在Expect请求标头字段（请参阅第14.20节）中给出的期望，或者，如果该服务器是代理服务器，则该服务器有明确的证据表明下一跳服务器无法满足该请求。</p>
<hr>
<h1 id="Server-Error-5xx-服务端错误"><a href="#Server-Error-5xx-服务端错误" class="headerlink" title="Server Error 5xx (服务端错误)"></a>Server Error 5xx (服务端错误)</h1><p>以数字“ 5”开头的响应状态代码表示服务器知道服务器已出错或无法执行请求的情况。除响应HEAD请求外，服务器应包含一个实体，该实体包含错误情况的说明，以及它是暂时还是永久的情况。用户代理应该向用户显示任何包含的实体。这些响应代码适用于任何请求方法。</p>
<hr>
<h2 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h2><p>服务器遇到意外情况，阻止其满足请求。</p>
<hr>
<h2 id="501-Not-Implemented"><a href="#501-Not-Implemented" class="headerlink" title="501 Not Implemented"></a>501 Not Implemented</h2><p>服务器不支持满足请求所需的功能。当服务器无法识别请求方法并且不支持任何资源时，这是适当的响应。</p>
<hr>
<h2 id="502-Bad-Gateway"><a href="#502-Bad-Gateway" class="headerlink" title="502 Bad Gateway"></a>502 Bad Gateway</h2><p>该服务器在充当网关或代理的同时，从尝试访问该请求的上游服务器接收到无效响应。</p>
<hr>
<h2 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h2><p>由于暂时的服务器过载或维护，服务器当前无法处理该请求。这意味着这是一个暂时性状况，经过一段时间的延迟后会缓解。如果知道的话，延迟的长度可以在Retry-After头中指出。如果没有给出Retry-After，则客户端应该像处理500响应那样处理响应。</p>
<pre><code>  注意：503状态代码的存在并不意味着
  服务器过载时必须使用它。一些服务器可能希望
  简单地拒绝连接。</code></pre>
<hr>
<h2 id="504-Gateway-Timeout"><a href="#504-Gateway-Timeout" class="headerlink" title="504 Gateway Timeout"></a>504 Gateway Timeout</h2><p>该服务器虽然充当网关或代理，但没有收到来自URI指定的上游服务器（例如HTTP，FTP，LDAP）或尝试完成访问所需访问的某些其他辅助服务器的及时响应。请求。</p>
<pre><code>  注意：实施者注意：已知一些已部署的代理
  DNS查找超时时返回400或500。</code></pre>
<hr>
<h2 id="505-HTTP-Version-Not-Supported"><a href="#505-HTTP-Version-Not-Supported" class="headerlink" title="505 HTTP Version Not Supported"></a>505 HTTP Version Not Supported</h2><p>服务器不支持或拒绝支持请求消息中使用的HTTP协议版本。如第3.1节所述，服务器会使用该客户端的主版本指示其无法或不愿意完成该请求 ，但该错误消息除外。响应应该包含一个实体，描述为什么不支持该版本以及该服务器支持哪些其他协议。</p>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中Quartz2.2.2的使用</title>
    <url>//post/course-spring-quartz.html</url>
    <content><![CDATA[<p>本文介绍的内容为, 在spring管理的项目中使用Quartz2.2.2版本进行任务调度</p>
<h4 id="quartz-非教学介绍"><a href="#quartz-非教学介绍" class="headerlink" title="quartz 非教学介绍"></a>quartz 非教学介绍</h4><p>quartz是一款基于java timer开发的一个轻量级任务调度框架, 可以帮助我们快速实现定时/周期任务处理工具组件</p>
<p> Quartz中有任务组, 任务, 触发器组, 触发器 cron expression 等概念.<br> JOB_GROUP 、JOB 、TRIGGER_GROUP 、TRIGGER 、CRON</p>
<p>顾名思义任务组对应任务, 触发器组对应触发器, 目前实战项目中的用法比较特殊.</p>
<p>我们使用一个任务, 对应多个触发器来达到任务调度的实现.当前Quartz支持两种任务配置, 这里使用的是以任务为单位来进行定时执行的概念, 还有一种指定service方法来执行, 具体大家可以参考其他博主的文章自行了解.</p>
<a id="more"></a>

<p><strong>注意!!! Quartz版本2.x以后,不支持向下兼容, 此文所用Quartz为2.2.2</strong></p>
<h4 id="常用类及API"><a href="#常用类及API" class="headerlink" title="常用类及API"></a>常用类及API</h4><p>JobDetail、JobBuilder、TriggerBuilder、Scheduler、CronTrigger、CronScheduleBuilder</p>
<h5 id="相互之间的关系"><a href="#相互之间的关系" class="headerlink" title="相互之间的关系"></a>相互之间的关系</h5><p>任务调度器 Scheduler 内可以存在多个任务 JobDetail 任务内可以存在多个触发器来调起这个任务来进行任务的执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mermaid">graph LR<br> B((job1)) --&gt;A[Scheduler] <br>f((job2)) --&gt;A[Scheduler] <br>g[Trigger1] --0&#x2F;5 * * * * --&gt; f((job2)) <br><br>h[Trigger2] --0&#x2F;10 * * * * --&gt; f((job2)) <br><br>i[Trigger3] --0&#x2F;10 * * * * --&gt; f((job2)) <br>c[Trigger1] --0&#x2F;5 * * * * --&gt; B((job1)) <br><br>d[Trigger2] --0&#x2F;10 * * * * --&gt; B((job1)) <br><br>e[Trigger3] --0&#x2F;10 * * * * --&gt; B((job1)) <br></code></pre></td></tr></table></figure>

<h5 id="JobDetail"><a href="#JobDetail" class="headerlink" title="JobDetail"></a>JobDetail</h5><p>任务的最小单元。该类主要记录任务信息</p>
<h5 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h5><p>任务的执行时机，触发的时点</p>
<h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><blockquote>
<p>创建一个任务</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Quartz 2.x 以后版本,JobDetail由类, 上升成为了接口,对应的实现为JobDetailImpl</span><br><span class="hljs-comment"> * 但Quartz并不推荐使用JobDetailImpl直接获取到Job对象</span><br><span class="hljs-comment"> * Quartz提供了构建者模式创建对象</span><br><span class="hljs-comment"> * 其中包含这里看到的任务构建器, 以及后面得到触发器构建器</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 这里说明一下构建器的几个参数, 通过阅读源码我们可以发现,</span><br><span class="hljs-comment"> * Job构建器需要指定一个任务的class路径作为一个构建者的标注, 然后依次属性durably</span><br><span class="hljs-comment"> * 任务是否进行持久化, 默认为false, 这里后面我们可以通过观察qrtz_job_details中is_durably字段</span><br><span class="hljs-comment"> * 数据变化来检查对应任务的设置情况. 接着requestRecovery属性为是否记录任务执行状态,</span><br><span class="hljs-comment"> * 比如中断后, 重启应用后是否继续执行,默认为false,对应表字段qrtz_job_details中 request_recovery字段</span><br><span class="hljs-comment"> * 接着后面的 withIdentity 为我们任务的基本信息, 分别为任务名称及任务组</span><br><span class="hljs-comment"> */</span><br>JobDetail jobDetail = JobBuilder.newJob(xsdsJob.getClass())<br>        .storeDurably().requestRecovery().<br>                withIdentity(xsdsJob.getJobName(), xsdsJob.getJobGroupName()).build();<br><span class="hljs-keyword">try</span> &#123;<br>    scheduler.addJob(jobDetail, <span class="hljs-keyword">true</span>);<br>&#125; <span class="hljs-keyword">catch</span> (SchedulerException e) &#123;<br>    ........<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>为某个任务增加执行时机(触发器)</p>
</blockquote>
<p>具体内容参考代码中日志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>	  <span class="hljs-comment">// TriggerKey  是作为一个触发器的标识存在的, 通过 TriggerKey 可以定位到一个触发器, 这里使用的参数为触发器所在组及触发器名称</span><br>    TriggerKey triggerKey = TriggerKey.triggerKey(trigger.getTriggerName(), trigger.getTriggerGroupName());<br> <span class="hljs-comment">// 通过使用调度器 scheduler.getTrigger() 方法返回值来获取对应的触发器</span><br>    <span class="hljs-keyword">if</span> (scheduler.getTrigger(triggerKey) != <span class="hljs-keyword">null</span>) &#123;<br>        logger.error(<span class="hljs-string">&quot;当前任务【&quot;</span> + trigger.getTriggerName() + <span class="hljs-string">&quot;】已存在, 无法覆盖创建任务调度计划&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br> <span class="hljs-comment">// 触发器构建器</span><br>    TriggerBuilder&lt;Trigger&gt; triggerBuilder = TriggerBuilder.newTrigger();<br>    <span class="hljs-comment">// 执行时辅助参数</span><br>    triggerBuilder.usingJobData(trigger.getParam());<br>    <span class="hljs-comment">// 触发器信息</span><br>    triggerBuilder.withIdentity(trigger.getTriggerName(), trigger.getTriggerGroupName());<br>    <span class="hljs-comment">// 设置后立即启动</span><br>    triggerBuilder.startNow();<br>    <span class="hljs-comment">// 使用的调度类型, 这里配置为cron表达式触发器</span><br>    triggerBuilder.withSchedule(<br>            CronScheduleBuilder.cronSchedule(trigger.getCron())<br>                    .withMisfireHandlingInstructionDoNothing());<br>    <span class="hljs-comment">// 该触发器所关联的任务</span><br>    triggerBuilder.forJob(trigger.getJobName(), trigger.getJobGroupName());<br>    CronTrigger cronTrigger = (CronTrigger) triggerBuilder.build();<br>    <span class="hljs-comment">// 设置触发器</span><br>    scheduler.scheduleJob(cronTrigger);<br>    <span class="hljs-comment">// 当前调度器是否执行, 如果没执行, 启动该调度器</span><br>    <span class="hljs-keyword">if</span> (!scheduler.isShutdown()) &#123;<br>        scheduler.start();<br>        logger.info(<span class="hljs-string">&quot;【&quot;</span> + trigger.getTriggerName() + <span class="hljs-string">&quot;】任务调度计划启动成功!&quot;</span>);<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="代码编写参考"><a href="#代码编写参考" class="headerlink" title="代码编写参考"></a>代码编写参考</h4><blockquote>
<p>下面一切内容皆建立在Spring管理项目基础上Quartz相关内容</p>
</blockquote>
<h6 id="jar包下载"><a href="#jar包下载" class="headerlink" title="jar包下载"></a>jar包下载</h6><p>maven</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.quartz-scheduler<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>quartz<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h6 id="配置Quartz文件"><a href="#配置Quartz文件" class="headerlink" title="配置Quartz文件"></a>配置Quartz文件</h6><ol>
<li>注册调度bean</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&lt;!-- 定时任务配置 --&gt;<br>&lt;bean id=<span class="hljs-string">&quot;scheduler&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;</span>&gt;<br>    &lt;property name=<span class="hljs-string">&quot;dataSource&quot;</span> ref=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;<br>    &lt;property name=<span class="hljs-string">&quot;overwriteExistingJobs&quot;</span> value=<span class="hljs-string">&quot;true&quot;</span>/&gt;<br>    &lt;property name=<span class="hljs-string">&quot;startupDelay&quot;</span> value=<span class="hljs-string">&quot;10&quot;</span>/&gt;<br>    &lt;property name=<span class="hljs-string">&quot;autoStartup&quot;</span> value=<span class="hljs-string">&quot;true&quot;</span>/&gt;<br>    &lt;property name=<span class="hljs-string">&quot;applicationContextSchedulerContextKey&quot;</span> value=<span class="hljs-string">&quot;applicationContextKey&quot;</span>/&gt;<br>    &lt;property name=<span class="hljs-string">&quot;configLocation&quot;</span> value=<span class="hljs-string">&quot;classpath:conf/common/properties/quartz.properties&quot;</span>/&gt;<br>&lt;/bean&gt;<br><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>Quartz properties(官方默认即可)</li>
</ol>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><br><span class="hljs-comment"># Default Properties file for use by StdSchedulerFactory</span><br><span class="hljs-comment"># to create a Quartz Scheduler Instance, if a different</span><br><span class="hljs-comment"># properties file is not explicitly specified.</span><br><span class="hljs-comment">#</span><br><span class="hljs-attr">org.quartz.scheduler.instanceName</span>=XSDSQuartzScheduler<br><span class="hljs-attr">org.quartz.scheduler.instanceId</span>=AUTO<br><span class="hljs-attr">org.quartz.scheduler.rmi.export</span>=<span class="hljs-literal">false</span><br><span class="hljs-attr">org.quartz.scheduler.rmi.proxy</span>=<span class="hljs-literal">false</span><br><span class="hljs-attr">org.quartz.scheduler.wrapJobExecutionInUserTransaction</span>=<span class="hljs-literal">false</span><br><span class="hljs-attr">org.quartz.threadPool.class</span>=org.quartz.simpl.SimpleThreadPool<br><span class="hljs-attr">org.quartz.threadPool.threadCount</span>=<span class="hljs-number">20</span><br><span class="hljs-attr">org.quartz.threadPool.threadPriority</span>=<span class="hljs-number">5</span><br><span class="hljs-attr">org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread</span>=<span class="hljs-literal">true</span><br><span class="hljs-comment">#60000</span><br><span class="hljs-attr">org.quartz.jobStore.misfireThreshold</span>=<span class="hljs-number">120000</span><br><br><span class="hljs-comment">#org.quartz.jobStore.class = org.quartz.simpl.RAMJobStore</span><br><span class="hljs-attr">org.quartz.jobStore.class</span>=org.quartz.impl.jdbcjobstore.JobStoreTX<br><span class="hljs-comment">#org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate</span><br><span class="hljs-attr">org.quartz.jobStore.driverDelegateClass</span>=com.erayt.xsds.common.schedule.core.OracleDelegate<br><span class="hljs-attr">org.quartz.jobStore.useProperties</span>=<span class="hljs-literal">false</span><br><span class="hljs-comment">#org.quartz.jobStore.dataSource = myDS</span><br><span class="hljs-attr">org.quartz.jobStore.tablePrefix</span>=QRTZ_<br><span class="hljs-attr">org.quartz.jobStore.isClustered</span>=<span class="hljs-literal">true</span><br><span class="hljs-attr">org.quartz.jobStore.clusterCheckinInterval</span>=<span class="hljs-number">30000</span><br><span class="hljs-attr">org.quartz.jobStore.maxMisfiresToHandleAtATime</span>=<span class="hljs-number">10</span><br><span class="hljs-comment">#org.quartz.jobStore.doubleCheckLockMisfireHandler=false</span><br><br><br></code></pre></td></tr></table></figure>

<h6 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h6><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.erayt.xsds.common.schedule.core;<br><br><span class="hljs-keyword">import</span> com.erayt.xsds.common.cache.ehcache.cachedOb.SysParamList;<br><span class="hljs-keyword">import</span> com.erayt.xsds.common.domain.base.SysParam;<br><span class="hljs-keyword">import</span> com.erayt.xsds.common.utils.CronUtil;<br><span class="hljs-keyword">import</span> org.apache.log4j.Logger;<br><span class="hljs-keyword">import</span> org.quartz.*;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgo</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@package</span> com.erayt.xsds.common.schedule.service</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 定时任务调度管理</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2019/9/18 16:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduleService</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TRG_BATCHTODAY = <span class="hljs-string">&quot;当日晚间批处理任务&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TRG_SYSBATCH = <span class="hljs-string">&quot;系统隔夜批处理任务&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TRG_SYSONLINEBATCH = <span class="hljs-string">&quot;系统联机隔夜批处理任务&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger logger = Logger.getLogger(ScheduleService.class);<br>    <span class="hljs-meta">@Value(&quot;$&#123;TRG_GROUP_NAME&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String triggerGroupName = <span class="hljs-string">&quot;TRIGGER_GROUP_SYSTEM&quot;</span>;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> XsdsJob xsdsJob;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> Scheduler scheduler;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDemoSchedule</span><span class="hljs-params">()</span> </span>&#123;<br>        String cron = CronUtil.getCron(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>);<br>        addTrigger(getXsdsJobTrigger(<span class="hljs-string">&quot;这是一个测试任务&quot;</span>, cron, <span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-number">1000</span>));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建一个xsds任务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createXsdsJob</span><span class="hljs-params">()</span> </span>&#123;<br>        JobDetail jobDetail = JobBuilder.newJob(xsdsJob.getClass())<br>                .storeDurably().requestRecovery().<br>                        withIdentity(xsdsJob.getJobName(), xsdsJob.getJobGroupName()).build();<br>        <span class="hljs-keyword">try</span> &#123;<br>            scheduler.addJob(jobDetail, <span class="hljs-keyword">true</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (SchedulerException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;增加XSDS基本任务异常&quot;</span>, e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取一个XSDS任务触发器对象</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 创建的任务名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cron 任务执行时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 任务执行触发器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> XsdsJobTrigger <span class="hljs-title">getXsdsJobTrigger</span><span class="hljs-params">(String name, String cron)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> XsdsJobTrigger.Builder().jobGroupName(xsdsJob.getJobGroupName()).jobName(xsdsJob.getJobName())<br>                .triggerGroupName(triggerGroupName).triggerName(name).cron(cron);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> XsdsJobTrigger <span class="hljs-title">getXsdsJobTrigger</span><span class="hljs-params">(String name, String cron, String paramKey, Object paramValue)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> XsdsJobTrigger.Builder().jobGroupName(xsdsJob.getJobGroupName()).jobName(xsdsJob.getJobName())<br>                .triggerGroupName(triggerGroupName).triggerName(name).cron(cron).params(paramKey, paramValue);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 增加一个任务执行触发器</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> trigger 任务执行触发器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTrigger</span><span class="hljs-params">(AbstractTrigger trigger)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TriggerKey triggerKey = TriggerKey.triggerKey(trigger.getTriggerName(), trigger.getTriggerGroupName());<br>            <span class="hljs-keyword">if</span> (scheduler.getTrigger(triggerKey) != <span class="hljs-keyword">null</span>) &#123;<br>                logger.error(<span class="hljs-string">&quot;当前任务【&quot;</span> + trigger.getTriggerName() + <span class="hljs-string">&quot;】已存在, 无法覆盖创建任务调度计划&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            TriggerBuilder&lt;Trigger&gt; triggerBuilder = TriggerBuilder.newTrigger();<br>            triggerBuilder.usingJobData(trigger.getParam());<br>            triggerBuilder.withIdentity(trigger.getTriggerName(), trigger.getTriggerGroupName());<br>            triggerBuilder.startNow();<br>            triggerBuilder.withSchedule(<br>                    CronScheduleBuilder.cronSchedule(trigger.getCron())<br>                            .withMisfireHandlingInstructionDoNothing());<br>            triggerBuilder.forJob(trigger.getJobName(), trigger.getJobGroupName());<br>            CronTrigger cronTrigger = (CronTrigger) triggerBuilder.build();<br>            scheduler.scheduleJob(cronTrigger);<br>            <span class="hljs-keyword">if</span> (!scheduler.isShutdown()) &#123;<br>                scheduler.start();<br>                logger.info(<span class="hljs-string">&quot;【&quot;</span> + trigger.getTriggerName() + <span class="hljs-string">&quot;】任务调度计划启动成功!&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 修改一个任务的触发时间</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> xsdsJob xsds任务类 提供触发器组, 触发器名称, 修改后的cron表达式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">modifyJobTime</span><span class="hljs-params">(AbstractTrigger xsdsJob)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TriggerKey triggerKey = TriggerKey.triggerKey(xsdsJob.getTriggerName(),<br>                    xsdsJob.getTriggerGroupName());<br>            CronTrigger trigger = (CronTrigger) scheduler.getTrigger(triggerKey);<br>            <span class="hljs-keyword">if</span> (trigger == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            String oldTime = trigger.getCronExpression();<br>            <span class="hljs-keyword">if</span> (!oldTime.equalsIgnoreCase(xsdsJob.getCron())) &#123;<br>                TriggerBuilder&lt;Trigger&gt; triggerBuilder = TriggerBuilder.newTrigger();<br>                triggerBuilder.forJob(xsdsJob.getJobName(), xsdsJob.getJobGroupName());<br>                triggerBuilder.withIdentity(xsdsJob.getTriggerName(), xsdsJob.getTriggerGroupName());<br>                triggerBuilder.startNow();<br>                triggerBuilder.usingJobData(trigger.getJobDataMap());<br>                triggerBuilder.withSchedule(CronScheduleBuilder.cronSchedule(xsdsJob.getCron()));<br>                trigger = (CronTrigger) triggerBuilder.build();<br>                scheduler.rescheduleJob(triggerKey, trigger);<br>                logger.info(<span class="hljs-string">&quot;【&quot;</span> + xsdsJob.getTriggerName() + <span class="hljs-string">&quot;】任务调度计划重设成功!&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除一个任务</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> xsdsJob xsds 任务类 提供任务名称, 任务组, 触发器名称, 触发器组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeJob</span><span class="hljs-params">(AbstractTrigger xsdsJob)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TriggerKey triggerKey = TriggerKey.triggerKey(xsdsJob.getTriggerName(), xsdsJob.getTriggerGroupName());<br>            scheduler.pauseTrigger(triggerKey);<br>            scheduler.unscheduleJob(triggerKey);<br>            scheduler.deleteJob(JobKey.jobKey(xsdsJob.getJobName(), xsdsJob.getJobGroupName()));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 启动所有定时任务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startJobs</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            scheduler.start();<br>            logger.info(<span class="hljs-string">&quot;任务调度计划启动成功&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关闭所有定时任务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdownJobs</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (!scheduler.isShutdown()) &#123;<br>                scheduler.shutdown();<br>                logger.info(<span class="hljs-string">&quot;任务调度计划停止成功&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.erayt.xsds.common.schedule.core;<br><br><span class="hljs-keyword">import</span> org.quartz.JobDataMap;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgo</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@package</span> com.erayt.xsds.common.schedule.core</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 触发器标识基础抽象类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2019/9/19 14:11</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractTrigger</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取触发器名称</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 触发器名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getTriggerName</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取触发器组名称</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 触发器组名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getTriggerGroupName</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取cron表达式 执行时机</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> cron表达式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getCron</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取任务名称</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 任务名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getJobName</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取任务组名称</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 任务组名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getJobGroupName</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取任务执行所需参数, 假如需要的话</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 任务执行所需参数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> JobDataMap <span class="hljs-title">getParam</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.erayt.xsds.common.schedule.core;<br><br><span class="hljs-keyword">import</span> com.erayt.solar2.engine.query.QueryParam;<br><span class="hljs-keyword">import</span> com.erayt.solar2.engine.query.impl.QueryEngineImpl;<br><span class="hljs-keyword">import</span> com.erayt.xsds.common.domain.base.SysParam;<br><span class="hljs-keyword">import</span> com.erayt.xsds.common.schedule.batch.FinancialOverNight;<br><span class="hljs-keyword">import</span> com.erayt.xsds.common.schedule.batch.LogInfoUtil;<br><span class="hljs-keyword">import</span> com.erayt.xsds.common.schedule.service.SysParamService;<br><span class="hljs-keyword">import</span> org.apache.log4j.Logger;<br><span class="hljs-keyword">import</span> org.quartz.JobDataMap;<br><span class="hljs-keyword">import</span> org.quartz.JobExecutionContext;<br><span class="hljs-keyword">import</span> org.quartz.JobExecutionException;<br><span class="hljs-keyword">import</span> org.quartz.SchedulerException;<br><span class="hljs-keyword">import</span> org.quartz.impl.triggers.CronTriggerImpl;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.scheduling.quartz.QuartzJobBean;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.web.context.support.XmlWebApplicationContext;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgo</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@package</span> com.erayt.xsds.common.schedule.batch</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: xsds job 类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2019/9/19 10:06</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XsdsJob</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">QuartzJobBean</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = Logger.getLogger(XsdsJob.class);<br>    <span class="hljs-keyword">private</span> Logger loggerBatch = Logger.getLogger(XsdsJob.class);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 任务名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Value(&quot;$&#123;XSDS_JOB&#125;&quot;)</span>  <span class="hljs-comment">// 这里读取的是配置文件, 有需要自行调整</span><br>    <span class="hljs-keyword">private</span> String jobName;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 任务组名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Value(&quot;$&#123;JOB_GROUP_NAME&#125;&quot;)</span> <span class="hljs-comment">// 这里读取的是配置文件, 有需要自行调整</span><br>    <span class="hljs-keyword">private</span> String jobGroupName;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getJobName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> jobName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getJobGroupName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> jobGroupName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">executeInternal</span><span class="hljs-params">(JobExecutionContext currentJob)</span> <span class="hljs-keyword">throws</span> JobExecutionException </span>&#123;<br>        QueryEngineImpl queryEngine = <span class="hljs-keyword">null</span>;<br>        SysParamService sysParamService = <span class="hljs-keyword">null</span>;<br>        FinancialOverNight financialOverNight = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            XmlWebApplicationContext context = (XmlWebApplicationContext) currentJob<br>                    .getScheduler().getContext().get(<span class="hljs-string">&quot;applicationContextKey&quot;</span>);<br>            queryEngine = (QueryEngineImpl) context.getBean(<span class="hljs-string">&quot;queryEngine&quot;</span>);<br>            sysParamService = (SysParamService) context.getBean(<span class="hljs-string">&quot;sysParamService&quot;</span>);<br>            financialOverNight = (FinancialOverNight) context.getBean(<span class="hljs-string">&quot;financialOverNight&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (SchedulerException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        CronTriggerImpl trigger = (CronTriggerImpl) currentJob.getTrigger();<br>        logger.info(<span class="hljs-string">&quot;任务调度执行计划【&quot;</span> + trigger.getName() + <span class="hljs-string">&quot;】已启动&quot;</span>);<br>        JobDataMap jobDataMap = trigger.getJobDataMap();<br>        Integer type = (Integer) jobDataMap.get(<span class="hljs-string">&quot;type&quot;</span>);<br>        logger.info(<span class="hljs-string">&quot;当前执行任务type:&quot;</span> + type);<br>        <span class="hljs-keyword">switch</span> (type) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1000</span>:<br>               System.out.println(<span class="hljs-string">&quot;测试任务正常执行&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        logger.info(<span class="hljs-string">&quot;任务调度执行计划【&quot;</span> + trigger.getName() + <span class="hljs-string">&quot;】已结束&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.erayt.xsds.common.schedule.core;<br><br><span class="hljs-keyword">import</span> org.quartz.JobDataMap;<br><br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lvgo</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@package</span> com.erayt.xsds.common.schedule.core</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: xpad基础任务新增触发器类 通过 Builder 方法创建</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2019/9/19 14:01</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XsdsJobTrigger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractTrigger</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 任务名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String jobName;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 任务组名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String jobGroupName;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 触发器名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String triggerName;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 触发器组名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String triggerGroupName;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * cron 表达式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String cron;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 参数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> JobDataMap param = <span class="hljs-keyword">new</span> JobDataMap();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 建议使用builder创建xsdsJOb触发器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">XsdsJobTrigger</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getJobName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> jobName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getJobGroupName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> jobGroupName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTriggerName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> triggerName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTriggerGroupName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> triggerGroupName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCron</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cron;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> JobDataMap <span class="hljs-title">getParam</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> param;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">XsdsJobTrigger</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">jobName</span><span class="hljs-params">(String jobName)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.jobName = jobName;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">jobGroupName</span><span class="hljs-params">(String jobGroupName)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.jobGroupName = jobGroupName;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">triggerName</span><span class="hljs-params">(String triggerName)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.triggerName = triggerName;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">triggerGroupName</span><span class="hljs-params">(String triggerGroupName)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.triggerGroupName = triggerGroupName;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">cron</span><span class="hljs-params">(String cron)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.cron = cron;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">params</span><span class="hljs-params">(Map&lt;String, Object&gt; param)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.param = <span class="hljs-keyword">new</span> JobDataMap(param);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">params</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.param.put(key, value);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章让你彻底了解Java内部类</title>
    <url>//post/java-basic-innerclass.html</url>
    <content><![CDATA[<h4 id="内容整理自《Thinking-in-Java》-第四版-第10章-PDF下载地址"><a href="#内容整理自《Thinking-in-Java》-第四版-第10章-PDF下载地址" class="headerlink" title="内容整理自《Thinking in Java》(第四版) 第10章 PDF下载地址 "></a>内容整理自《Thinking in Java》(第四版) 第10章<a href="https://download.csdn.net/download/sinat_34344123/10206155"> PDF下载地址 </a></h4><hr>
<h1 id="什么是内部类"><a href="#什么是内部类" class="headerlink" title="什么是内部类?"></a>什么是内部类?</h1><blockquote>
<p>将一个类的定义，放在另一个类的定义内部，那这个类，就是内部类</p>
</blockquote>
<a id="more"></a>

<hr>
<h1 id="为什么需要内部类？"><a href="#为什么需要内部类？" class="headerlink" title="为什么需要内部类？"></a>为什么需要内部类？</h1><p>　　一般来说，内部类继承自某个类或实现某个接口，内部类的代码操作创建其的外围类的对象。所以你可以认为内部类提供了某种进入其外围类的窗口。</p>
<hr>
<h1 id="内部类的优雅之处："><a href="#内部类的优雅之处：" class="headerlink" title="内部类的优雅之处："></a>内部类的优雅之处：</h1><blockquote>
<p>每个内部类都能独立的继承一个（接口的）实现，无论外部类是否已经继承了一个（接口的）实现，对内部类都没有影响。</p>
</blockquote>
<h1 id="内部类主要有以下几类："><a href="#内部类主要有以下几类：" class="headerlink" title="内部类主要有以下几类："></a><div id='TOP_TYPE'>内部类主要有以下几类：</div></h1><ul>
<li><a href="#A">A:成员内部类</a></li>
<li><a href="#B">B:局部内部类</a></li>
<li><a href="#C">C:静态内部类</a></li>
<li><a href="#D">D:匿名内部类</a></li>
</ul>
<p>注意:</p>
<ol>
<li>定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，<br> 即：<code>内部类 对象名 = 外部类对象.new 内部类( );</code></li>
<li>外部类是不能直接使用内部类的成员和方法滴，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法。</li>
<li>可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法。HelloWorld.this.name</li>
</ol>
<hr>
<h2 id="A：成员内部类"><a href="#A：成员内部类" class="headerlink" title="A：成员内部类"></a><div id='A'>A：成员内部类</div></h2><p> <a href="#TOP_TYPE">返回分类</a></p>
<blockquote>
<p>作为外部类的一个成员存在，与外部类的属性、方法并列。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> k = <span class="hljs-number">20</span>;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">outerF1</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 外部类的静态方法访问成员内部类，与在外部类外部访问成员内部类一样</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">outerF4</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//step1 建立外部类对象</span><br>        Outer out = <span class="hljs-keyword">new</span> Outer();<br>        <span class="hljs-comment">//step2 根据外部类对象建立内部类对象</span><br>        Inner inner = out.<span class="hljs-function">new <span class="hljs-title">Inner</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-comment">//step3 访问内部类的方法</span><br>        inner.innerF1();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * outerF4();该语句的输出结果和下面三条语句的输出结果一样</span><br><span class="hljs-comment">         *如果要直接创建内部类的对象，不能想当然地认为只需加上外围类Outer的名字，</span><br><span class="hljs-comment">         *就可以按照通常的样子生成内部类的对象，而是必须使用此外围类的一个对象来</span><br><span class="hljs-comment">         *创建其内部类的一个对象：</span><br><span class="hljs-comment">         *Outer.Inner outin = out.new Inner()</span><br><span class="hljs-comment">         *因此，除非你已经有了外围类的一个对象，否则不可能生成内部类的对象。因为此</span><br><span class="hljs-comment">         *内部类的对象会悄悄地链接到创建它的外围类的对象。如果你用的是静态的内部类，</span><br><span class="hljs-comment">         *那就不需要对其外围类对象的引用。</span><br><span class="hljs-comment">         */</span><br>        Outer out = <span class="hljs-keyword">new</span> Outer();<br>        Outer.Inner outin = out.n<span class="hljs-function">ew <span class="hljs-title">Inner</span><span class="hljs-params">()</span></span>;<br>        outin.innerF1();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">outerF2</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 外部类的非静态方法访问成员内部类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">outerF3</span><span class="hljs-params">()</span> </span>&#123;<br>        Inner inner = <span class="hljs-keyword">new</span> Inner();<br>        inner.innerF1();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 成员内部类中，不能定义静态成员</span><br><span class="hljs-comment">     * 成员内部类中，可以访问外部类的所有成员</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>&#123;<br>        <span class="hljs-comment">// static int innerI = 100;内部类中不允许定义静态变量</span><br>        <span class="hljs-comment">// 内部类和外部类的实例变量可以共存</span><br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">int</span> innerI = <span class="hljs-number">1</span>;<br><br><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">innerF1</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(i);<br>            <span class="hljs-comment">//在内部类中访问内部类自己的变量直接用变量名</span><br>            System.out.println(j);<br>            <span class="hljs-comment">//在内部类中访问内部类自己的变量也可以用this.变量名</span><br>            System.out.println(<span class="hljs-keyword">this</span>.j);<br>            <span class="hljs-comment">//在内部类中访问外部类中与内部类同名的实例变量用外部类名.this.变量名</span><br>            System.out.println(Outer.<span class="hljs-keyword">this</span>.j);<br>            <span class="hljs-comment">//如果内部类中没有与外部类同名的变量，则可以直接用变量名访问外部类变量</span><br>            System.out.println(k);<br>            outerF1();<br>            outerF2();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="注意：内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。"><a href="#注意：内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。" class="headerlink" title="注意：内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。"></a><font color=red>注意：内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。</font></h4><p><strong>对于一个名为outer的外部类和其内部定义的名为inner的内部类。编译完成后出现outer.class和outer$inner.class两类。</strong></p>
<hr>
<h2 id="B-局部内部类"><a href="#B-局部内部类" class="headerlink" title="B:局部内部类"></a><div id='B'>B:局部内部类</div></h2><p> <a href="#TOP_TYPE">返回分类</a></p>
<blockquote>
<p>在方法中定义的内部类称为局部内部类。与局部变量类似，局部内部类不能有访问说明符，因为它不是外围类的一部分，但是它可以访问当前代码块内的常量，和此外围类所有的成员。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> s = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> outI = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 访问局部内部类必须先有外部类对象</span><br>        Outer out = <span class="hljs-keyword">new</span> Outer();<br>        out.f(<span class="hljs-number">3</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> s = <span class="hljs-number">200</span>;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">10</span>;<br><br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 定义在方法内部</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>&#123;<br>            <span class="hljs-comment">// 可以定义与外部类同名的变量</span><br>            <span class="hljs-keyword">int</span> s = <span class="hljs-number">300</span>;<br>            <span class="hljs-keyword">int</span> innerI = <span class="hljs-number">100</span>;<br><br>            <span class="hljs-comment">// static int m = 20; 不可以定义静态变量</span><br>            Inner(<span class="hljs-keyword">int</span> k) &#123;<br>                innerF(k);<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">innerF</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>                <span class="hljs-comment">// java如果内部类没有与外部类同名的变量，在内部类中可以直接访问外部类的实例变量</span><br>                System.out.println(outI);<br>                <span class="hljs-comment">// 可以访问外部类的局部变量(即方法内的变量)，但是变量必须是final的</span><br>                System.out.println(j);<br>                <span class="hljs-comment">//System.out.println(i);</span><br>                <span class="hljs-comment">// 如果内部类中有与外部类同名的变量，直接用变量名访问的是内部类的变量</span><br>                System.out.println(s);<br>                <span class="hljs-comment">// 用this.变量名访问的也是内部类变量</span><br>                System.out.println(<span class="hljs-keyword">this</span>.s);<br>                <span class="hljs-comment">// 用外部类名.this.内部类变量名访问的是外部类变量</span><br>                System.out.println(Outer.<span class="hljs-keyword">this</span>.s);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">new</span> Inner(k);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="C：静态内部类-嵌套类-："><a href="#C：静态内部类-嵌套类-：" class="headerlink" title="C：静态内部类(嵌套类)："></a><div id='C'>C：静态内部类(嵌套类)：</div></h2><p> <a href="#TOP_TYPE">返回分类</a></p>
<p><code>注意：前两种内部类与变量类似，所以可以对照参考变量</code></p>
<blockquote>
<p>如果你不需要内部类对象与其外围类对象之间有联系，那你可以将内部类声明为static。这通常称为嵌套类（nested class）。想要理解static应用于内部类时的含义，你就必须记住，普通的内部类对象隐含地保存了一个引用，指向创建它的外围类对象。然而，当内部类是static的时，就不是这样了。嵌套类意味着：</p>
</blockquote>
<ol>
<li>要创建嵌套类的对象，并不需要其外围类的对象。</li>
<li>不能从嵌套类的对象中访问非静态的外围类对象。</li>
</ol>
<p><font color=red>单例模式:由于静态内部类的加载机制,决定了他可以使用来处理单例模式,而且性能客观</font>单例模式相关内容&gt;&gt;<a href="https://blog.csdn.net/sinat_34344123/article/details/81943772">点我</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">outerF1</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Outer().outerF3();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">outerF2</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">outerF3</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 外部类访问内部类的静态成员：内部类.静态成员</span><br>        System.out.println(Inner.inner_i);<br>        Inner.innerF1();<br>        <span class="hljs-comment">// 外部类访问内部类的非静态成员:实例化内部类即可</span><br>        Inner inner = <span class="hljs-keyword">new</span> Inner();<br>        inner.innerF2();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 静态内部类可以用public,protected,private修饰</span><br><span class="hljs-comment">     * 静态内部类中可以定义静态或者非静态的成员</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>&#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> inner_i = <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">int</span> innerJ = <span class="hljs-number">200</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">innerF1</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">// 静态内部类只能访问外部类的静态成员(包括静态变量和静态方法)</span><br>            System.out.println(<span class="hljs-string">&quot;Outer.i&quot;</span> + i);<br>            outerF1();<br>        &#125;<br><br><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">innerF2</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">// 静态内部类不能访问外部类的非静态成员(包括非静态变量和非静态方法)</span><br>            <span class="hljs-comment">// System.out.println(&quot;Outer.i&quot;+j);</span><br>            <span class="hljs-comment">// outerF2();</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="静态内部类和成员内部类的区别"><a href="#静态内部类和成员内部类的区别" class="headerlink" title="静态内部类和成员内部类的区别"></a>静态内部类和成员内部类的区别</h3><blockquote>
<p>生成一个静态内部类不需要外部类成员<br>静态内部类的对象可以直接生成：<br><code>Outer.Inner in = new Outer.Inner(); </code><br>而不需要通过生成外部类对象来生成。这样实际上使静态内部类成为了一个顶级类<br>(正常情况下，你不能在接口内部放置任何代码，但嵌套类可以作为接口的一部分，因为它是static 的。只是将嵌套类置于接口的命名空间内，这并不违反接口的规则）</p>
</blockquote>
<hr>
<h2 id="D：匿名内部类-from-thinking-in-java-3th"><a href="#D：匿名内部类-from-thinking-in-java-3th" class="headerlink" title="D：匿名内部类(from thinking in java 3th)"></a><div id='D'>D：匿名内部类(from thinking in java 3th)</div></h2><p> <a href="#TOP_TYPE">返回分类</a></p>
<blockquote>
<p>匿名内部类就是没有名字的内部类。</p>
</blockquote>
<h3 id="什么情况下需要使用匿名内部类？"><a href="#什么情况下需要使用匿名内部类？" class="headerlink" title="什么情况下需要使用匿名内部类？"></a>什么情况下需要使用匿名内部类？</h3><p><strong>如果满足下面的一些条件，使用匿名内部类是比较合适的：</strong></p>
<ul>
<li>只用到类的一个实例。</li>
<li>类在定义后马上用到。</li>
<li>类非常小（SUN推荐是在4行代码以下）</li>
<li>给类命名并不会导致你的代码更容易被理解。</li>
</ul>
<p><strong>在使用匿名内部类时，要记住以下几个原则：</strong></p>
<ol>
<li>匿名内部类一般不能有构造方法。</li>
<li>匿名内部类不能定义任何静态成员、方法和类。</li>
<li>匿名内部类不能是public,protected,private,static。</li>
<li>只能创建匿名内部类的一个实例。</li>
<li>一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。</li>
<li>因匿名内部类为局部内部类，所以局部内部类的所有限制都对其生效。</li>
</ol>
<p><em>下面的例子看起来有点奇怪：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在方法中返回一个匿名内部类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parcel6</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Parcel6 p = <span class="hljs-keyword">new</span> Parcel6();<br>        Contents c = p.cont();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Contents <span class="hljs-title">cont</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Contents() &#123;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">11</span>;<br><br><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;; <span class="hljs-comment">// 在这里需要一个分号</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>　　<code>cont()</code>方法将下面两个动作合并在一起：返回值的生成，与表示这个返回值的类的定义！<br>　　进一步说，这个类是匿名的，它没有名字。更糟的是，看起来是你正要创建一个Contents对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Contents()<br></code></pre></td></tr></table></figure>

<p>　　但是，在到达语句结束的分号之前，你却说：“等一等，我想在这里插入一个类的定义”:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Contents() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">11</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>　　这种奇怪的语法指的是：“创建一个继承自Contents的匿名类的对象。”通过new 表达式返回的引用被自动向上转型为对Contents的引用。匿名内部类的语法是下面例子的简略形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyContents</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Contents</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">11</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyContents();<br></code></pre></td></tr></table></figure>


<p>　　在这个匿名内部类中，使用了缺省的构造器来生成Contents。下面的代码展示的是，如果你的基类需要一个有参数的构造器，应该怎么办：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parcel7</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Parcel7 p = <span class="hljs-keyword">new</span> Parcel7();<br>        Wrapping w = p.wrap(<span class="hljs-number">10</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Wrapping <span class="hljs-title">wrap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-comment">// Base constructor call:</span><br>        <span class="hljs-comment">// Pass constructor argument.</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Wrapping(x) &#123; <br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.value() * <span class="hljs-number">47</span>;<br>            &#125;<br>        &#125;; <span class="hljs-comment">// Semicolon required</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>　　只需简单地传递合适的参数给基类的构造器即可，这里是将x 传进new Wrapping(x)。在匿名内部类末尾的分号，并不是用来标记此内部类结束（C++中是那样）。实际上，它标记的是表达式的结束，只不过这个表达式正巧包含了内部类罢了。因此，这与别的地方使用的分号是一致的。</p>
<p>　　如果在匿名类中定义成员变量，你同样能够对其执行初始化操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parcel8</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Parcel8 p = <span class="hljs-keyword">new</span> Parcel8();<br>        Destination d = p.dest(<span class="hljs-string">&quot;Tanzania&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Argument must be final to use inside</span><br>    <span class="hljs-comment">// anonymous inner class:</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Destination <span class="hljs-title">dest</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String dest)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Destination() &#123;<br>            <span class="hljs-keyword">private</span> String label = dest;<br><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">readLabel</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> label;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<p>　　如果你有一个匿名内部类，它要使用一个在它的外部定义的对象，编译器会要求其参数引用是final 型的，就像<code>dest()</code>中的参数。如果你忘记了，会得到一个编译期错误信息。如果只是简单地给一个成员变量赋值，那么此例中的方法就可以了。但是，如果你想做一些类似构造器的行为，该怎么办呢？在匿名类中不可能有已命名的构造器（因为它根本没名字！），但通过实例初始化，你就能够达到为匿名内部类“制作”一个构造器的效果。像这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Base</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Base constructor, i = &quot;</span> + i);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnonymousConstructor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Base <span class="hljs-title">getBase</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Base(i) &#123;<br>            &#123;<br>                System.out.println(<span class="hljs-string">&quot;Inside instance initializer&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;In anonymous f()&quot;</span>);<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Base base = getBase(<span class="hljs-number">47</span>);<br>        base.f();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>　　在此例中，不要求变量i 一定是final 的。因为i 被传递给匿名类的基类的构造器，它并不会在匿名类内部被直接使用。下例是带实例初始化的“parcel”形式。注意dest()的参数必须是final，因为它们是在匿名类内被使用的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parcel9</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Destinationdest</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String dest, <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> price)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Destination() &#123;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cost;<br>            <span class="hljs-keyword">private</span> String label = dest;<br><br>            <span class="hljs-comment">// Instance initialization for each object:</span><br>            &#123;<br>                cost = Math.round(price);<br>                <span class="hljs-keyword">if</span> (cost &gt; <span class="hljs-number">100</span>)<br>                    System.out.println(<span class="hljs-string">&quot;Over budget!&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">readLabel</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> label;<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Parcel9 p = <span class="hljs-keyword">new</span> Parcel9();<br>        Destination d = p.dest(<span class="hljs-string">&quot;Tanzania&quot;</span>, <span class="hljs-number">101.395F</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>　　在实例初始化的部分，你可以看到有一段代码，那原本是不能作为成员变量初始化的一部分而执行的（就是if 语句）。所以对于匿名类而言，实例初始化的实际效果就是构造器。当然它受到了限制：你不能重载实例初始化，所以你只能有一个构造器。</p>
<hr>
<h3 id="从多层嵌套类中访问外部"><a href="#从多层嵌套类中访问外部" class="headerlink" title="从多层嵌套类中访问外部"></a>从多层嵌套类中访问外部</h3><p>　　一个内部类被嵌套多少层并不重要，它能透明地访问所有它所嵌入的外围类的所有成员，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MNA</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;<br>            <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span> </span>&#123;<br>                g();<br>                f();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiNestingAccess</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MNA mna = <span class="hljs-keyword">new</span> MNA();<br>        MNA.A mnaa = mna.n<span class="hljs-function">ew <span class="hljs-title">A</span><span class="hljs-params">()</span></span>;<br>        MNA.A.B mnaab = mnaa.n<span class="hljs-function">ew <span class="hljs-title">B</span><span class="hljs-params">()</span></span>;<br>        mnaab.h();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>　　可以看到在MNA.A.B中，调用方法g()和f()不需要任何条件（即使它们被定义为private）。这个例子同时展示了如何从不同的类里面创建多层嵌套的内部类对象的基本语法。“.new”语法能产生正确的作用域，所以你不必在调用构造器时限定类名。</p>
<hr>
<h3 id="内部类的重载问题"><a href="#内部类的重载问题" class="headerlink" title="内部类的重载问题"></a>内部类的重载问题</h3><blockquote>
<p>如果你创建了一个内部类，然后继承其外围类并重新定义此内部类时，会发生什么呢？也就是说，内部类可以被重载吗？这看起来似乎是个很有用的点子，但是“重载”内部类就好像它是外围类的一个方法，其实并不起什么作用：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Egg</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Yolk y;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Egg</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;New Egg()&quot;</span>);<br>        y = <span class="hljs-keyword">new</span> Yolk();<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Yolk</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Yolk</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;Egg.Yolk()&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigEgg</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Egg</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> BigEgg();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Yolk</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Yolk</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;BigEgg.Yolk()&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function">New <span class="hljs-title">Egg</span><span class="hljs-params">()</span></span><br><span class="hljs-function">Egg.<span class="hljs-title">Yolk</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<p>　　缺省的构造器是编译器自动生成的，这里是调用基类的缺省构造器。你可能认为既然创建了BigEgg 的对象，那么所使用的应该是被“重载”过的Yolk，但你可以从输出中看到实际情况并不是这样的。</p>
<p>　　这个例子说明，当你继承了某个外围类的时候，内部类并没有发生什么特别神奇的变化。这两个内部类是完全独立的两个实体，各自在自己的命名空间内。当然，明确地继承某个内部类也是可以的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Egg2</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Yolk y = <span class="hljs-keyword">new</span> Yolk();<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Egg2</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;New Egg2()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertYolk</span><span class="hljs-params">(Yolk yy)</span> </span>&#123;<br>        y = yy;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123;<br>        y.f();<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Yolk</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Yolk</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;Egg2.Yolk()&quot;</span>);<br>        &#125;<br><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;Egg2.Yolk.f()&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigEgg2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Egg2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BigEgg2</span><span class="hljs-params">()</span> </span>&#123;<br>        insertYolk(<span class="hljs-keyword">new</span> Yolk());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Egg2 e2 = <span class="hljs-keyword">new</span> BigEgg2();<br>        e2.g();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Yolk</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Egg2</span>.<span class="hljs-title">Yolk</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Yolk</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;BigEgg2.Yolk()&quot;</span>);<br>        &#125;<br><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;BigEgg2.Yolk.f()&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Egg2.Yolk()<br><span class="hljs-function">New <span class="hljs-title">Egg2</span><span class="hljs-params">()</span></span><br><span class="hljs-function">Egg2.<span class="hljs-title">Yolk</span><span class="hljs-params">()</span></span><br><span class="hljs-function">BigEgg2.<span class="hljs-title">Yolk</span><span class="hljs-params">()</span></span><br><span class="hljs-function">BigEgg2.Yolk.<span class="hljs-title">f</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<p>　　现在<code>BigEgg2.Yolk</code> 通过<code>extends Egg2.Yolk</code> 明确地继承了此内部类，并且重载了其中的方法。<code>Egg2</code> 的<code>insertYolk()</code>方法使得<code>BigEgg2</code> 将它自己的<code>Yolk</code> 对象向上转型，然后传递给引用y。所以当<code>g()</code>调用<code>y.f()</code>时，重载后的新版的f()被执行。第二次调用<code>Egg2.Yolk()</code>是<code>BigEgg2.Yolk</code> 的构造器调用了其基类的构造器。可以看到在调用<code>g()</code>的时候，新版的<code>f()</code>被调用了。</p>
<hr>
<h3 id="内部类的继承问题（thinking-in-java-3th-p294）"><a href="#内部类的继承问题（thinking-in-java-3th-p294）" class="headerlink" title="内部类的继承问题（thinking in java 3th p294）"></a>内部类的继承问题（thinking in java 3th p294）</h3><blockquote>
<p>因为内部类的构造器要用到其外围类对象的引用，所以在你继承一个内部类的时候，事情变得有点复杂。问题在于，那个“秘密的”外围类对象的引用必须被初始化，而在被继承的类中并不存在要联接的缺省对象。要解决这个问题，需使用专门的语法来明确说清它们之间的关联：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WithInner</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>&#123;<br>        Inner() &#123;<br>            System.out.println(<span class="hljs-string">&quot;this is a constructor in WithInner.Inner&quot;</span>);<br>        &#125;<br><br>        ;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritInner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WithInner</span>.<span class="hljs-title">Inner</span> </span>&#123;<br>    <span class="hljs-comment">// ! InheritInner() &#123;&#125; // Won&#x27;t compile</span><br>    InheritInner(WithInner wi) &#123;<br>        wi.<span class="hljs-keyword">super</span>();<br>        System.out.println(<span class="hljs-string">&quot;this is a constructor in InheritInner&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        WithInner wi = <span class="hljs-keyword">new</span> WithInner();<br>        InheritInner ii = <span class="hljs-keyword">new</span> InheritInner(wi);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>
<p>　输出结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">this</span> is a constructor in WithInner.Inner<br><span class="hljs-keyword">this</span> is a constructor in InheritInner<br></code></pre></td></tr></table></figure>

<p>　　可以看到，InheritInner 只继承自内部类，而不是外围类。但是当要生成一个构造器时，缺省的构造器并不算好，而且你不能只是传递一个指向外围类对象的引用。此外，你必须在构造器内使用如下语法：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">enclosingClassReference.super()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
<h2 id="关于Java回调函数"><a href="#关于Java回调函数" class="headerlink" title="关于Java回调函数"></a>关于Java回调函数</h2><blockquote>
<p>在Java中，通常就是编写另外一个类或类库的人规定一个接口，然后你来实现这个接口，然后把这个接口的一个对象作为参数传给别人的程序，别人的程序必要时就会通过那个接口来调用你编写的函数,执行后续的一些方法,。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallBack</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        CallBack callBack = <span class="hljs-keyword">new</span> CallBack();<br>        callBack.toDoSomethings(<span class="hljs-number">100</span>, <span class="hljs-keyword">new</span> CallBackInterface() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;我的请求处理成功了&quot;</span>);<br>            &#125;<br>        &#125;);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">toDoSomethings</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, CallBackInterface callBackInterface)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>        <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">100</span>) &#123;<br>            callBackInterface.execute();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;a &lt; 100 不需要执行回调方法&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;该接口回调时间 : &quot;</span> + (end - start));<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CallBackInterface</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Java回调的实现,是不是就是基于匿名内部类实现的呢?答案是肯定的.</p>
<p>Java里的回调,可以说是匿名内部类精彩表演,优美的编码风格,真是让人陶醉~</p>
<hr>
<p>参考</p>
<ul>
<li><a href="https://download.csdn.net/download/sinat_34344123/10206155">Thinking in Java</a></li>
<li><a href="https://blog.csdn.net/hikvision_java_gyh/article/details/8964155">https://blog.csdn.net/hikvision_java_gyh/article/details/8964155</a> 《JAVA内部类 （吐血之作）</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>和 lvgo 一起学设计模式（零）序</title>
    <url>//post/learn-design-patterns-with-lvgo.html</url>
    <content><![CDATA[<h1 id="java-design-patterns"><a href="#java-design-patterns" class="headerlink" title="java-design-patterns"></a>java-design-patterns</h1><p>　　Java 设计模式专题，共 23 种设计模式。内容来自个人学习理解消化的结果，谈不上教程，只望记录于此同你分享。希望能够和大家一起进步、成长。为了梦想，学习技术。如果看过内容觉得还可以就点个 star ⭐ 吧 ヾ(≧▽≦*)o <a href="https://github.com/lvgocc/java-design-patterns">https://github.com/lvgocc/java-design-patterns</a></p>
<h1 id="“别废话！下面那些我都不想看，我想直接学习！”-“好的大哥，这就安排！”"><a href="#“别废话！下面那些我都不想看，我想直接学习！”-“好的大哥，这就安排！”" class="headerlink" title="“别废话！下面那些我都不想看，我想直接学习！” “好的大哥，这就安排！”"></a>“别废话！下面那些我都不想看，我想直接学习！” “好的大哥，这就安排！”</h1><ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://github.com/lvgocc/java-design-patterns/tree/main/singleton">1. 单例模式: 资源！要合理的分配使用！</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://github.com/lvgocc/java-design-patterns/tree/main/prototype">2. 原型模式：啥？盗图、盗文章的人居然用的是一种设计模式！叫原型模式？</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://github.com/lvgocc/java-design-patterns/tree/main/factory">3. 工厂模式：像工厂一样创建对象，让业务代码更专注！</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://github.com/lvgocc/java-design-patterns/tree/main/abstract-factory">4. 抽象工厂模式：抽象工厂模式和工厂模式有区别吗？</a></li>
</ul>
<h1 id="软件设计模式背景"><a href="#软件设计模式背景" class="headerlink" title="软件设计模式背景"></a>软件设计模式背景</h1><blockquote>
<p>当我们要学习一门技术或者一类知识的时候，先去了解学习它的背景，会对我们接下来的学习和理解产生一些潜移默化的影响和帮助</p>
</blockquote>
<h2 id="“设计模式”最初的提出，是在建筑领域。🌉"><a href="#“设计模式”最初的提出，是在建筑领域。🌉" class="headerlink" title="“设计模式”最初的提出，是在建筑领域。🌉"></a>“设计模式”最初的提出，是在建筑领域。🌉</h2><p>　　1977 年被美国的建筑大师🕍 克里斯托夫·亚历山大 （Christopher Alexander）在他的著作📕《建筑模式语言：城镇、建筑、构造（A Pattern Language: Towns Building Construction）中描述了一些常见的建筑设计问题，并提出了一系列的解决方案， 至此称为模式。<br>　　<br>　　2年后，1979年，克里斯托夫·亚历山大 在他的另一本著作📙《建筑的永恒之道》（The Timeless Way of Building）进一步强化了设计模式的思想。<br>　　<br>　　直到 1990 年，也就是 13 年后。设计模式一词才到了软件工程界，同时为此开辟了专题研讨会。</p>
<h2 id="GOF👨‍🦲👦👨🧑"><a href="#GOF👨‍🦲👦👨🧑" class="headerlink" title="GOF👨‍🦲👦👨🧑"></a>GOF👨‍🦲👦👨🧑</h2><p>　　在“设计模式”进入软件行业后的第5年，也就是 1995 年，艾瑞克·伽马（ErichGamma）👨‍🦲、理査德·海尔姆（Richard Helm）👦、拉尔夫·约翰森（Ralph Johnson）👨、约翰·威利斯迪斯（John Vlissides）🧑等 4 位作者合作出版了📘《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software）一书。</p>
<p>　　从此掀起了软件工程界的“设计模式”浪潮，使越来越多的开发者受益，同时涌现出了越来越多的设计模式。而这 4 位作者在软件领域小组名称 Gang of Four 四人组（四人帮），后来设计模式也以此匿名著称 GOF。</p>
<p><img src="https://i.loli.net/2020/10/08/CHaE8bzvX4fScYA.jpg" alt="gof"></p>
<h2 id="设计模式要做的事情"><a href="#设计模式要做的事情" class="headerlink" title="设计模式要做的事情"></a>设计模式要做的事情</h2><p>　　现如今的设计模式可远不止笔者这里收录整理学习的 23 种，而要比这多太多太多，但这么多的设计模式希望做的事情确实相同的。都是为了能够被反复利用，解决不断重复出现的问题而存在的，就像当初 GOF 写的那本书一样，‘可复用面向对象的基础’。</p>
<p>　　一种方法，解决n种问题。这就是模式，它要解决的，就是拥有共性的问题。</p>
<h1 id="设计模式基本原则"><a href="#设计模式基本原则" class="headerlink" title="设计模式基本原则"></a>设计模式基本原则</h1><p>　　当问题的解决方案有很多时，该怎么权衡哪一个方案可以成为是模式呢？这就有了原则性的约束。为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，我们应当要尽量根据 <strong>⑦</strong> 条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p>
<ul>
<li><p>1️⃣ 开闭原则 OCP ， 1988 年 勃兰特·梅耶（Bertrand Meyer）在其著作《面向对象软件构造》📕中提出 ：<u>软件实体应当对扩展开放，对修改关闭</u>。</p>
</li>
<li><p>2️⃣ 里式替换原则 LSP ，1987 年 里斯科夫（Liskov）女士👩‍🦰 的“面向对象技术的高峰会议”（OOPSLA）上发表的一篇文章《数据抽象和层次》📜提出：<u>继承必须确保超类所拥有的性质在子类中仍然成立</u>。</p>
</li>
<li><p>3️⃣ 依赖倒置原则 DIP ，1996 年 Object Mentor 公司总裁罗伯特·马丁（Robert C.Martin）🧑在 <a href="http://c.biancheng.net/cplus/">C++</a> Report 上发表的文章 ：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象 （<u>要面向接口编程，不要面向实现编程。</u>）</p>
</li>
<li><p>4️⃣ 单一职责原则 SRP，罗伯特·C.马丁🧑（与DIP原则同一人）（Robert C. Martin）于《敏捷软件开发：原则、模式和实践》一书中提出的。这里的职责是指类变化的原因，单一职责原则规定一<u>个类应该有且仅有一个引起它变化的原因，否则类应该被拆分</u></p>
</li>
<li><p>5️⃣ 接口隔离原则 ISP，2002 年罗伯特·C.马丁🧑 给“接口隔离原则”的定义是：客户端不应该被迫依赖于它不使用的方法。该原则还有另外一个定义：一个类对另一个类的依赖应该建立在最小的接口上。以上两个定义的含义是：<u>要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用</u>。</p>
</li>
<li><p>6️⃣ 迪米特法则又叫作最少知识原则 LOD/LKP ，1987 年美国东北大学👨‍🎓（Northeastern University）的一个名为迪米特（Demeter）的研究项目，由伊恩·荷兰（Ian Holland）提出，被 UML 创始人之一布奇（Booch）🧙‍♂️普及，后来又在经典著作《程序员修炼之道》📕中提及，从而传播开来。原则定义：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：<u>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用</u>。其目的是降低类之间的耦合度，提高模块的相对独立性。</p>
</li>
<li><p>7️⃣ 合成复用原则 CRP 又叫组合/聚合复用原则，提倡<u>软件复用过程中，优先使用组合复用，其次考虑继承</u>，(如果使用继承，必须遵循里式替换原则)，它与里式替换原则相辅相成。</p>
</li>
</ul>
<blockquote>
<p>对于原则的定义和约束，在多个设计模式中会有具体体现及说明。</p>
</blockquote>
<h1 id="🎨-设计模式分类"><a href="#🎨-设计模式分类" class="headerlink" title="🎨 设计模式分类"></a>🎨 设计模式分类</h1><p>　　根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。</p>
<blockquote>
<p>每种类型在对应部分中会再进行着重说明</p>
</blockquote>
<ol>
<li>🏗创建型模式：用于描述“<u>怎样创建对象</u>”，它的主要特点是“<u>将对象的创建与使用分离</u>”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</li>
<li>🖇结构型模式：用于描述<u>如何将类或对象按某种布局组成更大的结构</u>，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</li>
<li>🎭行为型模式：用于描述<u>类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责</u>。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</li>
</ol>
<p><strong>在通过表格的形式帮助理解学习和记忆</strong></p>
<p>我希望用一些不同的颜色背景来区分那些我们常用而且必须熟知的一些模式。</p>
<table>
<caption>按照类型划分</caption>
    <tr>
        <th>类型</th>
        <th>模式</th>
        <th>类型</th>
        <th>模式</th>
        <th>类型</th>
        <th>模式</th>
    </tr >
    <tr >
        <td rowspan="5">创建型(5)</td>
        <td>单例</td>
        <td rowspan="7">结构型(7)</td>
        <td>代理</td>
        <td rowspan="11">行为型(11)</td>
        <td>模板方法</td>
    </tr>
    <tr>
        <td>原型</td>
        <td>适配器</td>
        <td>策略</td>
    </tr>
    <tr>
        <td>建造者</td>
        <td>桥接</td>
        <td>命令</td>
    </tr>
    <tr>
        <td>工厂</td>
        <td>装饰</td>
        <td>职责链</td>
    </tr>
    <tr>
        <td>抽象工厂</td>
        <td>外观/门面</td>
        <td>状态</td>
    </tr>    
    <tr>
        <td></td>        
        <td></td>
        <td>享元</td>
        <td>观察者</td>
    </tr>  
    <tr>
        <td></td>        
        <td></td>
        <td>组合</td>
        <td>中介者</td>
    </tr>    
    <tr>
        <td></td>        
        <td></td>
        <td></td>
        <td></td>
        <td>迭代器</td>
    </tr>    
    <tr>
        <td></td>        
        <td></td>
        <td></td>
        <td></td>
        <td>访问者</td>
    </tr>    
    <tr>
        <td></td>        
        <td></td>
        <td></td>
        <td></td>
        <td>备忘录</td>
    </tr>    
    <tr>
        <td></td>        
        <td></td>
        <td></td>
        <td></td>
        <td>解释器</td>
    </tr>    
</table>


<p><strong>按照作用来划分</strong></p>
<table>
<thead>
<tr>
<th>范围\目的</th>
<th>创建型模式</th>
<th>结构型模式</th>
<th>行为型模式</th>
</tr>
</thead>
<tbody><tr>
<td>类模式</td>
<td>工厂方法</td>
<td>(类)适配器</td>
<td>模板方法<br />解释器</td>
</tr>
<tr>
<td>对象模式</td>
<td>单例<br />原型<br />建造<br />抽象工厂</td>
<td>(对象)适配器<br />外观<br />装饰<br />桥接<br />代理<br />享元<br />组合</td>
<td>状态<br />命令<br />责任链<br />策略<br />观察者<br />中介者<br />访问者<br />备忘录<br />迭代器</td>
</tr>
</tbody></table>
<p>以上我们已经对设计模式有一个比较全面的简单了解了. 那么现在，开始吧！</p>
<hr>
<p><strong>以下分类中可点击的模式为已完成部分，其他未完成部分正在努力“生产”</strong></p>
<h2 id="🏗-创建型-5"><a href="#🏗-创建型-5" class="headerlink" title="🏗 创建型(5)"></a>🏗 创建型(5)</h2><ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://github.com/lvgocc/java-design-patterns/tree/main/singleton">1. 单例（Singleton）模式: 某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://github.com/lvgocc/java-design-patterns/tree/main/prototype">2. 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://github.com/lvgocc/java-design-patterns/tree/main/factory">3. 工厂（Factory）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://github.com/lvgocc/java-design-patterns/tree/main/abstract-factory">4. 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</a></li>
<li><input disabled="" type="checkbox"> 5.建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li>
</ul>
<h2 id="🖇-结构型-7"><a href="#🖇-结构型-7" class="headerlink" title="🖇 结构型(7)"></a>🖇 结构型(7)</h2><ul>
<li><input disabled="" type="checkbox"> 1.代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li>
<li><input disabled="" type="checkbox"> 2.适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li>
<li><input disabled="" type="checkbox"> 3.桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</li>
<li><input disabled="" type="checkbox"> 4.装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。</li>
<li><input disabled="" type="checkbox"> 5.外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li>
<li><input disabled="" type="checkbox"> 6.享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li>
<li><input disabled="" type="checkbox"> 7.组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li>
</ul>
<h2 id="🎭-行为型-11"><a href="#🎭-行为型-11" class="headerlink" title="🎭 行为型(11)"></a>🎭 行为型(11)</h2><ul>
<li><input disabled="" type="checkbox"> 1.模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li>
<li><input disabled="" type="checkbox"> 2.策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li>
<li><input disabled="" type="checkbox"> 3.命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li>
<li><input disabled="" type="checkbox"> 4.职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li>
<li><input disabled="" type="checkbox"> 5.状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li>
<li><input disabled="" type="checkbox"> 6.观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li>
<li><input disabled="" type="checkbox"> 7.中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li>
<li><input disabled="" type="checkbox"> 8.迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li>
<li><input disabled="" type="checkbox"> 9.访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li>
<li><input disabled="" type="checkbox"> 10.备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li>
<li><input disabled="" type="checkbox"> 11.解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li>
</ul>
<h1 id="系列专题"><a href="#系列专题" class="headerlink" title="系列专题"></a>系列专题</h1><p>　　该设计模式专题将用以记录笔者技术生涯的一次沉淀过程，一共会分为 23 篇文章以及对应的源码内容，文中内容和源码均为自我理解学习沉淀分享，目的与各位一起学习，一起完成心中的梦想。</p>
<p>　　笔者技术水平、理解能力均有限，如有读者发现有歧义甚至错误的地方，希望可以通过评论或私信或邮箱等等让我知道的途径提醒笔者改正。记得点个 star ⭐ 哦 ヾ(≧▽≦*)o <a href="https://github.com/lvgocc/java-design-patterns">https://github.com/lvgocc/java-design-patterns</a></p>
<h1 id="参（ju）考（ren）文（jian）献（bang）"><a href="#参（ju）考（ren）文（jian）献（bang）" class="headerlink" title="参（jù）考（rén）文（jiān）献（bǎng）"></a>参（jù）考（rén）文（jiān）献（bǎng）</h1><p>　　非常感谢以下平台或个人的无私贡献知识资源，才能够让我有更多机会去学习了解各类知识。同时在此列出系列文章中的全部出处来源，同时后续在各篇独立文章中如有涉及也会尽可能的列出。排名不分先后。</p>
<ul>
<li><p><a href="http://c.biancheng.net/design_pattern/">http://c.biancheng.net/design_pattern/</a></p>
</li>
<li><p><a href="https://refactoringguru.cn/design-patterns">https://refactoringguru.cn/design-patterns</a></p>
</li>
<li><p><a href="https://www.journaldev.com/31902/gangs-of-four-gof-design-patterns">https://www.journaldev.com/31902/gangs-of-four-gof-design-patterns</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
